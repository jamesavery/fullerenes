      PROGRAM Fullerene
      IMPLICIT REAL*8 (A-H,O-Z)
C---------------------------------------------------------------------- 
C
C  PROGRAM FULLERENE FOR TOPOLOGICAL ANALYSIS OF FULLERENES
C    A program to create good cartesian coordinates for
C    for fullerenes for input into QM program packages, or to analyze
C    outputs from these packages in terms of their topology.
C    Version 3.3 is the first complete version, for the future 
C    For upcoming version 4 there will be major changes including
C    much better algorithms for many of the features presented here.
C
C---------------------------------------------------------------------- 
C  R U N N I N G    T H E    P R O G R A M:
C---------------------------------------------------------------------- 
C* This program works with the gfortran compiler      gfortran -w
C    You can use the make file included in c60.zip for fullerene.f
C    The executable "fullerene" runs on a mac intel:
C      ./fullerene <inp >out
C    You can also use the g77 compiler, but need to change date and time
C      calls in the main routine, which are commented out with G77
C    If you type      make tests      it runs all the input jobs and
C      puts them into *.out
C
C----------------------------------------------------------------------
C  G E N E R A L   D E S C R I P T I O N:
C---------------------------------------------------------------------- 
C    The program is written in standard Fortran (~8400 lines)
C    Some standard routines from Mathematical Recepies were modified and
C    are used here for matrix diagonalization and geometry optimization.
C
C* Function: To perform a topological analysis of a regular fullerene 
C    (i.e. consisting of pentagons and hexagons) fulfilling Euler's theorem, 
C    and to calculate the volume through tessellation into (irregular) 
C    tetrahedrons with origin at the center of points (for carbon atoms 
C    only it would be the center of mass). Further to construct the cartesian
C    coordinates from the canonical ring spiral pentagon indices. Note that 
C    there is no unique definition for the volume of a fullerene for
C    nonplanar 5- or 6-rings on the fullerene surface, but there is no 
C    reason why any other definition than the tesselation algorithm
C    should be preferred. Another possibility is to use of the convex hull 
C    yet to be implemented. The Wu force-field and geometry optimization 
C    using a Fletcher-Reeves-Polak-Ribiere minimization with analytical 
C    gradients is also implemented, providing good initial guess for 
C    cartesian coordinates.
C
C    Note: This program works for any (distorted or not) regular fullerene.
C     The spiral algorithm of Fowler and Manolopoulus is not
C     restricted to starting from a pentagon, for example all isomes
C     for C100 are obtained including the spiral starting from a hexagon
C     for the Td isomer. For a general list of fullerenes see
C     "The House of graphs" at https://hog.grinvin.org/Fullerenes. 
C
C    Lit.: 1) P. Schwerdtfeger, "Topological Analysis of Fullerenes - A Fortran
C    ----     Program (Version 3.3)", Massey University Albany, 
C             Auckland, New Zealand (2012).
C          2) P. W. Fowler and D. E. Manopoulus, "An Atlas of Fullerenes" 
C             (Dover Publ., New York, 2006).
C          3) D. Babic, "Nomenclature and Coding of Fullerenes",
C             J. Chem. Inf. Comput. Sci. 35, 515-526 (1995).
C          4) Z. C. Wu, D. A. Jelski, T. F. George, "Vibrational Motions of
C             Buckminsterfullerene", Chem. Phys. Lett. 137, 291-295 (1987).
C
C      Further reading:
C          5) D. E. Manopoulus and P. W. Fowler, "Molecular graphs, point groups, 
C             and fullerenes", J. Chem. Phys. 96, 7603-7614 (1992).
C          6) G. B. Adams, M. O'Keefe, and R. S. Ruoff, "Van der Waals Surface Areas
C             and Volumes of Fullerenes", J. Phys. Chem. 98, 9465-9469 (1994).
C          7) W. O. J. Boo, "An Introduction to Fullerene Structures",
C             J. Chem. Ed. 69, 605-609 (1992).
C          8) D. Babic, D. J. Klein and C. H. Sah, "Symmetry of fullerenes",
C             Chem. Phys. Lett. 211 (1993) 235-241.
C          9) R. Tonner, G. Frenking, M. Lein, and P. Schwerdtfeger, 
C             "Packed to the Rafters – Filling up C60 with Rare Gas Atoms", 
C             Chem. Phys. Chem. 12, 2081-2084 (2011).
C         10) G. Brinkmann, J. Goedgebeur, B. D. McKay, "The smallest fullerene 
C             without a spiral", Chem. Phys. Lett. 522, 54–55 (2012).
C
C      There is a paper in preparation which explains most of the features
C        in this program. You may ask for a preliminary copy.
C
C      If you use the CYLview program the input file is written into cylview.dat.
C        CYLview plots molecules, is written by C. Y. Legault and is available
C        under http://www.cylview.org/Home.html
C
C      If you use QMGA for plotting fullerene graphs the input file is written
C        in qmga.dat. The program is available at http://qmga.sourceforge.net/
C        In this case you need to cite A. T. Gabriel, T. Meyer, G. Germano, 
C        "Molecular graphics of convex body fluids", J. Chem. Theory Comput. 
C        4, 468-476 (2008).
C
C   -----------------------------------------------------------------------------
C   |  NOTE: You may do whatever you like with this program, but if you use it  |
C   |  and publish data please cite at least references 1-4 given above.        |
C   |  The book by Fowler and Manopoulus is highly recommended.                 |
C   |  It helps understanding how this program works (the book is fun to read!).|
C   |  Many of the concepts used in this program can be found in this book.     |
C   -----------------------------------------------------------------------------
C
C   Important steps in the program are:
C--------------------------------------
C - Read in Cartesian coordinates for a fullerene (see files c20.inp to c540.inp), 
C   or construct them for the Ih isomer (files ico.inp, icoExp.inp, icoideal.inp)
C   of C60, or get cartesian coordinates from ring spiral pentagon indices
C   as defined in refs.2 and 5 (files pentagon1.inp to pentagon8.inp). Center of 
C   the fullerene is set to the origin.
C   See ref.2 for the construction of cartesian coordinates from pentagon indices
C   and the use of P-type eigenvectors. Note it is critical to get the right
C   vectors for the construction of the cartesian coordinates. The 3 P-type
C   vectors may need to be read in (see file pentagon8.inp for such an example).
C   It is important that the end-product is viewed by molecular visualization.
C   program. We recommend CYLview by Claude Legault (see http://www.cylview.org).
C   For this purpose an input file is written out to cylview.xyz to be used
C   as input file.
C   Many definitions depend on the use of Angstroems, so please use this unit.
C
C - Use program SPIRAL of Fowler and Manopoulus for ring spiral properties.
C
C - Use program HAMILTON of Babic for Hamiltonian cycles and IUPAC Nomenclature.
C    The number of Hamiltonian cycles given have been checked against a
C    second algorithm, so it should work. Note, the number gives all distinct
C    Hamiltonian cycles and left-right cycles counted the same. Also, finding
C    all Hamiltonian cycles by the back-track algorith of Babich used here
C    is a PN-hard problem, it works fine up to C100. After that it becomes
C    computationally very demanding. Note also that the existence of
C    Hamiltonian cycles for fullerenes is only conjectured, only for
C    layered fullerenes it has been proven to exist and for fullerenes
C    up to a certain number of vertices.
C
C - Calculate smallest and largest cage diameters which gives 
C    already a measure for distortion from spherical symmetry
C    (Subroutine DIAMETER). Produce the distance matrix 
C    (Subroutine DISTMATRIX). Already indicates if fullerene
C    is heavily distorted fron spherical symmetry.
C
C - Establish connectivities between atoms either from given cartesian
C    coordinates or from adjacency matrix if ring spiral as input is used:
C    1) Bond between atoms, 2) Vertices (Subroutine CONNECT).
C
C - Produce canonical ring spiral and pentagon indices (Subroutine SPIRALSEARCH)
C   if cartesian coordinate input is chosen.
C
C - Perform Hueckel analysis (Subroutine HUECKEL). 
C    This gives you a good hint if the fullerene is open or closed shell.
C    Note: It is known that for fullerenes the Hueckel analysis is not
C      very reliable as hybridization with the C(2s) orbitals occur due
C      to nonplanarity. Hence the sigma-pi separation breaks down.
C      Nevertheless, we adopt  alpha=-0.21 au  and  beta=-0.111 au obtained
C      from the exp. ionization potential (7.58 eV) and excitation energy
C      (3.02 eV) of C60 (note the electron goes into the second LUMO of 
C      t1g symmetry). This gives also orbital energies for C60 in reasonable 
C      agreement with DFT Kohn-Sham orbital energies.
C
C - Identify all closed 5- and 6-ring systems (Subroutine RING).
C    This routine also determines if Euler's theorem is fulfilled.
C
C - Fletcher-Reeves-Polak-Ribiere geometry optimization using analytical 
C    gradients for the Wu force field (Subroutine OPTFF).
C    It is very fast, even for C840.
C
C - Determine the center for each 5- and 6-ring (Subroutine RINGC)
C    This is required for the trigonal pyramidal tessellation to obtain
C    the volume.  This routine also analyzes all 2- and 3-ring fusions
C    It further gives the Rhagavachari-Fowler-Manoupoulos neighboring pentagon 
C    and hexagon indices as described in the Fowler and Manolopoulos book.
C    From the hexagon indices one derives if the fullerne fulfills the
C    IPR or not. 
C
C - Calculate the volume of the fullerene by summing over all
C    tetrahedrons spanned by the three vectors (Subroutine VOLUME).
C     CM-CR  (center of cage to the center of ring)
C     CM-CA1 (center of cage to atom 1 in ring)
C     CM-CA2 (center of cage to atom 2 in ring)
C     There are 5 such tetrahedrons in a 5-ring and 6 in a 6-ring
C     Note that CM is already in the origin
C     Let CR=(X1,Y1,Z1) , CA1=(X2,Y2,Z2) , and CA2=(X2,Y2,Z2)
C     Then the volume V for a irregular tetrahedron is given by 
C       the determinant
C
C                                 | X1 Y1 Z1 |
C     V = abs(Vdet)  ,   V =  1/6 | X2 Y2 Z2 |
C                                 | X3 Y3 Z3 |
C
C   Calculate the surface area A and the area/volume ratio (Subroutine VOLUME)
C
C                                        2              2              2
C                             | Y1 Z1 1 |    | Z1 X1 1 |    | X1 Y1 1 |   
C     A = 1/2 d**0.5 ,   d =  | Y2 Z2 1 | +  | Z2 X2 1 | +  | X2 Y2 1 |
C                             | Y3 Z3 1 |    | Z3 X3 1 |    | X3 Y3 1 |
C
C   Note that the ideal C60 coordinates can be constructed from scratch 
C    (Subroutine COORDC60). This routine was constructed to test the program 
C    for the case of an ideal capped icosahedron, where the analytical formula 
C    is well known, i.e.   V=[(125+43*sqrt(5))*R**3]/4
C    and R is the distance between the atoms (all the same)
C    Setting R=Rmin (Rmin is the smallest distance in C60) this gives a
C      lower bound for the volume, while the volume of the covering central sphere 
C      gives the upper bound
C    For two different bond distances, R5 for the 5-ring and R6 for the 6-ring
C    joining another 6-ring, the volume can be determined as well after some tedious
C    algebraic manipulations:
C    i.e.   V=5[(3+sqrt(5))*(2R5+R6)**3]/12-[(5+sqrt(5))*R5**3]/2
C    For C20 (ideal dodecahedron) we have V=[(15+7sqrt(5))*R5**3]/4
C    For C20 and C60 the result of these formulae are also printed.
C   This method gives sensible results for convex fullerenes.
C
C - Calculate the minimum covering sphere (MCS) of the cage molecule 
C    (Subroutine MINCOVSPHERE): The MCS in m-dimensional space exits and is unique 
C     and can be expressed as a convex combination of at most (m+1) points, hence
C     our algorithm stops when 4 points are left over in the iteration process.
C
C    The problem can be reduced to
C
C    min(c) max(i) || p(I) - Cmcs ||
C
C    where ||..|| is the Eucledian norm in m dimensions and Cmcs is the center 
C    of the MCS.
C
C    Note: The spherical central cover SCC is not the minimum covering sphere MCS
C    (except if all distances from the center of points CM are the same as in the
C    ideal capped icosahedron). The spherical central cover is taken from the
C    CM point with radius Rmax (longest distance to one vertix).
C    The minimum covering sphere is calculated at the end of the
C    program using the algorithm of E. A. Yildirim, SIAM Journal on Optimization
C    Vol. 19(3),1368-1391 (2008) and the test by T. H. Hopp and C. P. Reeve,
C    NIST, US Department of Commerce (1996)'). Note that the much simpler algorithm 
C    by F. Lu and W. He, Global Congress on Intelligent Systems (2009),
C    DOI 10:1109/GCIS:2009:381, simply does not work for more than m+1 points on a 
C    surface or close by as their linear equation becomes linearly dependent.
C    Note also that the function Psi in Yildirim's algorithm is really the function
C    Phi defined earlier in his paper in section 2 and corrected in the SIAM paper.
C    His easier to program algorithm 1 was also tested, but is much slower.
C    If the value given in the iteration as "convergence" is close to
C    zero (equal zero), the iteration stops (if it falls below epsilon).
C    You can change the epsilon parameter in subroutine Sphere.
C    You can also try algorithm 1 of Yildirim through subroutine Sphere1
C    which is included in an file called algorithm1.f. Note that we changed the first
C    condition in this algorithm by choosing the furthest point from CM
C    In the final statistics there should be 0 points outside the sphere
C    and at least 1 point on the sphere.
C    At the end the Van der Waals radius of carbon (1.415 Angstroems) is added to the
C    radius of the minimum covering sphere (note input coordinates for this need to be
C    in Angstroems otherwise change the program), and the volume of
C    and ideal fcc solid is calculated. The Van der Waals radius is chosen such that
C    for C60 the solid-state results of P.A.Heiney et al., Phys. Rev. Lett. 66, 2911 (1991)
C    are reproduced. The definition of the distortion parameter D from the MCS or for the
C    the isoperimetric quotient IPQ:
C
C    IPQ=36Pi(V^2/A^3)
C
C    D=[100/(N*Rmin)]* sum(i=1,N) {Rmcs - ||pi-Cmcs|| }    (N=MAtom)
C
C - Calculate the minimum distance sphere (MDS) of the cage molecule
C    The MCS definition for the distortion is biased for the case that few atoms stick 
C    out on a sphere and the MDS measure may be more appropriate for a measure
C    from spherical distortion. The MDS is defined as
C    The problem can be reduced to
C
C    min(Cmds) 1/N sum(i=1,N) | Rmds - || p(I) - Cmds || |
C
C    where ||..|| is the Eucledian norm in m dimensions. The MDS may not be
C    uniquely defined, as there can be many (even degenerate) local minima, 
C    but for most spherical fullerenes it should just be fine. Analogous
C    to the MCS there will be a measure for distortion from spherical symmetry.
C
C    D=[100/(N*Rmin)]* sum(i=1,N) | Rmds - || p(I) - Cmds || |
C
C - Calculate the maximum inner sphere (MCS) of the cage molecule
C
C    max(Cmds) min(i) || p(I) - Cmds ||
C
C   The maximum inner sphere is important for evaluating how much space
C    there is in a fullerene for encapsulating atoms and molecules. For
C    this the radius and volume is printed out with the Van der Waals
C    radius of carbon taken off Rmds. 
C
C - Produce the (X,Y) coordinates of a Schlegel diagram  (Subroutine SCHLEGEL)
C    Here the points are rotated (if in input I1,I2, and I3 are given) so to
C    put the selected vertex, edge or ring center on top of the z-axis as the
C    point of projection (otherwise the point (0,0,zmax) is chosen with zmax
C    being the point with maximum z-value from the original input coordinates).
C    Points are then sorted in descending order according to their z-values.
C    The circumfences for atoms and rings down the z-axis are determined.
C    The Schlegel projection is created giving as output the projected (X,Y)
C    coordinates. The connections between the points are already written out
C    earlier in the output such that the Schlegel diagram can be drawn.
C    There are two choices for the projection, depending if you choose the
C    outer ring or the center part of the Schlegel diagram as a starting point:
C    1) The cone projection, i.e. points are projected out to an enveloping cone
C       and then down to a plane below the fullerene. The input I1,I2,I3 
C       defines the center of the Schlegel diagram. The last ring center should 
C       be at the bottom of the fullerene and if detected, will not be projected 
C       out, or if not will have a large scale factor (this center may be ignored 
C       in the drawing). Also, the last points on the outer ring in the Schlegel 
C       diagram are scaled in distance by 1.2 in order to make the outer rings 
C       more visible. This also moves the outer centers within the ring.
C    2) The perspective projection, i.e. points are projected down a plane from
C       a set projection point. In this case the input I1,I2,I3 defines the outer
C       ring of the Schlegel diagram. 
C    From the output you can easily construct the name of the fullerene. 
C    At the end a rough printout of the Schlegel diagram is
C    produced. Note that this is o.k for fullerenes up to about C100, beyond it
C    it becomes too crowded and a proper plotting program should be used.
C    Nevertheless, it serves for a first rough picture. 
C    Furthermore, for large fullerenes it becomes critical to correctly set the
C    projection point or point of the cone. If for example the projection
C    point is too far away from the fullerene edges may cross. 
C    
C-----------------------------------------------------------------------------------
C  G E N E R A L    I N F O R M A T I O N
C-----------------------------------------------------------------------------------
C This program has been tested for the ideal capped icosahedron (input file ico.inp)
C   and for many other fullerenes which are found in the following input files:
C       C20 (c20.inp), C24 (c24.inp), C26 (c26.inp), C28 (c28.inp), C30 (c30.inp),
C       C36 (c36.inp), C50 (c50.inp), C60 (c60.inp), C70 (c70.inp), C72 (c72.inp),
C       C74 (c74.inp), C78 (c78.inp), C80 (c80.inp), C92 (c92.inp), C100 (c100.inp),
C       C180 (c180.inp), C320 (c320.inp), and C540 (c540.inp), pentagon1.inp, ...,
C       pentagon20.inp
C   Output files are attached as well in the c60.zip file
C   The coordinates are mostly B3LYP aug-cc-pVDZ optimized up to C60, and
C    cc-pVDZ up to C180, and 6-31G for the rest and all for singlet states
C    (except of course for the ones where the pentagon indices input is
C    chosen). Note that for some of the fullerene coordinates the singlet
C    state chose is not the electronic ground state.
C Number of atoms is set in NATOMS currently at 840, so change this parameter
C   if you do not have enough RAM, alternatively the distances need to be
C   calculated directly and the DistMat(natomL) Matrix removed 
C   (which I can do if somebody insists). Also, maxit=2000000, which sets the
C   number of isomers or the number of Hamiltonian cycles to this value in order
C   for the program to not run forever.
C NB: The algorithm for locating all 5-and 6-rings might not be the smartest
C      one, but as this program requires only a second or so to run it was
C      not important to find a better algorithm.
C You should also be aware of program fullgen for generating nonisomorphic fullerenes.
C      It is written by Gunnar Brinkmann (Gunnar.Brinkmann@Ugent.be) and can be
C      downloaded from Brendan McKay's website (Australian National University) at
C      http://cs.anu.edu.au/~bdm/plantri/
C
C  This program is under construction. The program has been tested for bugs.
C      Nevertheless, if you have any problem or find a bug please report to:
C                   peter.schwerdtfeger@gmail.com
C  Note: This program has neither been optimized for performance nor style.
C      It is however quite fast even for fullerenes such as C840.
C
C  Not implemented yet and on the to do list (in progress) is:
C      1) A subroutine to fit the minimum outer ellipsoidal cover 
C          useful for rugby ball like fullerenes.
C      2) Volume of the convex hull to compare to the tesselation method.
C      3) Produce symmetric Schlegel diagrams by optimizing the coordinates.
C         to avoid Schlegel projection which can result in edge crossings.
C      4) Geometry optimization using the extended Wu-Fowler force field.
C      5) Frequency calculations from the force field optimized geometry.
C      6) Construction of leap-frog fullerenes from adjacency matrix.
C      7) Construction of non-ring-spiral isomers using the genus algorithm.
C         Also using a better method than by eigenvectors.
C      8) Automatic selection of P-vectors.
C      9) Symmetry labels for Hueckel orbital energies.
C     10) Extend to non-regular fullerenes of genus 0 (heptagons and squares).
C     11) Extend to non-regular fullerenes of genus 1.
C     12) Using spiral algorithm of Brinkman and McKay for faster performance.
C
C For any questions concerning this program please contact P. Schwerdtfeger
C   Centre for Theoretical Chemistry and Physics (CTCP)
C   The New Zealand Institute for Advanced Study (NZIAS) 
C   Massey University Auckland, Bldg.44, Private Bag 102904
C   North Shore City, 0745 Auckland, New Zealand
C   email: peter.schwerdtfeger@gmail.com
C   http://ctcp.massey.ac.nz/   and  http://www.nzias.ac.nz/
C   --> Always open to improvements and suggestions
C
C-----------------------------------------------------------------------------------
C  A C K N O W L E D G M E N T
C-----------------------------------------------------------------------------------
C I am indebted to the Alexander von Humboldt Foundation (Bonn) for financial support 
C in terms of a Humboldt Research Award, and to both Prof. Gernot Frenking and 
C Dr. Ralf Tonner (Marburg) for support during my extended stay in Marburg where I
C wrote this program. I acknowledge also the help of Darko Babich, Patrick W. Fowler 
C and David E. Manopoulus to allow the use of their Fortran subroutines.
C
C-----------------------------------------------------------------------------------
C  I N P U T:
C-----------------------------------------------------------------------------------
C
C Input (All in Free Format):   (use Angstroem for distances)
C
C 1) N,IC,IOPT,iprintf,IHam,IPR,ISP,IS1,IS2,IS3,ParamS,Tol 
C                    (N=Number of Atoms, Tol= Tolerance in %)
C
C          If IC = 0 Cartesian Coordinates expected as input
C          If IC = 1 then coordinates are constructed for the IPR isomer of C60
C            In this case only one card is read in:
C              R5,R6        (arbitrary units, e.g. Angstroms)
C              R5: Bond lengths in the pentagons 
C              R6: Bond length of the bonds connecting hexagons
C              If R5=R6 chosen then the ideal capped icosahedron is obtained
C          If IC = 2 Cartesian Coordinates are created from an input list:
C           Rmin,IP(I),I=1,12 (next card, free format)
C           Rmin being the smallest bond distance in the fullerene and IP(I)
C           identify the locations of the pentagons as described in detail
C           in ref.2, i.e. IP is the pentagon ring spiral numbering scheme. 
C           Note this only works for ring spiral fullerenes as described in 
C           detail by P. W. Fowler and D. E. Manopoulus. Use the canonical
C           pentagon ring indices if possible (transformation to the canonical
C           from should work as well).
C           If problem with eigenvectors are found to construct the
C           cartesian coordinates, i.e. the identification of P-type
C           eigenvectors, three integer values on the next line (e.g.  2 3 4)
C           identifying the eigenvectors to be chosen can be used as input
C           in free format on the next line. pentagon5.inp is such an example.
C           In this case a severe warning occurs which means you should carefully
C           check the eigenvectors used and cartesian coordinates produced.
C           Otherwise coordinates are obtained which are useless. This is more
C           often the case as you might expect. Examples are given in the
C           the input files starting with 'pentagon'.
C           Please use Angstroems.
C
C      Connectivities are found for atoms with distances between
C         Rmin   and   Rmin*(1+Tol/100)   if cartesian coordinate input is chosen.
C      If Tol=0. default value of 33% is used. 
C         NB: If this parameter is set at a value too large, unwanted connectivities
C          are produced resulting in smaller polygons. This parameter
C          should reflect the maximum deviation in distance from the
C          smallest distance found.
C
C      if Iopt.ne.0  then fullerene is optimized using the force field method
C         of Wu et al within a Fletcher-Reeves-Polak-Ribiere algorithm:
C         Z.C.Wu, D.A.Jelski, T.F.George, Chem. Phys. Lett. 137, 291-295 (1987).
C         Note that there are more sophisticated force fields available,
C         but for these general parameters for fullerenes are not
C         yet available, and the Wu force field does the job to create good initial
C         cartesian coordinates for further refinement using more sophisticated
C         QM methods. Note that a converged energy much greater than zero implies
C         that the set distances and angles in the Wu force field cannot be
C         reached for all atoms and rings. For further reading see: 
C         A.Ceulemans, B.C.Titeca, L.F.Chibotaru, I.Vos, P.W.Fowler, 
C         J. Phys. Chem. A 105, 8284-8295 (2001).
C
C      If IPR>0 then the ring spiral subroutine of Fowler and Manopoulus is used.
C         This sub-program catalogues fullerenes with a given number of
C         vertices using the spiral algorithm and a uniqueness test
C         based on equivalent spirals. The required input is IPR.
C         IPR=1 for isolated-pentagon isomers from C60 onwards.
C         IPR=2 for general isomers (note that this generates a lot of output and
C            takes some computer time for fullerenes larger than C60).
C         IPR=3 same as IPR=1 but programs stops after calling this routine.
C         IPR=4 same as IPR=2 but programs stops after calling this routine.
C          The resulting output is a catalogue of the isomers found containing
C          their idealized point groups, canonical spirals, and NMR patterns
C          (see ref.2).
C
C      If iprintf>0 larger output produced, i.e. the full distance matrix, all
C          Hamiltonian cycles and all 3-ring connections.
C      If iprintf<0 IUPAC nomenclature in Hamiltonian subroutine is not calculated
C
C      If IHam>0 Then Subroutine Hamilton is called.
C         IHam=1 Routine will stop after 1 million Hamiltonian cycles are found
C         IHam>1 it will run up to 10**IHam Hamiltonian cycles.
C
C      If ISP>0 Use Program Schlegel for generating the Schlegel projection.
C         ISP=1 Use the perspective projection method.
C         ISP=2 Use the cone projection method.
C
C      If IS1=0 Use the input coordinates for the construction of 
C               the Schlegel diagram.
C      If IS1.ne.0 Specifying the ring center, edge or
C              vertex through which the z-axis goes at the top of
C              the projection (under construction). This rotates
C              the fullerene around the origin of points into the
C              right position for the Schlegel diagram. Since 3 atoms
C              uniquely define the ring, two the edge, and one the vertex,
C              the input is three integers in free format with the corresponding
C              atom numbers  I1 I2 I3,
C              i.e.  1 0 0 is a vertex with atom 1 on the top of the z-axis;
C                    7 8 0 is an edge between atom 7 and 8 and z-axis goes
C                          the middle of the bond;
C                    12 13 50 is a ring (either pentagon or hexagon determined
C                          by the program) and z-axis goes through the center
C                          of the ring;
C              NB: You can run the program first with 0 0 0, check the positions
C                  and run it again with the appropriate values.
C              NB2: For ISP=1 the input (if chosen) requires to be a ring, i.e.
C                  I1, I2 and I3 are required, otherwise they are chosen by the
C                  program using the largest z-coordinate.
C
C      IF ParamS.eq.0. Projection angle of 45 degrees is chosen (default value)
C              otherwise to be used as an input parameter in the cone projection
C              method. The angle is the cone angle from the point of projection 
C              to the projection plane, which touches the point with the smallest 
C              z-value (opposite the projection point). Note that angle is reset 
C              to 45 deg if chosen larger than 89.
C              In the case of the perspective projection ParamS is the distance
C              between the focal point and the ring center underneath, Note this
C              is chosen by the program, but if nonzero this parameter has to be
C              carefully chosen. The picture produced gives a good idea if the
C              ParamS is correctly chosen or not. Note that the ring centers get
C              an extra boost of 10% in the scaling factors such that they appear
C              more in the center of the rings produced by the Schlegel projection.
C              
C 2) N lines with    Z, X, Y, Z
C         (Z= Nuclear Charge, X,Y,C Cartesian Coordinates for Atom)
C      NB: Z is not really needed, but you can copy Gaussian output
C          directly into the input file
C---------------------------------------------------------------------- 

C    Set the dimensions for the distance matrix
      PARAMETER (natom=840)      !  Change natom if RAM is not sufficient
      PARAMETER (nat11=natom*11)  
      PARAMETER (msrs=56+1)      !  Size of Schlegel output matrix
      PARAMETER (natom2=natom*natom)
      PARAMETER (natomL=(natom*(natom-1))/2)
      PARAMETER (Nfaces=natom/2+2)
      PARAMETER (NSpScale=12)
      PARAMETER (NSpirals=Nfaces*NSpScale)
      PARAMETER (Nedges=3*natom/2)
      PARAMETER (maxit=2000000) 
      DIMENSION CRing5(3,Nfaces),CRing6(3,Nfaces),cmcs(3),CR(3,Nfaces)
      DIMENSION DistMat(natomL),Dist(3,natom),DistCM(3)
      DIMENSION A(NAtom,NAtom),evec(Natom),df(Natom)
      DIMENSION N5MEM(Nfaces,5),N6MEM(Nfaces,6),Iring(Nfaces)
      DIMENSION Icon2(natom2),distP(natom),IDA(Natom,Natom)
      DIMENSION IATOM(natom),IC3(natom,3),Nring(Nfaces)
      DIMENSION NringA(Nedges),NringB(Nedges)
      DIMENSION NringC(Nedges),NringD(Nedges)
      DIMENSION NringE(Nedges),NringF(Nedges)
      DIMENSION IDual(Nfaces,Nfaces)
      DIMENSION Symbol(Nfaces)
      Real*4 TimeX
CG77  CHARACTER CDAT*9,CTIM*8
      CHARACTER CDAT*8,CTIM*10,Zone*5
      CHARACTER*1  Symbol
      CHARACTER*2 El(99)
      CHARACTER*13 routine
      Integer Values(8)
      DATA El/2H H,2HHE,2HLI,2HBE,2H B,2H C,2H N,2H O,2H F,2HNE,2HNA,
     1 2HMG,2HAL,2HSI,2H P,2H S,2HCL,2HAR,2H K,2HCA,2HSC,2HTI,2H V,2HCR,
     1 2HMN,2HFE,2HCO,2HNI,2HCU,2HZN,2HGA,2HGE,2HAS,2HSE,2HBR,2HKR,    
     1 2HRB,2HSR,2H Y,2HZR,2HNB,2HMO,2HTC,2HRU,2HRH,2HPD,2HAG,2HCD,   
     1 2HIN,2HSN,2HSB,2HTE,2H I,2HXE,2HCS,2HBA,2HLA,2HCE,2HPR,2HND,  
     1 2HPM,2HSM,2HEU,2HGD,2HTB,2HDY,2HHO,2HER,2HTM,2HYB,2HLU,2HHF, 
     1 2HTA,2H W,2HRE,2HOS,2HIR,2HPT,2HAU,2HHG,2HTL,2HPB,2HBI,2HPO,
     1 2HAT,2HRN,2HFR,2HRA,2HAC,2HTH,2HPA,2H U,2HNP,2HPU,2HAM,2HCM,   
     1 2HBK,2HDU,2HDU/                                               
      DATA Tol,anglew,Rdist/0.33d0,45.d0,1.391d0/
C     Van der Waals radius of carbon, adjusted approximately to the
C     solid-state results of P.A.Heiney et al., Phys. Rev. Lett. 66, 2911 (1991)
      DATA RVdWC/1.415d0/
      Open(unit=3,file='cylview.xyz',form='formatted')
      IN=5
      IOUT=6

C  You might like to comment these 2 lines out 
C  (and same at the end of this routine) or substitute them with your
C  compiler specific option. Next two are g77 options
CG77    CALL Date(CDAT)
CG77    CALL Time(CTIM)
        call date_and_time(CDAT,CTIM,zone,values)
        TIMEX=0.d0
        CALL Timer(TIMEX)
C       WRITE(IOUT,1000) CDAT,CTIM,natom
        WRITE(IOUT,1000) Values(3),Values(2),Values(1),Values(5),
     1    Values(6),Values(7),natom
C  INPUT and setting parameters for running the subroutines
        CALL Datain(IN,IOUT,MAtom,Icart,Iopt,iprintf,IHam,IPR,ISchlegel,
     1  IS1,IS2,IS3,IER,istop,IOPD,iupac,Ipent,ParamS,TolX)

C  Stop if error in input
      If(IER.ne.0) go to 99
C  Only do isomer statistics
      if(istop.ne.0) go to 98

C Options for Input coordinates
      If(Icart-1) 10,20,30 
C Input Cartesian coordinates for fullerenes
   10 Do J=1,MAtom
      Read(IN,*) IAtom(J),(Dist(I,J),I=1,3)
      enddo
      Go to 40
C  Cartesian coordinates produced for Ih C60
   20 routine='COORDC60     '
      Write(Iout,1008) routine
      CALL CoordC60(Natom,IN,Iout,IAtom,Dist)
      Matom=60
      Do I=1,60
      IAtom(I)=6
      enddo
      Go to 40
C Cartesian coordinates produced ring from spiral pentagon list
C currently using the Fowler-Manopoulus algorithm to
C identify P-type eigenvectors and construct the 3D fullerene
   30 Ipent=1
      routine='COORDPENT    '
      Write(Iout,1008) routine
      Do I=1,Matom
      IAtom(I)=6
      enddo
      CALL CoordPent(Natom,NFaces,Nedges,MAtom,IN,Iout,IDA,IDual,
     1 Icart,A,evec,df,Dist,distp,Rdist)
   40 WRITE(IOUT,1001) MAtom,TolX*100.d0

C Some general infos on isomers and spiral routine
C of Fowler and Manopoulus. Set parameter IPR for independent
C pentagon rule as full list beyond C60 is computer time 
C intensive
  98  routine='ISOMERS      '
      iprintham=1
      Write(Iout,1008) routine
      CALL Isomers(NAtom,NFaces,Nedges,MAtom,IPR,IOUT,
     1 maxit,iprintham,IDA,A)
      if(istop.ne.0) go to 99

C Move carbon cage to Atomic Center
      routine='MOVECM       '
      Write(Iout,1008) routine
      Iprint=1
      Call MoveCM(Natom,Matom,Iout,Iprint,IAtom,Dist,DistCM,El)

C Calculate largest and smallest atom-to-atom diameters
C Also get moment of inertia (to be implemented)
      routine='DIAMETER     '
      Write(Iout,1008) routine
      CALL Diameter(NAtom,MAtom,IOUT,Dist,distp)

C Calculate the distance Matrix and print out distance Matrix
      routine='DISTMATRIX   '
      Write(Iout,1008) routine
      CALL Distmatrix(NAtom,natomL,MAtom,IOUT,iprintf,Iopt,
     1 Dist,DistMat,Rmin,Rmax,VolSphere,ASphere)

C Establish Connectivities
      routine='CONNECT      '
      Write(Iout,1008) routine
      CALL Connect(NAtom,natomL,Natom2,MCon2,MAtom,Ipent,IOUT,
     1 Icon2,IC3,IDA,TolX,DistMat,Rmin)

C Hueckel matrix and eigenvalues
      if(ipent.eq.0) then
      routine='HUECKEL      '
      Write(Iout,1008) routine
      CALL Hueckel(NAtom,MAtom,IOUT,IC3,IDA,A,evec,df)
      endif

C Generate IUPAC name and locate Hamiltonian cycles. 
C Routine written by D. Babic. Note routine
C is called only if IPR>0 as computer time is extensive beyond
C C100 (PN-hard problem). Last routine uses the adjaceny matrix
C to calculate the number of all distinct paths between 
C adjacent vertices
      routine='HAMILTON     '
      Write(Iout,1008) routine
       maxiter=maxit
      if(IHam.gt.1.and.IHam.le.10) then
       maxiter=10**IHam
      endif
      if(IHam.ne.0) then
       if(iupac.ne.0) then
         CALL Hamilton(NAtom,MAtom,Iout,iprintf,maxiter,IC3)
       else
         CALL HamiltonCyc(NAtom,MAtom,maxiter,IDA,Nhamilton)
         WRITE(Iout,1010) Nhamilton
       endif
      endif
      CALL Paths(NAtom,Nedges,MAtom,IOUT,IDA,A,evec,df)

C Establish all closed ring systems
      routine='RING         '
      Write(Iout,1008) routine
      CALL Ring(NAtom,Nfaces,natomL,Natom2,MCon2,MAtom,IOUT,N5Ring,
     1 N6Ring,IC3,Icon2,N5MEM,N6MEM,Rmin5,Rmin6,Rmax5,Rmax6,DistMat)

C Produce the dual of the fullerene
C     if(IOPD.eq.1) then
C     routine='DualFullerene'
C     Write(Iout,1008) routine
C     WRITE(Iout,1033) 
C1033 Format(/1X,'Produce the adjacency matrix for the dual fullerene')
C     CALL DUALFull(NMAX,MAtom,NFaces,IDA,IDual,
C    1 N5Ring,N6Ring,N5MEM,N6MEM)
C     IOPD=0
C     go to 98
C     endif

C Optimize Geometry through force field method
      If(Iopt.ne.0) then
      routine='OPTFF        '
      Write(Iout,1008) routine
      CALL OptFF(Natom,NFaces,MAtom,Iout,IDA,N5Ring,N6Ring,
     1 N5MEM,N6MEM,Dist,Rdist)
      Iprint=0
      Call MoveCM(Natom,Matom,Iout,Iprint,IAtom,Dist,DistCM,El)
      routine='DISTMATRIX   '
      Write(Iout,1008) routine
      CALL Distmatrix(NAtom,natomL,MAtom,IOUT,Iprintf,0,
     1 Dist,DistMat,Rmin,Rmax,VolSphere,ASphere)
      routine='DIAMETER     '
      Write(Iout,1008) routine
      CALL Diameter(NAtom,MAtom,IOUT,Dist,distp)

      endif
      routine='RING         '
      Write(Iout,1008) routine
      CALL Ring(NAtom,Nfaces,natomL,Natom2,MCon2,MAtom,IOUT,N5Ring,
     1 N6Ring,IC3,Icon2,N5MEM,N6MEM,Rmin5,Rmin6,Rmax5,Rmax6,DistMat)

C Calculate the center for each ring system
      routine='RINGC        '
      Write(Iout,1008) routine
      CALL RingC(NAtom,Nfaces,Nedges,NAtom2,Matom,nat11,Iout,iprintf,
     1 N5MEM,N6MEM,N5Ring,N6Ring,NRing,Iring5,Iring6,Iring56,NringA,
     1 NringB,NringC,NringD,NringE,NringF,DIST,CRing5,CRing6)

C Now produce clockwise spiral ring pentagon count a la Fowler and Manopoulus
      if(ipent.eq.0) then
      routine='SPIRALSEARCH '
      Write(Iout,1008) routine
      CALL SpiralSearch(NAtom,Nfaces,Nedges,Nspirals,MAtom,Iout,
     1 Iring5,Iring6,Iring56,NringA,NringB,NringC,NringD,NringE,NringF)
      endif

C Calculate the volume
      routine='VOLUME       '
      Write(Iout,1008) routine
      CALL Volume(NAtom,Nfaces,NAtom2,Matom,Iout,N5MEM,N6MEM,
     1 N5Ring,N6Ring,DIST,CRing5,CRing6,VolSphere,ASphere,
     2 Atol,VTol,Rmin5,Rmin6,Rmax5,Rmax6)

C Print out Coordinates used as input for CYLview
      routine='PRINTCOORD   '
      Write(Iout,1008) routine
      WRITE(IOUT,1002) 
      WRITE(3,1003) MATOM 
      Do J=1,MAtom
      IM=IAtom(J)      
      Write(3,1007) El(IM),(Dist(I,J),I=1,3)
      enddo

C Calculate the minimum distance sphere
C     routine='CONVEXHULL'
C     Write(Iout,1008) routine
C     CALL ConvexHull(NAtom,MAtom,Dist,VolumeCH,AreaCH)

C Calculate the minimum covering sphere and volumes
C     MinCovSphere1 contains algorithm 1 and MinCovSphere2 algorithm2
C     MinCovSphere2 is more efficient and contains more useful information
C     CALL MinCovSphere1(NAtom,MAtom,IOUT,Dist,
C    1 Rmin,Rmax,VolSphere,ASphere,Atol,VTol,cmcs,rmcs,RVdWC)
      routine='MINCOVSPHERE2'
      Write(Iout,1008) routine
      CALL MinCovSphere2(NAtom,MAtom,IOUT,Dist,Rmin,Rmax,
     1 VolSphere,ASphere,Atol,VTol,distP,cmcs,rmcs,RVdWC)

C Calculate the minimum distance sphere
      routine='MINDISTSPHERE'
      Write(Iout,1008) routine
      CALL MinDistSphere(NAtom,MAtom,IOUT,Dist,
     1 Rmin,Rmax,distP,cmcs,rmcs)

C Calculate the maximum inner sphere
      routine='MAXINSPHERE'
      Write(Iout,1008) routine
      CALL MaxInSphere(NAtom,MAtom,IOUT,Dist,cmcs,RVdWC)

C Calculate Schlegel diagram
      if(ISchlegel.ne.0) then
      routine='SCHLEGEL     '
      Write(Iout,1008) routine
      if(ISchlegel.eq.2) then
       if(ParamS.le.1.d0.or.ParamS.gt.8.9d1) then
       ParamS=anglew
       WRITE(IOUT,1006) ParamS
       endif
      else
       ParamS=dabs(ParamS)
      endif
      CALL Schlegel(NAtom,Nfaces,Nedges,MAtom,msrs,IOUT,IS1,IS2,IS3,
     1 N5MEM,N6MEM,N5Ring,N6Ring,NRing,Iring,Ischlegel,IC3,Dist,ParamS,
     1 Rmin,TolX,CR,CRing5,CRing6,Symbol)
      endif

C  E N D   O F   P R O G R A M
CG77 99  CALL TIME(CTIM)
  99  call date_and_time(CDAT,CTIM,zone,values)
        WRITE(IOUT,1004) Values(3),Values(2),Values(1),Values(5),
     1    Values(6),Values(7)
      CALL Timer(TIMEX)
      Hours=TIMEX/3.6d3
      WRITE(IOUT,1009) TIMEX,Hours
      Close(unit=3)
C Formats 
 1000 FORMAT(
     1  1X,'*********************************************************',
     1 /1X,'**      P R O G R A M   F U L L E R E N E              **',
     1 /1X,'**  Fortran Program for the topological analysis       **',
     1 /1X,'**    of Fullerenes C(20+2H) (H: hexagonal faces)      **',
     1 /1X,'**  Written by P. Schwerdtfeger                        **',
     1 /1X,'**    with routines from Fowler, Manopoulus and Babic  **',
     1 /1X,'**  Massey University,  Auckland,  New Zealand         **',
     1 /1X,'**  First version                     08/06/10         **',
     1 /1X,'**  Version 3.3                       01/03/12         **',
     1 /1X,'*********************************************************',
CG77 1 /1X,'DATE: ',A9,10X,'TIME: ',A8,/1X,'Limited to ',I6,' Atoms',
     1 /1X,'Date: ',I2,'/',I2,'/',I4,10X,'Time: ',I2,'h',I2,'m',I2,'s',
     1 /1X,'Limited to ',I6,' Atoms',
     1 //1X,'Literature (please cite refs.1-4):',/1X,
     1 '1) P. Schwerdtfeger, Topological Aspects of Fullerenes -',
     1 ' A Fortran Program',/9X,'(Version 3.3, Massey University',
     1 ' Albany, Auckland, New Zealand, 2012).',/1X,
     1 '2) P. W. Fowler, D. E. Manopoulus, An Atlas of Fullerenes',
     1 ' (Dover Publ., New York, 2006).',/1X,
     1 '3) D. Babic, Nomenclature and Coding of Fullerenes,',
     1 ' J. Chem. Inf. Comput. Sci. 35, 515-526 (1995).',/1X,
     1 '4) Z. C. Wu, D. A. Jelski, T. F. George, Vibrational Motions of'
     1 ' Buckminsterfullerene, Chem. Phys. Lett. 137, 291-295 (1987).',
     1 /1X,' Further reading:',/1X,
     1 '5) D. E. Manopoulus, P. W. Fowler, Molecular graphs, point '
     1 'groups, and fullerenes,',
     1 ' J. Chem. Phys. 96, 7603-7614 (1992).',/1X,
     1 '6) D. Babic, D. J. Klein, C. H. Sah, Symmetry of fullerenes,',
     1 ' Chem. Phys. Lett. 211, 235-241 (1993).',/1X,
     1 '7) G. B. Adams, M. O Keefe, R. S. Ruoff, Van der Waals Surface'
     1 ' Areas and Volumes of Fullerenes, J. Phys. Chem. 98, 9465-9469'
     1 '(1994).',/1X,
     1 '8) W. O. J. Boo, An Introduction to Fullerene Structures,',
     1 ' J. Chem. Ed. 69, 605-609 (1992).',/1X,
     1 '9) R. Tonner, G. Frenking, M. Lein, P.',
     1 ' Schwerdtfeger, Packed to the Rafters – Filling up C60 with',
     1 ' Rare Gas Atoms,',/9X,'Chem. Phys. Chem. 12, 2081-2084 (2011).',
     1 /,132('-'),/1X)
 1001 FORMAT(/1X,'Number of Atoms: ',I4,', and distance tolerance: ',
     1 F12.2,'%')
 1002 FORMAT(/1X,'Input coordinates to be used for program CYLview ',
     1 'by C.Y.Legault:',/1X,'Output written into cylview.xyz')
 1003 FORMAT(I5,/,'Cartesian coordinate input for CYLview')
CG77 1004 FORMAT(1X,124(1H-),/1X,6HTIME: ,A8)
 1004 FORMAT(132(1H-),/1X,'DATE: ',I2,'/',I2,'/',I4,10X,
     1 'TIME: ',I2,'h',I2,'m',I2,'s')
 1006 FORMAT(/1X,'Angle for Schlegel diagram reset to ',
     1 F10.4,' degrees')
 1007 FORMAT(A2,6X,3(E18.12,2X))
 1008 FORMAT(132('-'),/1x,'--> Enter Subroutine ',A13)
 1009 FORMAT(1x,'CPU Seconds: ',F14.2,', CPU Hours: ',F12.5)
 1010 FORMAT(1X,'Number of Hamiltonian cycles: ',I10)
      STOP 
      END

      SUBROUTINE TIMER(TIMEX)
      Real TA(2)
      Call DTIME(TA,time)
      TIMEX=TIME
      RETURN
      END
 
      SUBROUTINE MoveCM(Natom,Matom,Iout,Iprint,IAtom,Dist,DistCM,El)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION Dist(3,natom),DistCM(3),Ainert(3,3),evec(3),df(3)
      DIMENSION IATOM(natom)
      CHARACTER*2 El(99)
      Data FNorm,STol/4.97369255d2,1.d-2/
      if(Iprint.ne.0) WRITE(IOUT,1000) 
      AnumX=0.d0
      AnumY=0.d0
      AnumZ=0.d0
      Do J=1,MAtom
        IM=IAtom(J)
        if(Iprint.ne.0) Write(IOUT,1002),J,IM,El(IM),(Dist(I,J),I=1,3)
        AnumX=AnumX+Dist(1,J)
        AnumY=AnumY+Dist(2,J)
        AnumZ=AnumZ+Dist(3,J)
      enddo
      Adenom=dfloat(MAtom)
      DistCM(1)=AnumX/Adenom
      If(dabs(DistCM(1)).lt.1.d-13) DistCM(1)=0.d0
       DistCM(2)=AnumY/Adenom
       If(dabs(DistCM(2)).lt.1.d-13) DistCM(2)=0.d0
         DistCM(3)=AnumZ/Adenom
         If(dabs(DistCM(3)).lt.1.d-13) DistCM(3)=0.d0
      Write(IOUT,1003) (DistCM(I),I=1,3)
      Do J=1,MAtom
       IM=IAtom(J)
         Do I=1,3
          Dist(I,J)=Dist(I,J)-DistCM(I)
         enddo
       Write(IOUT,1002),J,IM,El(IM),(Dist(I,J),I=1,3)
      enddo
C     Calculate distance part of moment of inertia
      Do I=1,3
      Do J=1,3
      Ainert(I,J)=0.d0
      enddo
      enddo
      Do J=1,MAtom
      x=Dist(1,J)
      y=Dist(2,J)
      z=Dist(3,J)
      x2=x*x
      y2=y*y
      z2=z*z
      xy=x*y
      xz=x*z
      yz=y*z
      Ainert(1,1)=Ainert(1,1)+y2+z2
      Ainert(2,2)=Ainert(2,2)+x2+z2
      Ainert(3,3)=Ainert(3,3)+x2+y2
      Ainert(1,2)=Ainert(1,2)+xy
      Ainert(1,3)=Ainert(1,3)+xz
      Ainert(2,3)=Ainert(2,3)+yz
      Ainert(2,1)=Ainert(1,2)
      Ainert(3,1)=Ainert(1,3)
      Ainert(3,2)=Ainert(2,3)
      enddo
      xmin=0.d0
      Do I=1,3
      if(Ainert(I,I).gt.xmin) xmin=Ainert(I,I)
      enddo
      Do I=1,3
      Do J=1,3
      Ainert(I,J)=Ainert(I,J)/xmin
      enddo
      enddo
C Diagonalize without producing eigenvectors
      call tred2l(Ainert,3,3,evec,df)
      call tqlil(evec,df,3,3)
      Do I=1,3
      evec(i)=evec(i)*xmin
      enddo
C Sort eigenvalues
      Do I=1,3
       e0=evec(I)
       jmax=I
        Do J=I+1,3
         e1=evec(J)
          if(e1.gt.e0) then 
           jmax=j
           e0=e1
          endif
        enddo
        if(i.ne.jmax) then
         ex=evec(jmax)
         evec(jmax)=evec(I)
         evec(I)=ex
        endif
      enddo
      Write(Iout,1001) (evec(i),I=1,3)
      do i=1,3
      evec(i)=evec(i)/FNorm
      enddo
      Write(Iout,1004) FNorm,(evec(i),I=1,3)
C Determine shape
      S1=dabs(evec(1)-evec(2))/evec(1)
      S2=dabs(evec(1)-evec(3))/evec(1)
      S3=S1+S2
C Symmetric top
      if(S3.lt.Stol) then
      Write(Iout,1005)
      Return
      endif
      if(S3.lt.5.d0*Stol) then
      Write(Iout,1006)
      Return
      endif
C Prolate
      dif=evec(1)/evec(3)
      if(S1.lt.Stol) then
      Write(Iout,1007)
      Return
      endif
      if(S1.lt.5.d0*Stol) then
      Write(Iout,1008)
      Return
      endif
C Oblate
      S4=dabs(evec(2)-evec(3))/evec(1)
      if(S4.lt.Stol) then
      Write(Iout,1009)
      Return
      endif
      if(S4.lt.5.d0*Stol) then
      Write(Iout,1010)
      Return
      endif
C Asymmetric
      Write(Iout,1011)
 1000 FORMAT(/1x,'Cartesian Input',
     1  /1X,'  I      Z  Element Cartesian Coordinates')
 1001 FORMAT(/1x,'Moment of inertia with setting the masses to unity:',
     1 /1x,'Eigenvalues (principal axis system): ',3F16.6)
 1002 FORMAT(1X,I3,1X,I6,1X,A2,6X,3(D18.12,2X))
 1003 FORMAT(/1X,'Shift Molecule to the centre of points:',
     1 /1X,'Original Centre: ',3(D15.9,1X),
     1 /1X,'New Coordinates:',
     1  /1X,'  I      Z  Element Cartesian Coordinates')
 1004 FORMAT(1x,'Using C60 ideal icosahedron to normalize eigenvalues',
     1 ' (',F6.2,' Angstroem^2)',/,' Eigenvalues (normalized): ',3F16.6)
 1005 FORMAT(1x,'Fullerene is symmetric top')
 1006 FORMAT(1x,'Fullerene is distorted symmetric top')
 1007 FORMAT(1x,'Fullerene is prolate')
 1008 FORMAT(1x,'Fullerene is distorted prolate')
 1009 FORMAT(1x,'Fullerene is oblate')
 1010 FORMAT(1x,'Fullerene is distorted oblate')
 1011 FORMAT(1x,'Fullerene is asymmetric')
      return
      END

      SUBROUTINE Hueckel(NAtom,MAtom,IOUT,IC3,IDA,A,evec,df)
      IMPLICIT REAL*8 (A-H,O-Z)
C Perform Hueckel matrix diagonalization to obtain eigenvalues
C This gives a good hint if the fullerene is closed-shell
      DIMENSION IC3(natom,3),A(NAtom,NAtom),evec(Natom),df(Natom)
      DIMENSION IDG(natom),IDA(Natom,Natom)
      Character*10 Symbol
C Parameters alpha and beta are in atomic units and are adjusted 
C  to HOMO DFT orbital energies
      Data Tol,Tol1,alpha,beta/1.d-5,.15d0,-.21d0,-0.111/
C Produce adjacency matrix
      WRITE(IOUT,1001) Matom,Matom 
      Do I=1,MAtom
      Do K=1,MAtom
        A(I,K)=0.d0
        IDA(I,K)=0
      enddo
      enddo
      Do I=1,MAtom
      Do J=1,3
        IP=IC3(I,J)
        A(I,IP)=1.d0
        A(IP,I)=1.d0
        IDA(I,IP)=1
        IDA(IP,I)=1
      enddo
      enddo

C Diagonalize without producing eigenvectors
      call tred2l(A,Matom,Natom,evec,df)
      call tqlil(evec,df,Matom,Natom)

C Sort eigenvalues
      Do I=1,MAtom
       e0=evec(I)
       jmax=I
        Do J=I+1,MAtom
         e1=evec(J)
          if(e1.gt.e0) then 
           jmax=j
           e0=e1
          endif
        enddo
        if(i.ne.jmax) then
         ex=evec(jmax)
         evec(jmax)=evec(I)
         evec(I)=ex
        endif
      enddo

C Now sort degeneracies
      df(1)=evec(1)
      ieigv=1
      ideg=1
      IDG(1)=ideg
      Do I=2,MAtom
       diff=dabs(evec(I-1)-evec(I))
       if(diff.lt.Tol) then
        ideg=ideg+1
        IDG(ieigv)=ideg
       else
        ieigv=ieigv+1
        ideg=1
        IDG(ieigv)=ideg
        df(ieigv)=evec(I)
       endif
      enddo

C     Now Print
      ntot=0
      nopen=0
      nflag=0
      Write(Iout,1000) 
      Do I=1,ieigv
       NE=2*idg(i)
       NE1=NE
       ntot=ntot+NE
       Symbol='(occupied)'
       if(ntot.gt.Matom) then 
         if(nflag.eq.0) then
          nflag=1
          bandgap=df(i-1)-df(i)
         endif
        NE=0
        Symbol='(empty)   '
       endif
       if(ntot.gt.Matom.and.(ntot-NE1).lt.Matom) then 
        NE=Matom-ntot+NE1
        Symbol='(fractocc)'
        nopen=1
       endif
       epsilon=alpha+df(i)*beta
       Write(Iout,1002) df(I),epsilon,idg(i),NE,Symbol
      enddo
      Write(Iout,1003)
      if(nopen.eq.1) then
       Write(Iout,1004)
      else
       excite=-bandgap*beta*27.2117
       Write(Iout,1005) bandgap,excite
       if(bandgap.lt.Tol1) Write(Iout,1006)
      endif
 
 1000 FORMAT(8X,'x',13X,'E',4X,'deg NE   type    ',/1X,45('-'))
 1001 FORMAT(/1X,'Construct the (',I3,','I3,') Hueckel matrix '
     1 'and diagonalize (E=alpha+x*beta; E in au)',
     1 /1X,'Eigenvalues are between [-3,+3] (in units of |beta|)',
     1 /1X,'deg: degeneracy; NE: number of electrons')
 1002 FORMAT(2(1X,F12.6),I3,1X,I3,3X,A10)
 1003 FORMAT(1X,45('-'))
 1004 FORMAT(1X,'Hueckel theory indicates that fullerene has',
     1 ' open-shell character (zero band gap)!')
 1005 FORMAT(1X,'Bandgap delta x =',F12.6,' in units of |beta| =',
     1 F12.6,' eV')
 1006 FORMAT(1X,'Caution: Bandgap small, possibility '
     1 'for open-shell character')
      Return
      End 

      SUBROUTINE Isomers(NAtom,Nfaces,Nedges,N,IPR,IOUT,
     1 maxAiso,iham,IDA,A)
C Information on number of isomers with or without fulfilling the
C the IPR rule. The routine also calls SPIRAL using the subroutines
C written by P. W. Fowler and D. E. Manopoulus, "An Atlas of Fullerenes"
C (Dover Publ., New York, 2006), which gives information on the
C isomers point group, pentagon ring spiral indices and NMR pattern. 
      IMPLICIT REAL*8 (A-H,O-Z)
      Integer Isonum(119),IsonumIPR(123),IDA(NAtom,NAtom)
      Character*11 Isoc(52),IsocIPR(28)
      Dimension A(NAtom,NAtom)
      Data Isonum/1,0,1,1,2,3,6,6,15,17,40,45,89,116,199,
     * 271,437,580,924,1205,1812,2385,3465,4478,6332,8149,
     * 11190,14246,19151,24109,31924,39718,51592,63761,81738,
     * 99918,126409,153493,191839,231017,285914,341658,419013,
     * 497529,604217,713319,860161,1008444,1207119,1408553,
     * 1674171,1942929,2295721,2650866,3114236,3580637,4182071,
     * 4787715,5566949,6344698,7341204,8339033,9604411,10867631,
     * 12469092,14059174,16066025,18060979,20558767,23037594,
     * 26142839,29202543,33022573,36798433,41478344,46088157,
     * 51809031,57417264,64353269,71163452,79538751,87738311,
     * 97841183,107679717,119761075,131561744,145976674,159999462,
     * 177175687,193814658,214127742,233846463,257815889,281006325,
     * 309273526,336500830,369580714,401535955,440216206,477420176,
     * 522599564,565900181,618309598,668662698,729414880,787556069,
     * 857934016,925042498,1006016526,1083451816,1176632247,
     * 1265323971,1372440782,1474111053,1596482232,1712934069,
     * 1852762875,1985250572,2144943655/
      Data IsonumIPR/1,0,0,0,0,1,1,1,2,5,7,9,24,19,35,46,86,134,187,
     * 259,450,616,823,1233,1799,2355,3342,4468,6063,8148,10774,13977,
     * 18769,23589,30683,39393,49878,62372,79362,98541,121354,151201,
     * 186611,225245,277930,335569,404667,489646,586264,697720,
     * 836497,989495,1170157,1382953,1628029,1902265,2234133,
     * 2601868,3024383,3516365,4071832,4690880,5424777,6229550,
     * 7144091,8187581,9364975,10659863,12163298,13809901,15655672,
     * 17749388,20070486,22606939,25536557,28700677,32230861,
     * 36173081,40536922,45278722,50651799,56463948,62887775,
     * 69995887,77831323,86238206,95758929,105965373,117166528,
     * 129476607,142960479,157402781,173577766,190809628,209715141,
     * 230272559,252745513,276599787,303235792,331516984,362302637,
     * 395600325,431894257,470256444,512858451,557745670,606668511,
     * 659140287,716217922,776165188,842498881,912274540,987874095,
     * 1068507788,1156161307,1247686189,1348832364,1454359806,
     * 1568768524,1690214836,1821766896,1958581588,2109271290/
       Data Isoc/'2295793276','2477017558','2648697036','2854536850',
     *           '3048609900','3282202941','3501931260','3765465341',
     *           '4014007928','4311652376','4591045471','4926987377',
     *           '5241548270','5618445787','5972426835','6395981131',
     *           '6791769082','7267283603','7710782991','8241719706',
     *          '8738236515','9332065811','9884604767','10548218751',
     *       '11164542762','11902015724','12588998862','13410330482',
     *       '14171344797','15085164571','15930619304','16942010457',
     *       '17880232383','19002055537','20037346408','21280571390',
     *       '22426253115','23796620378','25063227406','26577912084',
     *       '27970034826','29642262229','31177474996','33014225318',
     *       '34705254287','36728266430','38580626759','40806395661',
     *       '42842199753','45278616586','47513679057','50189039868'/
      Data IsocIPR/'2266138871','2435848971','2614544391','2808510141',
     *       '3009120113','3229731630','3458148016','3704939275',
     *       '3964153268','4244706701','4533465777','4850870260',
     *       '5178120469','5531727283','5900369830','6299880577',
     *       '6709574675','7158963073','7620446934','8118481242',
     *       '8636262789','9196920285','9768511147','10396040696',
     *       '11037658075','11730538496','12446446419','13221751502'/

C     Number of Isomers
      ISOMAX=256
      If(N.le.256) then
C     Both values fit 32bit signed integer
       M1=N/2-9
       M2=N/2-29
        if(M2.gt.0) then
         isomIPR=IsonumIPR(M2)
        else
         isomIPR=0
        endif
       Write(Iout,1000) Isonum(M1),isomIPR
       AisoNIPR=dfloat(Isonum(M1))
       AisoIPR=dfloat(isomIPR)
      endif

C     IPR value only fits 32bit signed integer
        If(N.le.304.and.N.gt.256) then
           fac1=10.d0**3.502347
         M1=N/2-128
         M2=N/2-29
         Write(Iout,1001) isoc(M1),IsonumIPR(M2)
        endif

C     Both values do not fit 32bit signed integer
C      Output in characters
          If(N.le.360.and.N.gt.304) then
           M1=N/2-128
           M2=N/2-152
         Write(Iout,1002) isoc(M1),IsocIPR(M2)
          endif

C     Both values not known, estimate by polynomial
C      fitted to asymptodic 
          If(N.gt.256) then
           fac1=10.d0**3.502347
           fac2=10.d0**1.503692
           AisoNIPR=fac1*(dfloat(N)/6.d1)**9.250947d0
           AisoIPR=fac2*(dfloat(N)/6.d1)**11.08800d0
           If(N.gt.360) Write(Iout,1003) AisoNIPR,AisoIPR
          endif
 
      if(IPR.eq.0) then
       if(AisoNIPR.gt.dfloat(maxAiso)) then
        Write(Iout,1004) maxAiso
        Return
       endif
      else
       if(AisoIPR.gt.dfloat(maxAiso)) then
        Write(Iout,1004) maxAiso
        Return
       endif
      endif

C SPIRAL uses the subroutines written by Fowler and Manopoulus
      If(IPR.ge.0) then
       Write(Iout,1005)
       CALL Spiral(Natom,Nfaces,Nedges,N,IPR,Iout,Isonum,
     1 IsonumIPR,iham,IDA,A)
      endif

 1000 Format(/1X,'Number of possible fullerene isomers: ',I10,
     1 ' (IPR isomers: ',I10,')')
 1001 Format(/1X,'Number of possible fullerene isomers: ',A11,
     1 ' (IPR isomers: ',I10,')')
 1002 Format(/1X,'Number of possible fullerene isomers: ',A11,
     1 ' (IPR isomers: ',A11,')')
 1003 Format(/1X,'Exact number of isomers not known for such a'
     1 ' large fullerene, projected polynomial value:',D12.4,
     1 ' (general), ',D12.4,' (IPR)',
     1 /2X,'obtained from fit of points between Nc=250 and 360)')
 1004 Format(/1X,'Number of Isomers larger than max value of ',I8)
 1005 Format(/1X,'Enter Spiral code for a general list of all ',
     1 'possible isomers (IPR or not depending on input)')
      Return
      END 

      SUBROUTINE Schlegel(NAtom,Nfaces,Nedges,M,msrs,IOUT,IS1,IS2,IS3,
     1 N5M,N6M,N5R,N6R,NRing,Iring,ISchlegel,IC3,Dist,angle,Rmin,
     1 Tol,CR,CR5,CR6,Symbol)
C Produce points in 2D-space for Schlegel diagrams using the cone-
C projection method and the perspective projection. The fullerene
C is rotated first such that the desired point, edge or face is at
C the top. Euler angles are used for rotation.
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION Dist(3,NAtom),IAtom(NAtom),NRing(Nfaces),distw(3),c(3)
      DIMENSION CR5(3,Nfaces),CR6(3,Nfaces),vec1(3),Iring(Nfaces)
      DIMENSION N5M(Nfaces,5),N6M(Nfaces,6),Rot(3,3),CR(3,Nfaces)
      DIMENSION Rotz(3,3),Symbol(Nfaces),DistS(2,NAtom),RingS(2,Nfaces)
      DIMENSION IC3(natom,3)
      Character*1  Symbol,SRS(msrs,2*msrs),satom,sring,s5ring,s6ring
      Character*12 Symbol1
      Open(unit=2,file='qmga.dat',form='formatted')
      Data epsf,dpi/.12d0,3.14159265358979d0/
C     Parameter set for Program QMGA
      Data DPoint,Dedge/0.5d0,0.1d0/

      satom='o'
      s5ring='^'
      s6ring='*'
      do I=1,msrs
      do J=1,2*msrs
      SRS(I,J)=' '
      enddo
      enddo
      eps=Rmin*epsf
      iorig=0
      Do I=1,3
      Do J=1,3
      Rot(I,J)=0.d0
      enddo
      enddo
      Rot(1,1)=1.d0
      Rot(2,2)=1.d0
      Rot(3,3)=1.d0
      if(ISchlegel.eq.2) then
      WRITE(IOUT,1013) angle
      endif

C Align fullerene for Schlegel diagram
C First check input and determine the coordinates for alignment
C We allow for vertices, edges and ring centers
      If(IS1.NE.0) then
      WRITE(IOUT,1006) IS1,IS2,IS3

C Check of errors in input
      if(is1.lt.0.or.is2.lt.0.or.is3.lt.0) then
       WRITE(IOUT,1007)
       Return
      endif
      if(is2.gt.0.and.is1.eq.is2) then
       WRITE(IOUT,1007)
       Return
      endif
      if(is3.gt.0.and.(is3.eq.is2.or.is3.eq.is1)) then
       WRITE(IOUT,1007)
       Return
      endif

C Vertex
      If(is2.eq.0) then
        Do I=1,3
         c(I)=DIST(I,is1)
        enddo
       WRITE(IOUT,1008) is1,(c(i),i=1,3)
      endif

C Edge
      If(is2.ne.0.and.is3.eq.0) then
       rd=0.d0
        Do I=1,3
         rd=rd+(DIST(I,is1)-DIST(I,is2))**2
         c(I)=.5d0*(DIST(I,is1)+DIST(I,is2))
        enddo
       rdist=dsqrt(rd)
       rtol=rmin*(1.d0+Tol)
        If(rdist.gt.rtol) then
         WRITE(IOUT,1012) rdist,rtol
         Return
        endif
       WRITE(IOUT,1009) is1,is2,(c(i),i=1,3)
      endif

C Ring center
      If(is3.ne.0.and.is2.ne.0.and.is1.ne.0) then

C   Find ring
C   Search in 5-ring
      n6hit=0
      Do I=1,N5R
       n5hit=0
        Do J=1,5
         if(is1.eq.N5M(I,J)) n5hit=n5hit+1
         if(is2.eq.N5M(I,J)) n5hit=n5hit+1
         if(is3.eq.N5M(I,J)) n5hit=n5hit+1
          if(n5hit.eq.3) then
           c(1)=cr5(1,I) 
           c(2)=cr5(2,I) 
           c(3)=cr5(3,I) 
           IR=I
           go to 150
          endif
        enddo
      enddo
C   Search in 6-ring
      Do I=1,N6R
      n6hit=0
       Do J=1,6
        if(is1.eq.N6M(I,J)) n6hit=n6hit+1
        if(is2.eq.N6M(I,J)) n6hit=n6hit+1
        if(is3.eq.N6M(I,J)) n6hit=n6hit+1
        if(n6hit.eq.3) then 
         c(1)=cr6(1,I) 
         c(2)=cr6(2,I) 
         c(3)=cr6(3,I)
         IR=N5R+I 
         go to 150
        endif
       enddo
      enddo
 150  if(n5hit.eq.3) WRITE(IOUT,1010) IR,is1,is2,is3,(c(i),i=1,3)
      if(n6hit.eq.3) WRITE(IOUT,1016) IR,is1,is2,is3,(c(i),i=1,3)
      nhit=n5hit+n6hit
      if(nhit.lt.3) then
       WRITE(IOUT,1017) nhit
       Return
       endif
      endif

C  Now define the vector of the projection axis and rotate molecule
C  such that it coincides with the z-axis
C  **** This still needs some work for better alignement
      R=1.d0/dsqrt(c(1)**2+c(2)**2+c(3)**2)
      Do I=1,3
      distw(i)=c(i)*R
      enddo
      WRITE(IOUT,1014) (distw(i),i=1,3)
C   Construct rotation matrix
      CALL Rotmat(IOUT,Rot,distw)

C   Now rotate all vertices
      DO I=1,M
      distw(1)=Dist(1,I)
      distw(2)=Dist(2,I)
      distw(3)=Dist(3,I)
      CALL Rotate(Rot,distw,vec1)
      Dist(1,I)=vec1(1)
      Dist(2,I)=vec1(2)
      Dist(3,I)=vec1(3)
      enddo

C   Rotate all ring centers
      Do I=1,N5R
      distw(1)=CR5(1,I)
      distw(2)=CR5(2,I)
      distw(3)=CR5(3,I)
      CALL Rotate(Rot,distw,vec1)
      CR5(1,I)=vec1(1)
      CR5(2,I)=vec1(2)
      CR5(3,I)=vec1(3)
      enddo
      Do I=1,N6R
      distw(1)=CR6(1,I)
      distw(2)=CR6(2,I)
      distw(3)=CR6(3,I)
      CALL Rotate(Rot,distw,vec1)
      CR6(1,I)=vec1(1)
      CR6(2,I)=vec1(2)
      CR6(3,I)=vec1(3)
      enddo

      else
       WRITE(IOUT,1011)
       iorig=1
      endif

C   Sort distances according to z-values
      DO I=1,M
      IAtom(I)=I
      enddo
      DO I=1,M
      dMaxx=Dist(3,I)
      iMax=I
      DO K=I+1,M
      IF (dMaxx.lt.Dist(3,K)) then
      iMax=K
      dMaxx=Dist(3,K)
      endif
      enddo

C   Swap
      Do ii=1,3
      iw=IAtom(iMax)
      IAtom(iMax)=IAtom(I)
      IAtom(I)=iw
      distw(ii)=Dist(ii,imax)
      Dist(ii,imax)=Dist(ii,i)
      Dist(ii,i)=distw(ii)
      enddo
      enddo

C   Now do the same with ring centers
      NR=N5R+N6R
      DO I=1,NR
      IRing(I)=NRing(I)
      if(I.LE.N5R) then
      CR(1,I)=CR5(1,I)
      CR(2,I)=CR5(2,I)
      CR(3,I)=CR5(3,I)
      else
      CR(1,I)=CR6(1,I-N5R)
      CR(2,I)=CR6(2,I-N5R)
      CR(3,I)=CR6(3,I-N5R)
      endif
      enddo
      DO I=1,NR
      dMaxx=CR(3,I)
      iMax=I
      DO K=I+1,NR
      dMax1=CR(3,K)
      IF (dMaxx.lt.dmax1) then
      iMax=K
      dMaxx=dMax1
      endif
      enddo

C   Swap 
      ival=IRing(imax)
      IRing(imax)=IRing(I)
      IRing(I)=ival
      Do ii=1,3
      dval=CR(ii,imax)
      CR(ii,imax)=CR(ii,I)
      CR(ii,I)=dval
      enddo
      enddo

C Rotate around the z-axis such that in Schlegel projection
C an edge of the last ring is on the bottom
C Find first the edge and the rotation angle and build the
C rotation matrix
      if(iorig.eq.0) then
      ILast=IRing(NR)
C   Get shortest distance
      if(ILast.le.N5R) then 
      Symbol1='pentagon (P)'
      rminL=1.d10
      Do I=1,5
      Do J=I+1,5
      IA=N5M(ILast,I)
      IB=N5M(ILast,J)
      X=Dist(1,IA)-Dist(1,IB)
      Y=Dist(2,IA)-Dist(2,IB)
      Z=Dist(3,IA)-Dist(3,IB)
      RL=dsqrt(X**2+Y**2+Z**2)
      if(RL.lt.rminL) then
      rminL=RL
      IAL=IA
      IBL=IB
      endif
      enddo
      enddo
      else
      Symbol1='hexagon  (H)'
      rminL=1.d10
      ILast6=ILast-N5R
      Do I=1,6
      Do J=I+1,6
      IA=N6M(ILast6,I)
      IB=N6M(ILast6,J)
      X=Dist(1,IA)-Dist(1,IB)
      Y=Dist(2,IA)-Dist(2,IB)
      Z=Dist(3,IA)-Dist(3,IB)
      RL=dsqrt(X**2+Y**2+Z**2)
      if(RL.lt.rminL) then
      rminL=RL
      IAL=IA
      IBL=IB
      endif
      enddo
      enddo
      endif

C   Determine the rotation angle
C   Coordinates of vector to rotate
C   Get atom label
      Do j=1,M
      if(IAL.eq.IATOM(j)) IAN=J
      if(IBL.eq.IATOM(j)) IBN=J
      enddo
      X=.5d0*(Dist(1,IAN)+Dist(1,IBN))
      Y=.5d0*(Dist(2,IAN)+Dist(2,IBN))
      Z=.5d0*(Dist(3,IAN)+Dist(3,IBN))
      RL=dsqrt(X**2+Y**2)
      If(dabs(Y).gt.1.d-10) then
      anglev=datan(X/Y)
      else
      anglev=.5d0*dpi
      endif
      anglev=anglev+dpi
      anglevd=anglev*180.d0/dpi
      WRITE(IOUT,1020) Symbol1,anglevd,IAL,IBL,RL
C   Build the rotation matrix
      rw1=dcos(anglev)
      rw2=dsin(anglev)
      Rotz(1,1)=rw1
      Rotz(1,2)=-rw2
      Rotz(1,3)=0.d0
      Rotz(2,1)=rw2
      Rotz(2,2)=rw1
      Rotz(2,3)=0.d0
      Rotz(3,1)=0.d0
      Rotz(3,2)=0.d0
      Rotz(3,3)=1.d0
      WRITE(IOUT,1021)
C   Rotate the vertices
      DO I=1,M
      distw(1)=Dist(1,I)
      distw(2)=Dist(2,I)
      distw(3)=Dist(3,I)
      CALL Rotate(Rotz,distw,vec1)
      Dist(1,I)=vec1(1)
      Dist(2,I)=vec1(2)
      Dist(3,I)=vec1(3)
      enddo
C   Rotate the ring centers
      Do I=1,NR
      distw(1)=CR(1,I)
      distw(2)=CR(2,I)
      distw(3)=CR(3,I)
      CALL Rotate(Rotz,distw,vec1)
      CR(1,I)=vec1(1)
      CR(2,I)=vec1(2)
      CR(3,I)=vec1(3)
      enddo
C   Print Complete rotation matrix
      CALL Rotprint(Iout,Rot,Rotz)
      endif
C   Print the sorted vertices
      WRITE(IOUT,1000) eps
      Natomcirc=0
      Ncircle=1
      DO I=1,M
      Natomcirc=Natomcirc+1
      If(I.gt.1) then
      dif=dabs(Dist(3,I)-Dist(3,I-1))
      if(dif.gt.eps) then
      Ncircle=Ncircle+1
      Natomcirc=1
      endif
      endif
      WRITE(IOUT,1001) IAtom(I),(Dist(ii,I),II=1,3),Ncircle,Natomcirc
      enddo
      if(Natomcirc.ne.5.and.Natomcirc.ne.6) then
      WRITE(IOUT,1005)
      endif
C   Print the sorted ring centers
      WRITE(IOUT,1015) eps
      Natomcirc=0
      Ncircle=1
      DO I=1,NR
      Natomcirc=Natomcirc+1
      If(I.gt.1) then
      dif=dabs(CR(3,I)-CR(3,I-1))
      if(dif.gt.eps) then
      Ncircle=Ncircle+1
      Natomcirc=1
      endif
      endif
      If(IRing(I).le.N5R) then
      Symbol(I)='P'
      iboost=5
      else
      Symbol(I)='H'
      iboost=6
      endif
      WRITE(IOUT,1019) IRing(I),(CR(ii,I),II=1,3),
     1 Ncircle,Natomcirc,Symbol(I)
      enddo
      if(Natomcirc.ne.1) then
      WRITE(IOUT,1005)
      endif

C     Prepare for Program QMGA
      Write(2,901) M,DPoint,Dedge

      If(ISchlegel.eq.2) then
 
C     Cone projection using the input angle
C     Calculate distance of vertices from z-axis for projection
      app=rmin+Dist(3,1)
      WRITE(IOUT,1002)
C     Write out on file unit=2 for qmga
C     See http://qmga.sourceforge.net/
      sfac=dtan(angle*dpi/180.d0)
      Do I=1,M
      X=Dist(1,I)
      Y=Dist(2,I)
      Z=Dist(3,I)
      R=dsqrt(X*X+Y*Y)
      If(R.gt.eps) then
      Fac=(app-Z)/R*sfac
      else
      Fac=1.d0
      If(I.ne.1) Write(IOUT,1003)
      endif
C   Extra boost for the last ring points
      IVert=M-Iboost
      If(I.gt.IVert) then
      Fac=Fac*1.2d0
      endif
      DistS(1,I)=Dist(1,I)*Fac
      DistS(2,I)=Dist(2,I)*Fac

C   Print
      IAT=IAtom(i)
      WRITE(IOUT,1004) IAT,DistS(1,I),DistS(2,I),
     1 IC3(IAT,1),IC3(IAT,2),IC3(IAT,3),Fac
      Write(2,902) IAT,DistS(1,I),DistS(2,I),
     1 IC3(IAT,1),IC3(IAT,2),IC3(IAT,3)
      enddo
      WRITE(IOUT,1032)

C   Calculate distance of ring centers from z-axis for projection
      WRITE(IOUT,1018)
C   Choose point for angle determination in Schlegel diagram
      X0=CR(1,1)
      Y0=CR(2,1)
      XMAX=0.d0
      YMAX=1.d0
      Do I=1,NR
      X=CR(1,I)
      Y=CR(2,I)
      Z=CR(3,I)
      R=dsqrt(X**2+Y**2)
      If(R.gt.eps) then
      Fac=(app-Z)/R*sfac
      else
      Fac=1.d0
      endif
C   Angle between the two vectors cos^-1(a.b/|a||b|)*(180/pi)
      angle=0.d0
      if(I.ne.1) then
      dx=X-X0
      dy=Y-Y0
      dxm=Xmax-X0
      dym=Ymax-Y0
      r1=dsqrt(dx**2+dy**2)
      r2=dsqrt(dxm**2+dym**2)
      anglef=R1*R2
      if(dabs(anglef).gt.1.d-3) then
      farg=(dx*dxm+dy*dym)/anglef
      angle=dacos(farg)*180.d0/dpi
      else
      angle=0.d0
      endif
      if(dx.lt.0.d0) angle=360.d0-angle
      if(dabs(angle-360.d0).lt.1.d-2) angle=0.d0
      endif
      RingS(1,I)=CR(1,I)*Fac
      RingS(2,I)=CR(2,I)*Fac
C   Print
      WRITE(IOUT,1023) IRing(i),Symbol(i),RingS(1,I),RingS(2,I),
     1 Angle,Fac
      enddo

      else
C   Perspective projection using the input distance
C   Algorithm to produce symmetric Schlegel diagrams
C   Smallest and largest ring z-coordinate
      Z=CR(3,1)
      scale=.45d0
      zmin=CR(3,NR)
C   Setting point of projection
      if(angle.eq.0.d0) then
      app=scale*rmin+Z
      else
      app=angle+Z
      WRITE(IOUT,1031) angle
      endif
      WRITE(IOUT,1022) app
      Zproj=app-zmin
      WRITE(IOUT,1030)
C   Atoms
      Do I=1,M
      X=Dist(1,I)
      Y=Dist(2,I)
      Z=Dist(3,I)
      Fac=Zproj/(app-Z)
      DistS(1,I)=Dist(1,I)*Fac
      DistS(2,I)=Dist(2,I)*Fac
      IAT=IAtom(i)
      WRITE(IOUT,1028) IAT,DistS(1,I),DistS(2,I),
     1 IC3(IAT,1),IC3(IAT,2),IC3(IAT,3)
      Write(2,902) IAT,DistS(1,I),DistS(2,I),
     1 IC3(IAT,1),IC3(IAT,2),IC3(IAT,3)
      enddo
      WRITE(IOUT,1032)
      WRITE(IOUT,1029)
C   Rings
      Do I=1,NR
      X=CR(1,I)
      Y=CR(2,I)
      Z=CR(3,I)
C     Extra boost for rings
      Fac=1.1d0*Zproj/(app-Z)
      RingS(1,I)=CR(1,I)*Fac
      RingS(2,I)=CR(2,I)*Fac
      WRITE(IOUT,1027) IRing(i),Symbol(i),RingS(1,I),RingS(2,I)
      enddo
      endif

C   Produce Schlegel picture
C   Atoms
       span=0.d0
       iflaga=0
      do i=1,M
       xabs=dabs(DistS(1,I))
       yabs=dabs(DistS(2,I))
       if(yabs.gt.xabs) xabs=yabs
       if(xabs.gt.span) span=xabs
      enddo
       msrs2=msrs/2
       grid=dfloat(msrs2-1)
       grids=grid/span
      do i=1,M
      ix=int(DistS(1,I)*grids)
      ixpos=ix+msrs2
      iy=int(DistS(2,I)*grids)
      iypos=iy+msrs2
      if(ixpos.le.0) ixpos=1
      if(iypos.le.0) iypos=1 
      if(ixpos.gt.msrs) ixpos=msrs
      if(iypos.gt.msrs) iypos=msrs
      if(SRS(ixpos,2*iypos).eq.' ') then
      SRS(ixpos,2*iypos)=satom
       else
        iflaga=iflaga+1
       endif
      enddo
C   Rings
      iflagr=0
      do i=1,NR
      ix=int(RingS(1,I)*grids)
      ixpos=ix+msrs2
      iy=int(RingS(2,I)*grids)
      iypos=iy+msrs2
      if(ixpos.le.0) ixpos=1
      if(iypos.le.0) iypos=1 
      if(ixpos.gt.msrs) ixpos=msrs
      if(iypos.gt.msrs) iypos=msrs
      sring=s6ring
      if(IRing(i).le.12) sring=s5ring
      if(SRS(ixpos,2*iypos).eq.' ') then
        SRS(ixpos,2*iypos)=sring
       else
        iflagr=iflagr+1
       endif
      enddo
C   Print Schlegel picture
      WRITE(IOUT,1024) msrs,2*msrs 
      if(iflaga.ne.0.or.iflagr.gt.1) Write(6,1026) iflaga,iflagr
      do I=1,msrs
        WRITE(IOUT,1025) (SRS(I,J),J=1,2*msrs)
      enddo

  901 Format(I6,2F12.6)
  902 Format(I6,2(1X,F12.6),1X,3(1X,I6))
 1000 Format(/1X,'Schlegel diagram for selected projection point',
     1 /1X,' First sort z-distances and produce NC circles'
     2  ' with NA atoms on it: Tolerance= ',F12.6,/1X,
     3  '  Atom       X            Y            Z     NC  NA')
 1001 Format(1X,I4,3(1X,F12.6),2(1X,I3))
 1002 Format(/1X,'Now project the vertices and print adjacent '
     1 'vertices:',/1X,'  Atom       X            Y     '
     1 '  N1   N2   N3   Scale factor')
 1003 Format(1X,'Warning: Fullerene probably misaligned for'
     1 ' Schlegel diagram')
 1004 Format(1X,I4,2(1X,F12.6),1X,3(1X,I4),' / ',F12.6)
 1005 Format(1X,'Warning: Fullerene probably misaligned for'
     1 ' Schlegel diagram (last circumfence should be a'
     2 ' pentagon or hexagon with ring center in the middle)')
 1006 Format(1X,'Aligning Fullerene, Input: ',3I4)
 1007 Format(1X,'ERROR in input')
 1008 Format(1X,'Vertex of atom ',I4,' chosen for Schlegel alignment.',
     1 ' Coordinates of vertex: X= ',F12.6,', Y= ',F12.6,', Z= ',F12.6)
 1009 Format(1X,'Edge between atoms ',I4,' and ',I4,
     1 ' chosen for Schlegel alignment.',
     2 ' Coordinates of edge center: X= ',
     3 F12.6,', Y= ',F12.6,', Z= ',F12.6)
 1010 Format(1X,'5-Ring center 'I4,' defined by atoms ',I4,' , ',
     1 I4,' and ',I4,' chosen for Schlegel alignment.',
     2 /1X,' Coordinates of ring center: X= ',
     3 F12.6,', Y= ',F12.6,', Z= ',F12.6)
 1011 Format(1X,'Original input coordinates chosen'
     1 ' for Schlegel alignment')
 1012 Format(1X,'ERROR: distance for edge ',F12.6,' greater than',
     1 ' tolerance distance of ',F12.6)
 1013 Format(/1X,'Algorithm for producing the Schlegel diagram'
     1 //1X,'Cone Projection using projection angle of ',
     1 d10.4,' degrees')
 1014 Format(1X,'Now do the rotation mapping vector (',
     1 F8.4,',',F8.4,',',F8.4,') into (0,0,1)')
 1015 Format(/1X,'Same for ring centers producing NC circles'
     2  ' with NA centers on it: Tolerance= ',F12.6,/1X,
     3  '  Ring       X            Y            Z     NC  NA  PG',
     4  ' (P: pentagon, H: hexagon)')
 1016 Format(1X,'6-Ring center ',I4,' defined by atoms ',I4,' , ',
     1 I4,' and ',I4,' chosen for Schlegel alignment.',
     2 /1X,' Coordinates of ring center: X= ',
     3 F12.6,', Y= ',F12.6,', Z= ',F12.6)
 1017 Format(1X,'ERROR: No ring found with given atom numbers',
     1 ' (indices found: ',I3,')')
 1018 Format(/1X,'Finally project the ring centers:',/1X,
     2  '  Ring         X            Y      Spiral Angle  Scale factor')
 1019 Format(1X,I4,3(1X,F12.6),2(1X,I3),3X,A1)
 1020 Format(1X,'Last ring is a ',A12,/1X,
     1 'Rotate around the z-axis by ',F12.4,' degrees',/1X,
     2 ' This moves the edge of the last ring between atoms ',
     3 I4,' and ',I4,' with distance ',F12.4,' to the bottom',
     4 ' the Schlegel diagram')
 1021 Format(1X,'')
 1022 Format(/1X,'Perspective Projection using Z= ',
     1 d10.4,' on z-axis')
 1023 Format(1X,I4,1X,A1,2(1X,F12.6),4X,F7.2,' / ',F12.6)
 1024 Format(/1X,'Schlegel diagram of points (o) and rings ',
     1 '(^ for 5 and * for 6) on a (',I3,','I3,') matrix:')
 1025 Format(2X,200A1)
 1026 Format(1X,'Fullerene too large for Schlegel picture, ',
     1 'could not print ',I3,' atom symbols and ',I3,' ring symbols: ',
     1 /2X,'Either increase parameter  msrs  or use proper ',
     1 'plotting ptogram')
 1027 Format(1X,I4,1X,A1,2(1X,F12.6))
 1028 Format(1X,I4,2(1X,F12.6),1X,3(1X,I4))
 1029 Format(/1X,'Finally project the ring centers:',/1X,
     2  '  Ring         X            Y')
 1030 Format(/1X,'Now project the vertices and print adjacent vertices:'
     2 /1X,'  Atom       X            Y       N1   N2   N3')
 1031 Format(/1X,'Reset focal point distance to nearest ring to ',F12.6)
 1032 Format(/1X,'File qmga.dat written out for input into',
     1 ' program QMGA')
  
      Close(unit=2)
      Return
      END

      SUBROUTINE spwindup(NMAX,MMAX,M,MP,Iout,D,S,JP,IER)
      IMPLICIT INTEGER (A-Z)
      DIMENSION D(MMAX,MMAX),S(MMAX),JP(12),IR(12),JR(12),JS(12)
C This routine tries to find the spiral from a preset of
C three connected rings stored in S(1), S(2) and S(3) using
C information on ring fusions from the dual matrix

      IER=0
      iring=0
      mloop=3
C   Big loop from ring 4 to the end
      Do 10 i=4,M
       if(i.gt.5) mloop=5
       ifound=0
       IP=S(i-1)
       if(IP.eq.0) go to 10
C    Find new ring connection to ring IP, but keep previous ones out
C    and store in IR
         IC=0
         Do j=1,M
           if(D(j,IP).eq.1) then
           iflag=0
            do k=1,i-2
            if(j.eq.s(k)) iflag=1
            enddo
            if(iflag.eq.0) then
              IC=IC+1
              IR(IC)=J
            endif
           endif
         enddo
       if(IC.gt.6.or.IC.eq.0) Go to 10
C    Find the ring adjacent to IP and to a previous ring
C    in the spiral and store
           iring=0
          do j=1,IC
           do k=1,i-mloop
            IX=S(k)
            if(D(IR(j),IX).eq.1) then
            iring=iring+1
            JR(iring)=IR(j)
            JS(iring)=k
            endif
           enddo
          enddo
C    Check if spiral is at dead end
      if(iring.eq.0) then
        IER=1
      Return
      endif
C    Now determine neighboring ring
         k=100000
         do j=1,iring
          if(JS(j).lt.k) then
          s(i)=JR(j)
          k=JS(j)
          endif
         enddo
C    Now check if it is a pentagon
            if(s(i).le.12) then
            MP=MP+1
            JP(MP)=i
            endif
  10  Continue
C    Spiral found if loop went through
C     Print*,M,IER,'/',(S(I),I=1,M)
C     Print*,iring,'/',JP
      Return
      END

      SUBROUTINE SpiralSearch(NMAX,MMAX,LMAX,NSP,N,Iout,IRG55,IRG66,
     1 IRG56,NrA,NrB,NrC,NrD,NrE,NrF)
      IMPLICIT INTEGER (A-Z)
      DIMENSION NrA(LMAX),NrB(LMAX),NrC(LMAX),NrD(LMAX)
      DIMENSION NrE(LMAX),NrF(LMAX),NMR(6),JP(12)
      DIMENSION Spiral(12,NMAX),SpiralT(12,NSP),SpiralF(MMAX,NSP)
      DIMENSION D(MMAX,MMAX),S(MMAX)
      CHARACTER*3 GROUP

C     This subroutine has been modified from the original one of Fowler and 
C     Manopoulus "An Atlas of Fullerenes" (Dover Publ., New York, 2006).           
C     It is used if dual matrix is already known. See subroutine Spiral for details.
C     N is the nuclearity of the fullerene.
      M=N/2+2
      ispiral=0
      WRITE (Iout,600)
         IF(N.lt.100) WRITE(Iout,601) N,M
         IF(N.ge.100) WRITE(Iout,602) N,M
      do I=1,MMAX
      do J=1,MMAX
       D(I,J)=0
      enddo
      enddo
      do I=1,12
      do J=1,NMAX
       Spiral(I,J)=0
      enddo
      enddo
C     Set up dual matrix
      do I=1,IRG55
       I1=NrA(I)
       I2=NrB(I)
       D(I1,I2)=1
       D(I2,I1)=1
      enddo
      do I=1,IRG56
       I1=NrC(I)
       I2=NrD(I)
       D(I1,I2)=1
       D(I2,I1)=1
      enddo
      do I=1,IRG66
       I1=NrE(I)
       I2=NrF(I)
       D(I1,I2)=1
       D(I2,I1)=1
      enddo

C     Search for all spirals 
C     Set up first three rings then wind
C     Start ring spiral algorithm. Quit after first successful spiral
C     JP contains the pentagon indices, S the ring numbers
      nspiral=0
      
C     Loop over all (5,5) fusions
      if(IRG55.eq.0) then
       write(Iout,610)
      else
       write(Iout,611) 2*IRG55
       do I=1,2*IRG55
       do j=4,M
        s(j)=0
       enddo
       if(I.le.IRG55) then
        I1=NrA(I)
        I2=NrB(I)
       else
        IR=I-IRG55
        I1=NrB(IR)
        I2=NrA(IR)
       endif
        S(1)=I1
        S(2)=I2
        JP(1)=1
        JP(2)=2
       do J=1,M
        if(D(I1,J).eq.1.and.D(I2,J).eq.1) then
         S(3)=J
         MP=2
         if(J.le.12) then
          JP(3)=3
          MP=3
         endif
          CALL spwindup(NMAX,MMAX,M,MP,Iout,D,S,JP,IER)
         if(IER.eq.0) then
         nspiral=nspiral+1
         If(nspiral.gt.NSP) then
         Write(Iout,626) nspiral,nsp
         nspiral=nspiral-1
         Go to 199
         endif
         do k=1,12
          SpiralT(k,nspiral)=JP(k)
         enddo 
         do k=1,M
          SpiralF(k,nspiral)=S(k)
         enddo 
         endif
        endif
       enddo 
       enddo 
      endif

C     Loop over all (5,6) fusions
      if(IRG56.le.0) then
      write(Iout,615)
      else
      write(Iout,612) 2*IRG56
      do I=1,2*IRG56
      do j=4,M
      s(j)=0
      enddo
      if(I.le.IRG56) then
      I1=NrC(I)
      I2=NrD(I)
      else
      IR=I-IRG56
      I1=NrD(IR)
      I2=NrC(IR)
      endif
      S(1)=I1
      S(2)=I2
      if(I1.le.12) then
      JP(1)=1
      else
      JP(2)=1
      endif
      do J=1,M
      if(D(I1,J).eq.1.and.D(I2,J).eq.1) then
      S(3)=J
      MP=1
      if(J.le.12) then
      JP(2)=3
      MP=2
      endif
      CALL spwindup(NMAX,MMAX,M,MP,Iout,D,S,JP,IER)
      if(IER.eq.0) then
      nspiral=nspiral+1
         If(nspiral.gt.NSP) then
         Write(Iout,627) nspiral,nsp
         nspiral=nspiral-1
         Go to 199
         endif
      do k=1,12
      SpiralT(k,nspiral)=JP(k)
      enddo 
      do k=1,M
      SpiralF(k,nspiral)=S(k)
      enddo 
      endif
      endif
      enddo 
      enddo 
      endif
      
C     Loop over all (6,6) fusions
      if(IRG66.eq.0) then
      write(Iout,616)
      else
      write(Iout,613) 2*IRG66
      do I=1,2*IRG66
       do j=4,M
        s(j)=0
       enddo
       if(I.le.IRG66) then
        I1=NrE(I)
        I2=NrF(I)
       else
        IR=I-IRG66
        I1=NrF(IR)
        I2=NrE(IR)
       endif
       S(1)=I1
       S(2)=I2
       do J=1,M
        if(D(I1,J).eq.1.and.D(I2,J).eq.1) then
          S(3)=J
          MP=0
         if(J.le.12) then
          JP(1)=3
          MP=1
         endif
       CALL spwindup(NMAX,MMAX,M,MP,Iout,D,S,JP,IER)
       if(IER.eq.0) then
        nspiral=nspiral+1
         If(nspiral.gt.NSP) then
         Write(Iout,628) nspiral,nsp
         nspiral=nspiral-1
         Go to 199
         endif
       do k=1,12
        SpiralT(k,nspiral)=JP(k)
       enddo 
       do k=1,M
        SpiralF(k,nspiral)=S(k)
       enddo 
       endif
      endif
      enddo 
      enddo 
      endif
      
C     Now loop over with found spiral until success with
C     Fowler algorithm
  199 write(Iout,614) nspiral
      IT=1
      IPR=0
      Do 13 msp=1,nspiral
       Do I=1,M
        S(I)=6
       enddo
       Do I=1,12
        S(SpiralT(I,msp))=5
        JP(I)=SpiralT(I,msp)
       enddo
       IER=0
       CALL Windup(MMAX,M,IPR,IER,S,D)      !      Wind up spiral into dual 
       IF(IER.ne.0) GO TO 13                !      and check for closure 
       Do I=1,12 
        Spiral(I,1)=JP(I)
       enddo
       CALL Unwind(NMAX,MMAX,LMAX,M,IER,IT,ispiral,
     1  Spiral,S,D,NMR,Group)             ! Unwind dual into spirals 
       K=0
       DO J=1,6
         IF(NMR(J).EQ.0) GO TO 16
         K=J
       enddo
 16    If(K.le.0) then
        WRITE(Iout,603) GROUP,(JP(I),I=1,12)
       else
        WRITE(Iout,605) GROUP,(JP(I),I=1,12),(NMR(J),J=1,K)
       endif
       WRITE(Iout,604) 
       WRITE(Iout,618) (SpiralF(I,msp),I=1,M)
       if(ispiral.ge.2) then
        if(ispiral.eq.2) then
         WRITE(Iout,623)
         Do II=1,12
          JP(II)=spiral(II,2)
         enddo 
        else
         WRITE(Iout,619) ispiral-1
        endif
       Do JJ=2,ispiral 
        WRITE(Iout,607) (spiral(II,JJ),II=1,12)
       enddo
       else
        WRITE(Iout,608)
       endif
       if(ispiral.gt.2) then
        CALL CanSpiral(NMAX,ispiral,spiral,JP)
        WRITE(Iout,623)
        WRITE(Iout,621) (JP(I),I=1,12)
       endif
       Do I=1,M
        S(I)=6
       enddo
       Do I=1,12
        S(JP(I))=5
       enddo
       WRITE(Iout,624)
       WRITE(Iout,625) (S(I),I=1,M)
       go to 99
 13   CONTINUE 
 99   if(IER.eq.0) then
       if(ispiral.ge.2) then
C     Print ring numbers
        WRITE(Iout,620) nspiral 
       Do msp=1,nspiral
         jpc=0
       Do ipent=1,12
         jpc=jpc+iabs(JP(ipent)-SpiralT(ipent,msp))
       enddo
        if(jpc.eq.0) then
        WRITE(Iout,618) (SpiralF(I,msp),I=1,M)
        return
        endif
       enddo
       endif
      else 
      WRITE(Iout,617)
      endif
 600  FORMAT(/1X,'Modified spiral algorithm Fowler and Manopoulus',
     1 ' (An Atlas of Fullerenes, Dover Publ., New York, 2006)')
 601  FORMAT(1X,'Spiral for fullerene isomers of C',I2,':',
     1 ' (',I3,' faces)')
 602  FORMAT(1X,'Spiral for fullerene isomers of C',I3,':',
     1 ' (',I3,' faces)')
 603  FORMAT(1X,A3,9X,12I4)
 604  FORMAT(1X,90('-'),/1X,'Corresponding ring numbers:') 
 605  FORMAT(1X,A3,9X,12I4,2X,3(I3,' x',I3,:,','))
 606  Format(/1X,'Spiral list of pentagon positions with ',
     1 'higher priority: (',I3,' spirals found)') 
 607  Format(12(1X,I3))
 608  Format(1X,'Input spiral is canonical')
 609  Format(/1X,'Canonical spiral list of pentagon positions')
 610  Format(1X,'This is an IPR fullerene, no (5,5) fusions to ',
     1 'loop over')
 611  Format(1X,'Loop over (5,5) fusions, ',I5,' max in total')
 612  Format(1X,'Loop over (5,6) fusions, ',I5,' max in total')
 613  Format(1X,'Loop over (6,6) fusions, ',I5,' max in total')
 614  Format(1X,I4,' Spirals found',/1X,
     1 'Point group   Ring spiral pentagon positions',
     2 19X,'NMR pattern (for fullerene in ideal symmetry)',/1X,90('-')) 
 615  Format(1X,'This is C20, no (5,6) fusions to loop over')
 616  Format(1X,'No (6,6) fusions to loop over')
 617  Format(1X,'Failed to find ring spiral')
 618  Format(20(1X,32(I3,'-'),/))
 619  Format(1X,'Spiral list of pentagon positions with ',
     1 'higher priority: (',I3,' spirals found)') 
 620  Format(1X,'Search ',I3,' spirals to produce canonical'
     1 ' list of atoms:')
 621  Format(12(1X,I3))
 622  Format(1X,'Input spiral is canonical')
 623  Format(1X,'Canonical spiral list of pentagon positions:')
 624  Format(1X,'Canonical spiral list of hexagons and pentagons:')
 625  Format(1X,100I1)
 626  Format(1X,'**** Severe Warning: Number of detected spirals is ',
     1 I5,' greater than dimension in field ',I5,' detected in (5,5)',
     1 'list',/1X,'Routine will stop here and tries to work with ',
     1 'existing spirals (otherwise increase NSpScale parameter ',
     1 'in main program')
 627  Format(1X,'**** Severe Warning: Number of detected spirals is ',
     1 I5,' greater than dimension in field ',I5,' detected in (5,6)',
     1 'list',/1X,'Routine will stop here and tries to work with ',
     1 'existing spirals (otherwise increase NSpScale parameter ',
     1 'in main program')
 628  Format(1X,'**** Severe Warning: Number of detected spirals is ',
     1 I5,' greater than dimension in field ',I5,' detected in (6,6)',
     1 'list',/1X,'Routine will stop here and tries to work with ',
     1 'existing spirals (otherwise increase NSpScale parameter ',
     1 'in main program')
      Return
      END
      
      SUBROUTINE Rotprint(Iout,Rot,Rotz)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION Rot(3,3),Rotz(3,3),RotC(3,3)
      DO I =1,3
      DO K =1,3
      RotC(I,K)=0.d0
      DO J =1,3
      RotC(I,K)=RotC(I,K)+Rotz(I,J)*Rot(J,K)
      enddo
      enddo
      enddo
      Write(Iout,1001)
      Write(Iout,1002) ((RotC(I,J),J=1,3),I=1,3)
 1001 Format(1X,'Complete rotation matrix:')
 1002 Format(3(' |',F12.6,1X),' |')
      Return
      END
 
      SUBROUTINE Rotmat(Iout,Rot,vec)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION Rot(3,3),vec(3),vec1(3)
      data dpi,eps/3.14159265358979d0,1.d-8/
C     Construct rotation matrix for turning vec into (0,0,1)
C     First rotate around y-axis to produce (0,y1,z1)
      beta=datan(-vec(1)/vec(3))
      facw=180.d0/dpi
      betaw=beta*facw
      cosb=dcos(beta)
      sinb=dsin(beta)
      xi=cosb*vec(1)+sinb*vec(3)
      yi=vec(2)
      zi=cosb*vec(3)-sinb*vec(1)
C     Then  rotate around x-axis to produce (0, 0,z2)
      alpha=datan(yi/zi)
      alphaw=alpha*facw
      cosa=dcos(alpha)
      sina=dsin(alpha)
C     Produce matrix
      Rot(1,1)=cosb
      Rot(1,2)=0.d0
      Rot(1,3)=sinb
      Rot(2,1)=sina*sinb
      Rot(2,2)=cosa
      Rot(2,3)=-sina*cosb
      Rot(3,1)=-cosa*sinb
      Rot(3,2)=sina
      Rot(3,3)=cosa*cosb
C     Now checking on the original vector
      CALL Rotate(Rot,vec,vec1)
      anorm=dsqrt(vec1(1)**2+vec1(2)**2+vec1(3)**2)
      dif=dabs(anorm-1.d0)
      If(dif.gt.eps) then
      Write(Iout,1000) dif
      endif
      vec1(1)=0.d0
      vec1(2)=0.d0
      if(vec1(3).lt.0.d0) then
      vec1(3)=-vec1(3)
      do i=1,3
      do j=1,3
      Rot(I,J)=-Rot(I,J)
      enddo
      enddo
      endif
      Write(Iout,1001) betaw,alphaw,anorm,vec1(3)
      Write(Iout,1002) 
      Write(Iout,1003) ((Rot(I,J),J=1,3),I=1,3)
 1000 Format(1X,'WARNING: Vector should be unit vector but is ',F12.6)
 1001 Format(1X,'Rotate around y-axis by ',F12.6,' degrees, then'
     1          ' rotate around x-axis by ',F12.6,' degrees.',
     2          ' Norm: ',F12.6,', Z= ',F12.6)
 1002 Format(1X,'Rotation matrix:')
 1003 Format(3(' |',F12.6,1X),' |')
      Return
      END
 
      SUBROUTINE Rotate(Rot,vec,vec1)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION Rot(3,3),vec(3),vec1(3)
      vec1(1)=Rot(1,1)*vec(1)+Rot(1,2)*vec(2)+Rot(1,3)*vec(3)
      vec1(2)=Rot(2,1)*vec(1)+Rot(2,2)*vec(2)+Rot(2,3)*vec(3)
      vec1(3)=Rot(3,1)*vec(1)+Rot(3,2)*vec(2)+Rot(3,3)*vec(3)
      Return
      END
 
      SUBROUTINE Diameter(Natom,M,IOUT,Dist,diam)
C Calculate largest and smallest atom-to-atom diameters
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION Dist(3,Natom),diam(Natom),imirror(Natom),jmirror(Natom)
      Data difeps/1.d-6/
      Do i=1,M
C     Search for the closest carbon atom to dmirror
      distmin=1.d10
      Do k=1,M
      if(i.ne.k) then
      x=-Dist(1,i)-Dist(1,k)
      y=-Dist(2,i)-Dist(2,k)
      z=-Dist(3,i)-Dist(3,k)
      distm=dsqrt(x*x+y*y+z*z)
      if(distm.lt.distmin) then
      distmin=distm
      kmin=k
      endif
      endif
      enddo
      x=Dist(1,i)-Dist(1,kmin)
      y=Dist(2,i)-Dist(2,kmin)
      z=Dist(3,i)-Dist(3,kmin)
      diam(i)=dsqrt(x*x+y*y+z*z)
      imirror(i)=kmin
      enddo
C     Sort from the largest to the smallest diameter
C     and delete duplicates
      CALL SortR(Natom,M,Mnew,imirror,jmirror,diam)
      Write(IOUT,1000) Mnew
      If(Mnew.ne.M/2) Write(IOUT,1002) Mnew,M/2
      Write(IOUT,1001) (imirror(i),jmirror(i),diam(i),i=1,MNew)
      dif=diam(1)-diam(MNew)
      if(dif.lt.difeps) then
      Write(IOUT,1003)
      else
C     Calculate the moment of inertia tensor and diagonalize (no mass)
      endif
 1000 Format(/1X,' Atom-to-atom largest diameters obtained from ',
     1 'inversion through center of points sorted largest to '
     2 'smallest: (',I4,' values)')
 1001 Format(5(1X,'(',I4,',',I4,')',2X,D14.8))
 1002 Format(1X,' Error: Check subroutine diameter',2I4)
 1003 Format(1X,' Diameters indicate that points lie on a sphere')
      Return
      END
 
      SUBROUTINE Sortr(ndim,M,Mnew,imirror,jmirror,diam)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION imirror(ndim),jmirror(ndim),diam(ndim)
      DIMENSION imirrorw(ndim),jmirrorw(ndim),diamw(ndim)
      ICOUNT=0
      DO I=1,M
      DO K=I+1,M
C     Delete duplicates
      IF(I.eq.imirror(k).and.K.eq.imirror(i)) then
      ICOUNT=ICOUNT+1
      imirrorw(ICOUNT)=I
      jmirrorw(ICOUNT)=imirror(I)
      diamw(ICOUNT)=diam(I)
      endif
      enddo
      enddo
      Mnew=Icount
C     Now sort values of diamw, output diam
      DO I=1,MNew
      dMax=diamw(I)
      im=imirrorw(i)
      jm=jmirrorw(i)
      ivec=i
      DO K=I+1,MNew
      IF (dMax.LT.diamw(K)) then
      im=imirrorw(K)
      jm=jmirrorw(K)
      dMax=diamw(K)
      Ivec=K
      endif
      enddo
      imirror(i)=im
      jmirror(i)=jm
      diam(I)=dMax
      if(ivec.ne.i) then
      imirrorw(ivec)=imirrorw(i)
      jmirrorw(ivec)=jmirrorw(i)
      diamw(ivec)=diamw(i)
      endif
      enddo
      RETURN
      END

      SUBROUTINE MaxInSphere(ndim,M,IOUT,Dist,c,RVdWC)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION Dist(3,ndim),c(3)
      DATA API/3.14159265358979d0/
      DATA itermax/10000000/
      DATA eps/1.d-8/
      IOP=1
C     Get the maximum inner sphere
      Write(IOUT,1000) 
C    Initial step
      Call MAInorm(ndim,3,M,IP,RMIS,c,Dist)
      Write(IOUT,1001) RMIS,IP,(c(i),i=1,3)
      VMIS=4.d0/3.d0*Api*RMIS**3
      AMIS=4.d0*Api*RMIS**2
      Write(IOUT,1002) RMIS,VMIS,AMIS
C     Start Iteration
      CALL powell(ndim,3,iter,Iout,IOP,ier,M,eps,AN,RMIS,c,Dist)
C     End Iteration
      if(ier.eq.1) then
       Write(IOUT,1010)
       Return
      endif
      Call MAInorm(ndim,3,M,IP,RMIS,c,Dist)
      Write(IOUT,1003) RMIS,IP,(c(i),i=1,3)
      VMIS=4.d0/3.d0*Api*RMIS**3
      AMIS=4.d0*Api*RMIS**2
      Write(IOUT,1004) RMIS,VMIS,AMIS
      RealMIS=RMIS-RVdWC
      VVdWC=4.d0/3.d0*Api*RealMIS**3
      Write(IOUT,1005) RVdWC,RealMIS,VVdWC
 1002 Format(/1x,'Initial values (in units of input):',
     1 /1x,' Radius of maximum inner sphere: ',D14.8,
     1 /1x,' Volume of maximum inner sphere: ',D14.8,
     1 /1x,' Area   of maximum inner sphere: ',D14.8)
 1001 Format(1X,'Initial inner radius: ',d12.6,' to point ',I5,
     1 ' taken from center of MDS at (X,Y,Z): ',3(D14.8,2X))
 1000 Format(/1X,'Calculate the maximum inner sphere')
 1003 Format(1X,'Inner radius: ',d12.6,' to point ',I5,
     1 ' taken from center of MIS at (X,Y,Z): ',3(D14.8,2X))
 1004 Format(/1x,'Final values (in units of input):',
     1 /1x,' Radius of maximum inner sphere: ',D14.8,
     1 /1x,' Volume of maximum inner sphere: ',D14.8,
     1 /1x,' Area   of maximum inner sphere: ',D14.8)
 1005 Format(/1x,'Subtracting Van der Waals radius of carbon ',
     1 F8.4,' gives VdW inner sphere radius of ',D14.8,
     1 ' and volume of ',D14.8)
 1010 Format(/1x,'**** Error in MaxInSphere, Problem ill-defined')
      RETURN
      END

      SUBROUTINE MinDistSphere(ndim,M,IOUT,Dist,Rmin,Rmax,
     1 distP,c,radiusi)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION Dist(3,ndim),distP(ndim),c(3)
C     Get the minimum distance sphere
      
      DATA API/3.14159265358979d0/
      DATA itermax/10000000/
      DATA eps/1.d-8/

      Write(IOUT,1000) 

C    Initial step
C    Calculate the MDS norm

      IOP=0
      Call MDSnorm(ndim,3,M,AN,RMDSI,c,Dist)
      Write(IOUT,1001) RMDSI,(c(i),i=1,3)
      VMDSI=4.d0/3.d0*Api*RMDSI**3
      AMDSI=4.d0*Api*RMDSI**2
      VMDS=VMDSI
      AMDS=AMDSI
      RMDS=RMDSI
      Write(IOUT,1002) RMDSI,VMDS,AMDS
      Write(IOUT,1003) AN
C     Start Iteration
      CALL powell(ndim,3,iter,Iout,IOP,ier,M,eps,AN,RMDSI,c,Dist)
C     End Iteration
      if(ier.eq.1) then
       Write(IOUT,1010)
       Return
      endif
      Call MDSnorm(ndim,3,M,AN,RMDSI,c,Dist)
      Write(IOUT,1004) iter,(c(i),i=1,3),AN
      VMDSI=4.d0/3.d0*Api*RMDSI**3
      AMDSI=4.d0*Api*RMDSI**2
      VMDS=VMDSI
      AMDS=AMDSI
      RMDS=RMDSI
      rmin=1.d8
      Do i=1,M
       dx=dist(1,I)-c(1)
       dy=dist(2,I)-c(2)
       dz=dist(3,I)-c(3)
       dp=dsqrt(dx*dx+dy*dy+dz*dz)
       if(dp.lt.rmin) rmin=dp
      enddo
      distortion=100.d0*AN/rmin
      Write(IOUT,1005) RMDSI,VMDS,AMDS,rmin,distortion
 1000 Format(/1X,'Calculate the minimum distance sphere')
 1001 Format(1X,'Initial average radius: ',d12.6,
     1 ' taken from center of MCS at (X,Y,Z): ',3(D14.8,2X))
 1002 Format(/1x,'Initial values (in units of input):',
     1 /1x,' Radius of minimum distance sphere: ',D14.8,
     1 /1x,' Volume of minimum distance sphere: ',D14.8,
     1 /1x,' Area of  minimum distance  sphere: ',D14.8)
 1003 Format(1x,' Norm: ',D14.8)
 1004 Format(/1x,'Final result after ',I4,' iterations',
     1 ' (in units of input): '
     1 /1X,'Center (x,y,z) of MDS: ',3(D14.8,2X),
     1 3X,'Norm: ',D14.8)
 1005 Format(/1x,'Final values (in units of input):',
     1 /1x,' Radius of minimum distance sphere:   ',D14.8,
     1 /1x,' Volume of minimum distance sphere:   ',D14.8,
     1 /1x,' Area of  minimum distance  sphere:   ',D14.8,
     1 /1x,' Smallest point distance from center: ',D14.8,
     1 /1x,' MDS distortion parameter in percent: ',D14.8)
 1010 Format(/1x,'**** Error in MaxInSphere, Problem ill-defined')
      Return
      End

      SUBROUTINE MAInorm(ndim,ncom,M,IP,dm,c,d)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION d(3,ndim),c(ncom)
C     Calculate minimum distance to center c
      dm=1.d8
      Do i=1,M
       dx=d(1,I)-c(1)
       dy=d(2,I)-c(2)
       dz=d(3,I)-c(3)
       dp=dsqrt(dx*dx+dy*dy+dz*dz)
       if(dp.lt.dm) then
        dm=dp
        IP=i
       endif
      enddo
      Return
      End

      SUBROUTINE MDSnorm(ndim,ncom,M,A,davd,c,d)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION d(3,ndim),c(ncom),dp(ndim)
C     Calculate norm for minimum distance sphere
      XM=dfloat(M)
      dav=0.d0
      Do i=1,M
       dx=d(1,I)-c(1)
       dy=d(2,I)-c(2)
       dz=d(3,I)-c(3)
       dp(i)=dsqrt(dx*dx+dy*dy+dz*dz)
       dav=dav+dp(i)
      enddo
      davd=dav/XM
      ddav=0.d0
      Do i=1,M
       ddav=ddav+dabs(davd-dp(i)) 
      enddo
      A=ddav/XM
      Return
      End

      SUBROUTINE MinCovSphere2(ndim,M,IOUT,Dist,Rmin,Rmax,
     1 VCS,ACS,Atol,VTol,u,c,radius,RVdWC)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION Dist(3,ndim)
      DIMENSION u(ndim),c(3),Kappa(ndim)
C     Get the minimum covering sphere using algorithm 2 by E.A.Yildirim
      DATA API/3.14159265358979d0/
      DATA itermax/10000000/
      DATA eps,disteps/1.d-12,1.d-5/
      epsilon=(1.d0+eps)**2-1.d0
      Write(IOUT,1000) M,epsilon
 1000 Format(/1X,'Calculate the minimum covering sphere using',
     1 ' the algorithm 2 given by E.A.Yildirim,'
     2 ' SIAM Journal on Optimization 19(3), 1368 (2008):',
     3 /1X,' Number of points in 3-D space: ',I4,
     4 ', epsilon for convergence: ',d12.6,/1X,
     5 ' Start search using the center of points and radius to ',
     6 'furthest point from the center as initial guess')
C   
C    Initial step
C 
      do i=1,M
        u(i)=0.d0
      enddo
      xmax=0.d0
      ialpha=0
C    Algorithm changed here by taking the furthest 
C    point from the center of points
      do i=1,M
        dx=Dist(1,i)
        dy=Dist(2,i)
        dz=Dist(3,i)
C       dx=Dist(1,1)-Dist(1,i)
C       dy=Dist(2,1)-Dist(2,i)
C       dz=Dist(3,1)-Dist(3,i)
        Xnorm=dx*dx+dy*dy+dz*dz
          if(Xnorm.gt.xmax) then
            ialpha=i
            xmax=Xnorm
          endif
      enddo
      xmax=0.d0
      ibeta=0
      do i=1,M
        dx=Dist(1,ialpha)-Dist(1,i)
        dy=Dist(2,ialpha)-Dist(2,i)
        dz=Dist(3,ialpha)-Dist(3,i)
        Xnorm=dx*dx+dy*dy+dz*dz
          if(Xnorm.gt.xmax) then
            ibeta=i
            xmax=Xnorm
          endif
      enddo
      u(ialpha)=.5d0
      u(ibeta)=.5d0
C     Size of set Kappa (number of vectors)
      nkappa=2
      Kappa(1)=ialpha
      Kappa(2)=ibeta
      do j=1,3
        c(j)=.5d0*(Dist(j,ialpha)+Dist(j,ibeta))
      enddo 
      gammak=fpsi(ndim,M,u,dist)
      xmax=0.d0
      ikappa=0
      do i=1,M
        dx=c(1)-Dist(1,i)
        dy=c(2)-Dist(2,i)
        dz=c(3)-Dist(3,i)
        Xnorm=dx*dx+dy*dy+dz*dz
          if(Xnorm.gt.xmax) then
            ikappa=i
            xmax=Xnorm
          endif
      enddo
      xmin=1.d12
      iksi=0
      do i=1,nkappa
        ik=Kappa(i)
        dx=c(1)-Dist(1,ik)
        dy=c(2)-Dist(2,ik)
        dz=c(3)-Dist(3,ik)
        Xnorm=dx*dx+dy*dy+dz*dz
          if(Xnorm.lt.xmin) then
            iksi=Kappa(i)
            xmin=Xnorm
          endif
      enddo
      dx=c(1)-Dist(1,ikappa)
      dy=c(2)-Dist(2,ikappa)
      dz=c(3)-Dist(3,ikappa)
      deltp=(dx*dx+dy*dy+dz*dz)/gammak-1.d0
      dx=c(1)-Dist(1,iksi)
      dy=c(2)-Dist(2,iksi)
      dz=c(3)-Dist(3,iksi)
      deltm=1.d0-(dx*dx+dy*dy+dz*dz)/gammak
      deltak=dmax1(deltp,deltm)
      k=0
      Write(IOUT,1001) k,nkappa,deltak,(c(i),i=1,3)
C     Now loop
C     ----------------
      do iter=1,itermax
      if(deltak.le.epsilon) Go to 10
      if(deltak.gt.deltm) then
        alamdak=.5d0*deltak/(1.d0+deltak)
        k=k+1
        blambdak=1.d0-alamdak
          do i=1,M
            u(i)=blambdak*u(i)
            if(i.eq.ikappa) u(i)=u(i)+alamdak
          enddo
          do j=1,3
            c(j)=blambdak*c(j)+alamdak*dist(j,ikappa)
          enddo
        itest=0
        do i=1,nkappa
        if(ikappa.eq.Kappa(i)) itest=1
        enddo
        if(itest.eq.0) then
        nkappa=nkappa+1
        Kappa(nkappa)=ikappa
        endif
      else
        arg1=.5d0*deltm/(1.d0-deltm)
        arg2=u(iksi)/(1.d0-u(iksi))
        alamdak=arg1
        signt=arg2-arg1
        if(signt.lt.0.d0) alamdak=arg2
          if(signt.lt.0.d0.and.nkappa.gt.1) then
            km=1
            isetk=0
            do i=1,nkappa
            imem=Kappa(i)
            if(imem.ne.iksi) then
            Kappa(km)=imem
            km=km+1
            else
            isetk=isetk-1
            endif
            enddo
            nkappa=nkappa+isetk
          endif
        k=k+1
          do i=1,M
            u(i)=(1.d0+alamdak)*u(i)
            if(i.eq.iksi) u(i)=u(i)-alamdak
          enddo
          do j=1,3
            c(j)=(1.d0+alamdak)*c(j)-alamdak*dist(j,iksi)
          enddo
      endif
C     New parameters
      gammak=fpsi(ndim,M,u,dist)
      xmax=0.d0
      ikappa=0
      do i=1,M
        dx=c(1)-Dist(1,i)
        dy=c(2)-Dist(2,i)
        dz=c(3)-Dist(3,i)
        Xnorm=dx*dx+dy*dy+dz*dz
          if(Xnorm.gt.xmax) then
            ikappa=i
            xmax=Xnorm
          endif
      enddo
      xmin=1.d12
      iksi=0
      do i=1,nkappa
        ik=Kappa(i)
        dx=c(1)-Dist(1,ik)
        dy=c(2)-Dist(2,ik)
        dz=c(3)-Dist(3,ik)
        Xnorm=dx*dx+dy*dy+dz*dz
          if(Xnorm.lt.xmin) then
            iksi=ik
            xmin=Xnorm
          endif
      enddo
      dx=c(1)-Dist(1,ikappa)
      dy=c(2)-Dist(2,ikappa)
      dz=c(3)-Dist(3,ikappa)
      deltp=(dx*dx+dy*dy+dz*dz)/gammak-1.d0
      dx=c(1)-Dist(1,iksi)
      dy=c(2)-Dist(2,iksi)
      dz=c(3)-Dist(3,iksi)
      deltm=1.d0-(dx*dx+dy*dy+dz*dz)/gammak
      deltak=dmax1(deltp,deltm)
      enddo
C     ----------------
   10 if(iter.ge.itermax) Write(IOUT,1006) itermax
      Write(IOUT,1005) k,nkappa,deltak,(c(i),i=1,3)
      rmcs=0.d0
      Do i=1,M
      RI=dsqrt((Dist(1,I)-c(1))**2+(Dist(2,I)-c(2))**2
     1 +(Dist(3,I)-c(3))**2)
      if (ri.gt.rmcs) rmcs=ri
      enddo
      dist0=dsqrt(c(1)*c(1)+c(2)*c(2)+c(3)*c(3))
      Write(IOUT,1002) (c(i),i=1,3),dist0
C     Check if there is no point outside the sphere
C     Finally calculate the surface and volume and compare to previous results
      VMCS=4.d0/3.d0*Api*RMCS**3
      AMCS=4.d0*Api*RMCS**2
      RatioMCS=AMCS/VMCS
      RatioCS=ACS/VCS
      RatioT=Atol/Vtol
      RatioV=VMCS/Vtol
      AIPQ=36.d0*API*Vtol**2/Atol**3
      DIPQ=(1.d0-AIPQ)*100.d0
      Write(IOUT,1004) VMCS,VCS,Vtol,AMCS,ACS,Atol,
     1 RatioMCS,RatioCS,RatioT,RatioV,AIPQ,DIPQ
C     Do statistics
      Write(IOUT,1011)
      keq=0
      kgt=0
      klo=0
      rmcsl=-10.d0*epsilon*rmcs
      rmcsu=10.d0*epsilon*rmcs
      Do i=1,M
      RZ=dsqrt((Dist(1,I)-c(1))**2+(Dist(2,I)-c(2))**2
     1 +(Dist(3,I)-c(3))**2)-rmcs
      u(i)=RZ
      if (rz.lt.rmcsl) klo=klo+1
      if (rz.gt.rmcsu) kgt=kgt+1
      if (rz.le.rmcsu.and.rz.ge.rmcsl) then
      keq=keq+1
      RI=dsqrt((Dist(1,I)-c(1))**2+(Dist(2,I)-c(2))**2
     1 +(Dist(3,I)-c(3))**2)
      if(keq.le.4) Write(IOUT,1003) i,(Dist(j,i),j=1,3),RI
      endif
      enddo
      radius=dsqrt((1.d0+deltak)*gammak)
      Write(IOUT,1008) radius
C     Add the carbon Van der Waals radius
      RVdWF=radius+RVdWC
      VVdWF=4.d0/3.d0*Api*RVdWF**3
      VFCC=VVdWF*3.d0*dsqrt(2.d0)/Api
      Write(IOUT,1009) RVdWC,RVdWF,VVdWF
      ALC=2.d0*RVdWF*dsqrt(2.d0)
      Write(IOUT,1010) ALC,VFCC,VFCC*0.60221367d0
C     For each vertex (atom) use the distance to the sphere
C     to calculate the root mean square as a measure for distortion
      rsum=0.d0
      rmax=0.d0
      Do I=1,M
      rsum=rsum+u(i)
      if(u(i).lt.rmax) rmax=u(i)
      enddo
      rmean=rsum/dfloat(M)
      distortion=-rmean/rmin*100.d0
      Write(IOUT,1014) 
      Write(IOUT,1013) (i,u(i),i=1,M)
      Write(IOUT,1007) M,keq,klo,kgt
      Write(IOUT,1012) rmax,rmean,distortion,M
      if(distortion.lt.disteps) then
      Write(IOUT,1015)
      endif
 1001 Format(1x,' Cycle ',I4,', nr. points: ',I4,', convergence: ',
     1 D14.8,', Center of Sphere (X,Y,Z): ',3(D12.6,2X))
 1002 Format(1x,' End of iteration',
     1 /1X,' Center of minimum covering sphere (x,y,z):',3(D14.8,2X),
     2 ' at distance ',D14.8,2X,'from origin')
 1003 Format(1x,' P',I3,'= ',3(D14.8,2X),'  RMCS = ',D14.8)
 1004 Format(/1x,' Final result and comparison (in units of input):',
     1 /1x,' Volume of minimum covering sphere: ',D14.8,
     1 /1x,' Volume of central covering sphere: ',D14.8,
     1 /1x,' Volume of cage molecule          : ',D14.8,
     1 ' (by tesselation)',
     1 /1x,' Area of minimum covering sphere  : ',D14.8,
     1 /1x,' Area of central covering sphere  : ',D14.8,
     1 /1x,' Area of cage molecule            : ',D14.8,
     1 ' (by tesselation)',
     1 /1x,' Ratio area/volume of minimum covering sphere: ',D14.8,
     1 /1x,' Ratio area/volume of central covering sphere: ',D14.8,
     1 /1x,' Ratio area/volume of cage molecule          : ',D14.8,
     1 /1x,' Ratio V(MCS)/V(cage)                        : ',D14.8,
     1 /1x,' Isoperimetric quotient (q_IP=36*PI*V^2/A^3) : ',D14.8,
     1 /1x,' Deformation parameter from q_IP (in %)      : ',D14.8)
 1005 Format(1x,' Number of cycles ',I8,', nr. points: ',I4,
     1 ', convergence: ',F14.8,', Center of Sphere (X,Y,Z): ',
     2 3(D12.6,2X))
 1006 Format(1x,' Maximum number of allowed iterations ',I8,' reached')
 1007 Format(/1x,' Final statistics:',/3X,
     1 ' Number of points: ',I4,/3X,
     2 ' Number of points on the sphere: ',I4,/3X,
     3 ' Number of points below the sphere: ',I4,/3X,
     4 ' Number of points above the sphere: ',I4)
 1008 Format(1x,' Radius of minimum covering sphere: ',D14.8)
 1009 Format(/1x,' Van der Waals radius of carbon: ',D14.8,' Angstroem,'
     1 1x,' Van der Waals radius of fullerene: ',D14.8,
     2 ' Angstroem',/1x,' Van der Waals volume: ',D14.8,
     3 ' Angstroem cube ',' (NB: Input coordinates need ',
     4 'to be in Angstroem)')
 1010 Format(1x,' FCC Lattice constant: ',D14.8,' Angstroem,'
     1 ' FCC volume: ',D14.8,' Angstroem cube,'
     2 ' FCC volume: ',D14.8,' cm3/mol')
 1011 Format(/1x,' Points on sphere (minimum 2, at most 4 points)'
     1 ,' coordinates and distance:')
 1012 Format(/3x,' Largest vertex distance from sphere: ',D12.6,
     1 /3x,' Mean distance from sphere: ',D12.6, 
     1 /3x,' Distortion (in percent) from the MCS relative to the'
     1 '  minimum bond distance: ',D12.6,' for ',I4,' atoms')
 1013 Format(8(1X,'(',I5,')',1X,D10.4))
 1014 Format(/1x,' Atom and distance from sphere:')
 1015 Format(1x,' Atoms lie on a sphere!')
      return
      END

      SUBROUTINE CanSpiral(NMAX,MS0,S,P)
      IMPLICIT Integer (A-Z)
      DIMENSION S(12,NMAX),P(12),PI(12),SM(12,NMAX)
C     Find canonical spiral by sorting
      IS=1
      MS=MS0
         Do I=1,12
         PI(I)=0
         enddo
C     Find lowest value
  1   Smax=100000
          Do I=1,MS
          IF(S(IS,I).le.Smax) Smax=S(IS,I)
          enddo
      IZ=0
          Do I=1,MS
           if(S(IS,I).eq.Smax) then
           IZ=IZ+1
            do j=1,12
            SM(j,IZ)=S(j,I)
            enddo
           endif
           enddo
      MS=IZ
       if(MS.eq.1) then
          Do I=1,12
          P(I)=SM(I,1)
          enddo
          return
       else
         Do I=1,MS
         Do J=1,12
          S(J,I)=SM(J,I)
         enddo
         enddo
       IS=IS+1
       go to 1
      endif
      return
      END

      SUBROUTINE CoordPent(NMAX,MMAX,LMAX,MAtom,IN,Iout,IDA,D,ICart,
     1 A,evec,df,Dist,distp,Rdist)
C Cartesian coordinates produced from ring spiral pentagon list
C cuurently using the Fowler-Manopoulus algorithm to
C identify P-type eigenvectors and construct the 3D fullerene
C Avery : Implement Tutte embedding and sphere projection
      IMPLICIT REAL*8 (A-H,O-Z)
      Integer D,S,RT,Spiral
      DIMENSION D(MMAX,MMAX),S(MMAX),Dist(3,NMAX),distP(NMAX)
      DIMENSION NMR(6),JP(12),A(NMAX,NMAX),IDA(NMAX,NMAX)
      DIMENSION evec(NMAX),df(NMAX),dipol(3,3)
      DIMENSION IDG(NMax)
      DIMENSION Spiral(12,NMAX)
      Character*10 Symbol
      CHARACTER*3 GROUP
      Data Tol,Tol1,Tol2,ftol/1.d-5,.15d0,1.5d1,1.d-10/
C Avery
      nalgorithm=ICart-1
C If nalgorithm=1 use Fowler-Manopoulus algorithm
C If nalgorithm=2 use Tutte algorithm
      M=Matom/2+2
      istop=0
      Group='NA '
C Read pentagon list
      Read(IN,*) Cdist,(JP(I),I=1,12)
      if(Cdist.le.0.d0) then
      Cdist=Rdist
      else
      Rdist=Cdist
      endif
      if(Rdist.gt.0.d0) then
      Cdist=Rdist
      WRITE(Iout,1017) Cdist
      else
      WRITE(Iout,1018) Cdist
      endif
C     Produce the Spiral S using the program WINDUP and UNWIND
      do I=1,MMAX
      do J=1,MMAX
      D(I,J)=0
      enddo
      enddo
      Do I=1,6
      NMR(I)=0
      enddo
      Do I=1,M
      S(I)=6
      enddo
C     Search where the 5-rings are in the spiral
      Do I=1,12
      S(JP(I))=5
      enddo
      IPR=0
      IER=0
      CALL Windup(MMAX,M,IPR,IER,S,D)              ! Wind up spiral into dual
      IF(IER.gt.0) then
      WRITE(Iout,1000) IER
      endif
      IT=1
      Do I=1,12
      Spiral(I,1)=JP(I)
      enddo
      CALL Unwind(NMAX,MMAX,LMAX,M,IER,IT,ispiral,
     1 Spiral,S,D,NMR,Group)                       ! Unwind dual into spirals
      K=0
      DO J=1,6
         IF(NMR(J).EQ.0) GO TO 3
         K=J
      enddo
  3   If(K.le.0) then
      WRITE(Iout,1020) M,Matom,GROUP,(JP(I),I=1,12)
      else
      WRITE(Iout,1001) M,Matom,GROUP,(JP(I),I=1,12),(NMR(J),J=1,K)
      endif
      if(ispiral.ge.2) then
       if(ispiral.eq.2) then
       WRITE(Iout,1023)
       Do II=1,12
       JP(II)=spiral(II,2)
       enddo 
       else
       WRITE(Iout,1019) ispiral-1
       endif
      Do JJ=2,ispiral 
      WRITE(Iout,1021) (spiral(II,JJ),II=1,12)
      enddo
      else
      WRITE(Iout,1022)
      endif
      if(ispiral.gt.2) then
      CALL CanSpiral(NMAX,ispiral,spiral,JP)
      WRITE(Iout,1023)
      WRITE(Iout,1021) (JP(I),I=1,12)
      endif
      Do I=1,M
      S(I)=6
      enddo
      Do I=1,12
      S(JP(I))=5
      enddo
      WRITE(Iout,1024)
      WRITE(Iout,1025) (S(I),I=1,M)
C End of Spiral Program, dual matrix in D(i,j)

C Now produce the Hueckel matrix from the dual matrix
      CALL DUAL(NMAX,D,MMAX,IDA,Matom,IER)
      IF(IER.ne.0) then
      WRITE(Iout,1002) IER
      stop
      endif
      Do I=1,MAtom
      Do J=1,MAtom
      A(I,J)=dfloat(IDA(I,J))
      enddo
      enddo

C Now produce the 3D image
C   Algorithm 1 (Fowler-Manopoulus):
      if(nalgorithm.le.1) then
C     Diagonalize
      call tred2(A,Matom,NMax,evec,df)
      call tqli(evec,df,Matom,NMax,A)
      Write(Iout,1004) Matom,Matom
C     Sort eigenvalues evec(i) and eigenvectors A(*,i)
      Do I=1,MAtom
      e0=evec(I)
      jmax=I
      Do J=I+1,MAtom
      e1=evec(J)
      if(e1.gt.e0) then 
      jmax=j
      e0=e1
      endif
      enddo
      if(i.ne.jmax) then
      ex=evec(jmax)
      evec(jmax)=evec(I)
      evec(I)=ex
      Do k=1,MAtom
      df(k)=A(k,jmax)
      A(k,jmax)=A(k,I)
      A(k,I)=df(k)
      enddo
      endif
      enddo
C     Now sort degeneracies
      df(1)=evec(1)
      ieigv=1
      ideg=1
      IDG(1)=ideg
      Do I=2,MAtom
      diff=dabs(evec(I-1)-evec(I))
      if(diff.lt.Tol) then
      ideg=ideg+1
      IDG(ieigv)=ideg
      else
      ieigv=ieigv+1
      ideg=1
      IDG(ieigv)=ideg
      df(ieigv)=evec(I)
      endif
      enddo
C     Now Print
      ntot=0
      nopen=0
      nflag=0
      iocc=0
      Write(Iout,1003) 
      Do I=1,ieigv
      NE=2*idg(i)
      NE1=NE
      ntot=ntot+NE
      Symbol='(occupied)'
      if(ntot.gt.Matom) then 
      if(nflag.eq.0) then
      nflag=1
      bandgap=df(i-1)-df(i)
      endif
      NE=0
      Symbol='(empty)   '
      endif
      if(ntot.gt.Matom.and.(ntot-NE1).lt.Matom) then 
      NE=Matom-ntot+NE1
      Symbol='(fractocc)'
      nopen=1
      endif
      if(NE.ne.0.and.NE.eq.idg(i)*2) iocc=iocc+idg(i)
      Write(Iout,1005) df(I),idg(i),NE,Symbol
      enddo
      Write(Iout,1006)
      if(nopen.eq.1) then
      Write(Iout,1007)
      else
      Write(Iout,1008) bandgap
      if(bandgap.lt.Tol1) Write(Iout,1009)
      endif
C     Now search for lowest energy P-type vectors
C     This needs to be changed
      icand=0
      Do I=1,iocc
      mneg=0
      mpos=0
      z=0.d0
      Do J=1,MATOM
      if(A(J,I).lt.-1.d-9) mneg=mneg+1
      if(A(J,I).gt.1.d-9) mpos=mpos+1
      enddo
      if(mneg.eq.mpos) then
      icand=icand+1
      idg(icand)=I
      endif
      enddo
C     Analyzing remaining occupied eigenvectors
C     Create cartesian coordinates (in Angstroems) and scale them
C     if required
      I1=idg(1)
      I2=idg(2)
      I3=idg(3)
      IL3=I3
      II1=0
      if(I1.ne.2.or.I2.ne.3.or.I3.ne.4) then
      Write(Iout,1027) I1,I2,I3
      endif
      Read(IN,*,end=99) II1,II2,II3
  99  if(II1.ne.0) then
      I1=II1
      I2=II2
      I3=II3
      Write(Iout,1028) I1,I2,I3
      endif
      Do I=1,MATOM
      Dist(1,I)=A(I,I1)
      Dist(2,I)=A(I,I2)
      Dist(3,I)=A(I,I3)
      enddo
      CALL Distan(NMAX,Matom,IDA,Dist,Rmin,Rminall,Rmax,rms)
      ratiotest=Rminall/Rmax
C     Search for better eigenvectors (not implemented yet)
      if(ratiotest.lt.1.d-6) then
      Write(Iout,1033) ratiotest
      istop=1
      endif
      fac1=1.d0/dsqrt(3.d0-evec(I1))
      fac2=1.d0/dsqrt(3.d0-evec(I2))
      fac3=1.d0/dsqrt(3.d0-evec(I3))
      ratio1=(Rmax/Rmin-1.d0)*1.d2
      Do I=1,MATOM
      Dist(1,I)=A(I,I1)*fac1
      Dist(2,I)=A(I,I2)*fac2
      Dist(3,I)=A(I,I3)*fac3
      enddo
      CALL Distan(NMAX,Matom,IDA,Dist,Rmin,Rminall,Rmax,rms)
      ratio=(Rmax/Rmin-1.d0)*1.d2
      if(ratio1.lt.ratio) then
      Write(Iout,1026)
      Do I=1,MATOM
      Dist(1,I)=A(I,I1)/fac1
      Dist(2,I)=A(I,I2)/fac2
      Dist(3,I)=A(I,I3)/fac3
      enddo
      fac1=1.d0
      fac2=1.d0
      fac3=1.d0
      CALL Distan(NMAX,Matom,IDA,Dist,Rmin,Rminall,Rmax,rms)
      endif

C     Obtain smallest distance for further scaling
C     Now this contracts or expandes the whole fullerene to set the
C     smallest bond distance to Cdist
      R0=1.d10
      Do I=1,MATOM
      Do J=I+1,MATOM
      X=Dist(1,I)-Dist(1,J)
      Y=Dist(2,I)-Dist(2,J)
      Z=Dist(3,I)-Dist(3,J)
      R=dsqrt(X*X+Y*Y+Z*Z)
      if(R.lt.R0) R0=R
      enddo
      enddo
      fac=CDist/R0
      Write(Iout,1010) icand,I1,I2,I3,fac1,fac2,fac3,fac,Cdist
      Do k=1,2*IL3
      ICN=0
      ICP=0
      do kk=1,Matom
      if(A(kk,k).gt.0.d0) ICP=ICP+1
      if(A(kk,k).lt.0.d0) ICN=ICN+1
      enddo
      Write(Iout,1011) k,evec(k),ICN,ICP
      Write(Iout,1012) (A(J,k),J=1,Matom)
      enddo
      if(R0.lt.1.d-5.or.istop.eq.1) then
      Write(IOUT,1032) R0,fac
      stop
      endif
      Do I=1,MATOM
      Dist(1,I)=Dist(1,I)*fac
      Dist(2,I)=Dist(2,I)*fac
      Dist(3,I)=Dist(3,I)*fac
      enddo
C     Check distances
      Write(IOUT,1013)     
      Do J=1,MAtom
      Write(IOUT,1014) J,(Dist(I,J),I=1,3)
      enddo
      CALL Distan(NMAX,Matom,IDA,Dist,Rmin,Rminall,Rmax,rms)
      Write(IOUT,1015) Rmin,Rmax,rms
      ratio=(Rmax/Rmin-1.d0)*1.d2
      iratio=dint(ratio)
      CALL Diameter(NMax,MAtom,IOUT,Dist,distp)
      if(iratio.lt.33) then
      Write(IOUT,1016) iratio
      else
      Write(IOUT,1029) iratio
      endif
C     Calculate P-type dipole moment
       Call Dipole(NMax,MAtom,I1,I2,I3,IOUT,dipol,Dist,A)
       Write(IOUT,1030)
       Do I=1,3
        Write(IOUT,1031) I,(dipol(I,J),J=1,3)
       enddo

      else
C   Avery 
C   Algorithm 2 (Tutte):
C     Here goes your part, the adjacency matrix is in IDA(i,j)
C     in integers (0 or 1), I guess this is all you need
C     Input: Integer Adjacency Matrix IDA(NMax,NMax)
C     Output: Real*8 Cartesian Coordinates  Dist(3,NMax)
C     NMax: Max Dimension of Matrix
C     MAtom: Working Dimension of Matrix

C      CALL Avery (NMax,MAtom,IDA,Dist)

C     Obtain smallest distance for further scaling
C     Now this contracts or expandes the whole fullerene to set the
C     smallest bond distance to Cdist
      R0=1.d10
      Do I=1,MATOM
      Do J=I+1,MATOM
      X=Dist(1,I)-Dist(1,J)
      Y=Dist(2,I)-Dist(2,J)
      Z=Dist(3,I)-Dist(3,J)
      R=dsqrt(X*X+Y*Y+Z*Z)
      if(R.lt.R0) R0=R
      enddo
      enddo
      fac=CDist/R0
      Do I=1,MATOM
      Dist(1,I)=Dist(1,I)*fac
      Dist(2,I)=Dist(2,I)*fac
      Dist(3,I)=Dist(3,I)*fac
      enddo
C     Check distances
      Write(IOUT,1034) fac     
      Do J=1,MAtom
      Write(IOUT,1014) J,(Dist(I,J),I=1,3)
      enddo
      CALL Distan(NMAX,Matom,IDA,Dist,Rmin,Rminall,Rmax,rms)
      Write(IOUT,1015) Rmin,Rmax,rms
      ratio=(Rmax/Rmin-1.d0)*1.d2
      iratio=dint(ratio)
      CALL Diameter(NMax,MAtom,IOUT,Dist,distp)
      if(iratio.lt.33) then
      Write(IOUT,1016) iratio
      else
      Write(IOUT,1029) iratio
      endif

      endif

 1000 FORMAT(/1X,'Cannot produce dual matrix, error IER= ',I2,
     1 ' Check your input for pentagon locations')
 1001 FORMAT(/1X,'Program to create cartesian coordinates through ',
     1 'pentagon index list producing the dual matrix and finally '
     1 'the Hueckel matrix',/1X,'Number of faces: ',I3,
     1 ', Number of atoms (vertices): ',I4,
     1 ', Point group of fullerene (in ideal symmetry): ',A3,/1X,
     1 'Ring spiral pentagon positions: ',12I4,
     1 /1X,'NMR pattern: ',3(I3,' x',I3,:,','))
 1002 FORMAT(/1X,'D contains IER = ',I6,' separating triangles and is ',
     1 'therefore NOT a fullerene dual')
 1003 FORMAT(1X,'       x     deg NE   type    ',/1X,32('-'))
 1004 FORMAT(/1X,'Construct the (',I3,','I3,') Hueckel matrix, '
     1 'diagonalize (E=alpha+x*beta) and get eigenvectors',
     1 /1X,'Eigenvalues are between [-3,+3]')
 1005 FORMAT(1X,F12.6,I3,1X,I3,3X,A10)
 1006 FORMAT(1X,32('-'))
 1007 FORMAT(1X,'Fullerene has open-shell character (zero band gap)!')
 1008 FORMAT(1X,'Bandgap delta x = ',F12.6,' (in units of |beta|)')
 1009 FORMAT(1X,'Caution: Bandgap small, possibility '
     1 'for open-shell character')
 1010 FORMAT(1X,I3,' potential candidates in occupied space discovered',
     1 ' for odd symmetry eigenvectors, take the lowest energy ones: ',
     1 3I4,/1X,'Create cartesian coordinates and scale a la Fowler ',
     1 /1X,'Scaling factors sx =',D12.6,', sy =',D12.6,', sz =',D12.6,
     1 ', and final scaling factor of ',D16.8,' setting Rmin= ',F12.6,
     1 /1X,'P-type eigenvalues and eigenvectors (path search not yet ',
     1 'implemented and cartesian coordinates may not be correct)',/1X,
     1 'Note: Procedure may give bond lengths which may vary strongly')
 1011 FORMAT(1X,'eigenvalue',I4,': ',F12.6,', eigenvector: (',I3,
     1 ' negative and ',I3,' positive values)')
 1012 FORMAT(10(1X,F12.6))
 1013 FORMAT(1X,'Fowler-Manopoulus Coordinates')
 1014 FORMAT(1X,I3,5X,3(D18.12,2X))
 1015 FORMAT(1X,'Minimum distance: ',F12.6,', Maximum distance: ',F12.6,
     1 ', RMS distance: ',F12.6)
 1016 Format(1X,'Maximum bond distance ',I5,'% larger than minimum ',
     1 'distance')
 1017 Format(1X,'Minimum bond distance set to input value: ',F12.6)
 1018 Format(1X,'Minimum bond distance set to default value ',
     1 'taken from C60 bond distance: ',F12.6)
 1019 Format(1X,'Spiral list of pentagon positions with ',
     1 'higher priority: (',I3,' spirals found)') 
 1020 FORMAT(/1X,'Program to create cartesian coordinates through ',
     1 'pentagon index list producing the dual matrix and finally '
     1 'the Hueckel matrix',/1X,'Number of faces: ',I3,
     1 ', Number of atoms (vertices): ',I4,
     1 ', Point group of fullerene (in ideal symmetry): ',A3,/1X,
     1 'Ring spiral pentagon positions: ',12I4)
 1021 Format(12(1X,I3))
 1022 Format(1X,'Input spiral is canonical')
 1023 Format(1X,'Canonical spiral list of pentagon positions:')
 1024 Format(1X,'Canonical spiral list of hexagons and pentagons:')
 1025 Format(1X,100I1)
 1026 Format(1X,'No Fowler scaling')
 1027 Format(1X,'Analysis of ',3I3,' eigenvectors finds P-type ',
     1 'eigenvectors not in sequence 2 3 4',
     1 /,' You might analyze eigenvectors and read in numbers for '
     1 'eigenvectors to be used to construct coordinates instead')
 1028 Format(1X,'Take ',3I3,' eigenvectors as required by input')
 1029 Format(1X,'Maximum bond distance ',I5,'% larger than minimum ',
     1 'distance. Fullerene strongly distorted!',/1X,
     1 'Optimization of geometry recommended')
 1030 Format(1X,'P-type dipole moments as indicators:')
 1031 Format(1X,I1,2X,'(',F9.2,',',F9.2,',',F9.2,')')
 1032 Format(1X,'Very small bond distance of ',D18.12,' found',
     1 ' leading to a unreasonable scaling factor of ',D18.12,
     1 /1X,'**** Program stops (choose other set of eigenvectors)')
 1033 Format(1X,'Rmin/Rmax ratio too small: ',D18.12,
     1 /1X,'Program will stop (choose other set of eigenvectors)')
 1034 FORMAT(1X,'Coordinates from Tutte embedding scaled by a factor'
     1 'of ',D18.12)
      Return 
      END

      SUBROUTINE Dipole(NMax,MAtom,I1,I2,I3,IOUT,dipol,Dist,A)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION Dist(3,NMAX),A(NMAX,NMAX),dipol(3,3)
      tol=1.d-7
      do I=1,3
      do j=1,3
      dipol(I,J)=0.d0
      enddo
      enddo
      do I=1,MAtom
      do j=1,3
      dipol(1,j)=dipol(1,j)+Dist(j,I)*A(I,I1)
      dipol(2,j)=dipol(2,j)+Dist(j,I)*A(I,I2)
      dipol(3,j)=dipol(3,j)+Dist(j,I)*A(I,I3)
      enddo
      enddo
      do i=1,3
      do j=1,3
      if(dabs(dipol(i,j)).lt.tol) dipol(i,j)=0.d0
      enddo
      enddo
      Return 
      END

      SUBROUTINE OptFF(NMAX,MMAX,MAtom,Iout,IDA,N5,N6,
     1 N5MEM,N6MEM,Dist,Rdist)
      IMPLICIT REAL*8 (A-H,O-Z)
C  This subroutine optimizes the fullerene using the Wu force field:
C   Z. C. Wu, D. A. Jelski, T. F. George, "Vibrational Motions of
C   Buckminsterfullerene", Chem. Phys. Lett. 137, 291-295 (1987).
C   Original force field in forceWu
C   Angstroem and rad is used for bond distances and bond length
C   Data from Table 1 of Wu in dyn/cm = 10**-3 N/m
      DIMENSION Dist(3,NMAX)
      DIMENSION IDA(NMAX,NMAX)
      DIMENSION N5MEM(MMAX,5),N6MEM(MMAX,6),force(8),forceWu(8)
      Data forceWu/1.455d0,1.391d0,108.d0,120.d0,1.d6,1.1d6,1.d5,1.d5/
      Data ftol,dpi,conv/1.d-6,3.14159265358979d0,6.0221367d-3/
      force(1)=forceWu(1)
      force(2)=forceWu(2)
C     Conversion of angles in rad
      conrad=dpi/180.d0
      force(3)=forceWu(3)*conrad
      force(4)=forceWu(4)*conrad
C     Conversion of dyn/cm in a.u. / Angstroem**2
      force(5)=.5d0*forceWu(5)*conv*3.80879844d-4
      force(6)=.5d0*forceWu(6)*conv*3.80879844d-4
      force(7)=.5d0*forceWu(7)*conv*3.80879844d-4
      force(8)=.5d0*forceWu(8)*conv*3.80879844d-4
      M=Matom/2+2
C     Optimize
      Write(IOUT,1000) Rdist
      NMAX3=3*NMAX
      MATOM3=3*MATOM
      CALL frprmn(NMAX,NMAX3,MATOM3,MMAX,IDA,Iout,N5,N6,N5MEM,N6MEM,
     1 Dist,force,ftol,iter,fret)
      if(fret.gt.1.d-2) then
      fretn=fret/dfloat(MATOM)
      Write(IOUT,1002) fretn
      endif
      CALL Distan(NMAX,Matom,IDA,Dist,Rmin,Rminall,Rmax,rms)
      fac=RDist/Rmin
      Do I=1,MATOM
      Dist(1,I)=Dist(1,I)*fac
      Dist(2,I)=Dist(2,I)*fac
      Dist(3,I)=Dist(3,I)*fac
      enddo
      CALL Distan(NMAX,Matom,IDA,Dist,Rmin,Rminall,Rmax,rms)
      Write(IOUT,1001) Rmin,Rmax,rms
 1000 Format(1X,'Optimization of geometry using harmonic oscillators',
     1 ' for stretching and bending modes using the force-field of ',
     1 ' Wu et al.',/1X,'Fletcher-Reeves-Polak-Ribiere algorithm used',
     1 /1X,'Smallest bond distance set to ',F12.6)
 1001 FORMAT(1X,'Minimum distance: ',F12.6,', Maximum distance: ',F12.6,
     1 ', RMS distance: ',F12.6)
 1002 FORMAT(1X,'Distances and angles defined in the force field can',
     1 ' not be reached',/1X,'Energy per atom in atomic units: ',F12.6)
      Return 
      END

      SUBROUTINE Distan(NMAX,Matom,IDA,Dist,Rmin,Rminall,Rmax,rms)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION Dist(3,NMAX)
      DIMENSION IDA(NMAX,NMAX)
C     Calculate minimal, maximal and root mean square distances
C     from adjacancy matrix IDA and cartesian coordinates Dist
      Rmin=1.d10
      Rminall=1.d10
      Rmax=0.d0
      Rrms=0.d0
      mc=0
      Do I=1,Matom
      Do J=I+1,Matom
      X=Dist(1,I)-Dist(1,J)
      Y=Dist(2,I)-Dist(2,J)
      Z=Dist(3,I)-Dist(3,J)
      R2=X*X+Y*Y+Z*Z
      R=dsqrt(R2)
      mc=mc+1
      if(R.lt.Rminall) Rminall=R
      if(IDA(I,J).ne.0) then
      if(R.lt.Rmin) Rmin=R
      if(R.gt.Rmax) Rmax=R
      Rrms=Rrms+R2
      endif
      enddo
      enddo
      if(Rmax.eq.0.d0.or.Rmin.eq.1.d10) then
      Print*,'**** Error in subroutine Distan'
      stop
      endif
      rms=dsqrt(Rrms/dfloat(mc))
      Return 
      END

      SUBROUTINE CoordC60(natom,IN,Iout,IAtom,Dist)
      IMPLICIT REAL*8 (A-H,O-Z)
C     This routine constructs coordinates for the ideal capped icosahedron
C     as described by P. Senn, J. Chem. Ed. 72, 302 (1995)
      DIMENSION IATOM(natom),NUM(30),NUN(30)
      DIMENSION Dist(3,natom)
      DIMENSION DIco(3,12)
      Data NUM/1,1,1,1,1,2,2,2,2,3,3,3,4,4,4,5,5,5,
     1   6,6,6,7,7,7,8,8,8,9,9,10/
      Data NUN/2,3,9,10,11,3,4,10,12,4,5,11,5,6,12,
     1   6,7,11,7,8,12,8,9,11,9,10,12,10,11,12/
      DATA API/3.14159265358979d0/
      Read(IN,*) R5,R6
      Write(Iout,1000) R5,R6
      DIF1=R5-R6
      Dif=Dabs(DIF1)
      If(Dif.lt.1.D-9) Write(Iout,1001)
C     Calculate the 12 coordinates of icosahedron
      dsqrt5=dsqrt(5.d0)
      AKSI=R5+.5d0*R6
      Rmax=AKSI*dsqrt((5.d0+dsqrt5)*.5d0)
      Rcov=.5d0*dsqrt(2.d0*(3.d0+dsqrt5)*AKSI**2+R6**2)
      Write(Iout,1002) Rmax,Rcov
      Fac1=Rmax/dsqrt5
      Do I=1,10
C     Angle multiple of 36 deg, or Pi/10., multiplied by 2
      ang=.2d0*dfloat(I)*API
      fcos=dcos(ang)
      fsin=dsin(ang)
      DIco(1,I)=2.d0*Fac1*fcos
      DIco(2,I)=2.d0*Fac1*fsin
      DIco(3,I)=Fac1*(-1.d0)**I
      enddo
      DIco(1,11)=0.d0
      DIco(1,12)=0.d0
      DIco(2,11)=0.d0
      DIco(2,12)=0.d0
      DIco(3,11)=-RMAX
      DIco(3,12)=RMAX
      Write(Iout,1003)
      Do I=1,12
      Write(Iout,1004) (DIco(J,I),J=1,3)
      enddo
C     Construct vertices of capped icosahedron
      fac2=R5/(2.d0*R5+R6)
C     Now calculated the coordinates
      ILoop=1
      Do I=1,30
      I1=NUM(I)
      I2=NUN(I)
      Do J=1,3
      Val1=DIco(J,I1)+fac2*(DIco(J,I2)-DIco(J,I1))
      Dist(J,ILoop)=Val1
      Val2=DIco(J,I2)+fac2*(DIco(J,I1)-DIco(J,I2))
      Dist(J,ILoop+1)=Val2
      enddo
      ILoop=ILoop+2
      enddo
 1000 Format(/1X,' Construct coordinates for 60-Fullerene',
     1 /1X,' Distances: R5= ',D12.6,'  R6= ',D12.6)
 1001 Format(/1X,' Identical distances chosen')
 1002 Format(/1X,' Radius of icosahedron (not capped): ',D12.6,
     1 ' Radius of covering central sphere for capped icosahedron: ',
     2 D12.6)
 1003 FORMAT(/1X,'Coordinates of Icosaeder:',/7X,
     1 'X',12X,'Y',12X,'Z')
 1004 Format(1X,3(D12.6,1X))
      Return
      END 

      SUBROUTINE Volume(NAtom,Nfaces,NAtom2,Matom,Iout,N5MEM,N6MEM,
     1 N5Ring,N6Ring,DIST,CRing5,CRing6,VolSphere,Asphere,
     2 Atol,VTol,Rmin5,Rmin6,Rmax5,Rmax6)
      IMPLICIT REAL*8 (A-H,O-Z)
C     Calculate the volume (and surface) of the cage molecule by summing over
C     all trigonal pyramids (areas) defined by the vectors
C     CM-CR  (center of cage to the center of ring)
C     CM-CA1 (center of cage to atom 1 in ring)
C     CM-CA2 (center of cage to atom 2 in ring)
C     There are 5 such trigonal pyramids in a 5-ring and 6 in a 6-ring
C     Note that CM is already in the origin
C     Let CR=(X1,Y1,Z1) , CA1=(X2,Y2,Z2) , and CA2(X3,Y3,Z3)
C     Then the volume V for a irregular trigonal pyramid is given by 
C       the determinant
C
C                                 | X1 Y1 Z1 |
C     V = abs(Vdet)  ,   V =  1/6 | X2 Y2 Z2 |
C                                 | X3 Y3 Z3 |
C
      DIMENSION Dist(3,natom),Distac(6)
      DIMENSION CRing5(3,Nfaces),CRing6(3,Nfaces)
      DIMENSION N5MEM(Nfaces,5),N6MEM(Nfaces,6)
C     Sum over all 5-rings
      Vol5=0.d0
      Area5=0.d0
      ITH=0
      DO I=1,N5Ring
      DO J=1,5
      IAT1=N5MEM(I,J)
      J1=J+1
      IF(J1.eq.6) J1=1
      IAT2=N5MEM(I,J1)
      VolTes=VolTP(CRing5(1,I),CRing5(2,I),CRing5(3,I),
     1 Dist(1,IAT1),Dist(2,IAT1),Dist(3,IAT1),
     1 Dist(1,IAT2),Dist(2,IAT2),Dist(3,IAT2))
      AreaTes=AreaTP(CRing5(1,I),CRing5(2,I),CRing5(3,I),
     1 Dist(1,IAT1),Dist(2,IAT1),Dist(3,IAT1),
     1 Dist(1,IAT2),Dist(2,IAT2),Dist(3,IAT2))
      Vol5=Vol5+VolTes
      Area5=Area5+AreaTes
      ITH=ITH+1
      enddo
      enddo
      Vol5=Vol5/6.d0
      Area5=Area5/2.d0
C     Sum over all 6-rings
      Area6=0.d0
      Vol6=0.d0
      If(N6Ring.eq.0) Go to 10
      DO I=1,N6Ring
      DO J=1,6
      IAT1=N6MEM(I,J)
      J1=J+1
      IF(J1.eq.7) J1=1
      IAT2=N6MEM(I,J1)
      VolTes=VolTP(CRing6(1,I),CRing6(2,I),CRing6(3,I),
     1 Dist(1,IAT1),Dist(2,IAT1),Dist(3,IAT1),
     1 Dist(1,IAT2),Dist(2,IAT2),Dist(3,IAT2))
      AreaTes=AreaTP(CRing6(1,I),CRing6(2,I),CRing6(3,I),
     1 Dist(1,IAT1),Dist(2,IAT1),Dist(3,IAT1),
     1 Dist(1,IAT2),Dist(2,IAT2),Dist(3,IAT2))
      Vol6=Vol6+VolTes
      Area6=Area6+AreaTes
      ITH=ITH+1
      enddo
      enddo
      Vol6=Vol6/6.d0
      Area6=Area6/2.d0
C     Now do the total volume calculation
  10  VTol=Vol5+Vol6
      ATol=Area5+Area6
      DVSphere=VTol-VolSphere
      VPC=DVSphere/VolSphere*1.d2
      DVArea=ATol-Asphere
      APC=DVArea/Asphere*1.d2
C     Calculate the volume and area for C60 using R5 and R6
      If(Matom.eq.60) then
      R5=(Rmin5+Rmax5)*.5d0
      R5div=dabs(Rmin5-Rmax5)
      R6div1=dabs(R5-Rmin6)
      R6div2=dabs(R5-Rmax6)
      R6=Rmin6
      if(R6div2.gt.R6div1) R6=Rmax6
      sqrt5=dsqrt(5.d0)
      Volico=(5.d0/12.d0)*(3.d0+sqrt5)*(R5+R5+R6)**3
      Volpenta=.5d0*(5.d0+sqrt5)*(R5)**3
      VolIcocap=Volico-Volpenta
      DVIcocap=VTol-VolIcocap
      fac1=dsqrt(sqrt5*10.d0+25.d0)*3.d0
      fac2=5.d0*dsqrt(3.d0)
      r5s=R5**2
      AreaIcocap=fac1*r5s+fac2*(R6**2+r5s+4.d0*R5*R6)
      Write(Iout,1002) VolIco,VolIcocap,AreaIcocap,R5,R6
      If(R5div.gt.1.d-5) Write(Iout,1003) R5div,R5
      endif
      If(Matom.eq.20) then
      R5=(Rmin5+Rmax5)*.5d0
      R5div=dabs(Rmin5-Rmax5)
      sqrt5=dsqrt(5.d0)
      Voldode=.25d0*(15.d0+7.d0*sqrt5)*R5**3
      Areadode=dsqrt(sqrt5*10.d0+25.d0)*3.d0*R5**2
      Write(Iout,1005) Voldode,Areadode,R5
      If(R5div.gt.1.d-5) Write(Iout,1003) R5div,R5
      endif
      Write(Iout,1000) VTol,Vol5,Vol6,ITH,DVSphere,VPC
      If(Matom.eq.60) Write(Iout,1004) DVIcocap
      Write(Iout,1001) ATol,Area5,Area6,Atol/VTol,DVArea,APC
 1000 Format(/1X,'Final result:',/1X,
     1 'Total calculated volume of cage molecule through tesselation: ',
     1 D14.8,' (Contributions from 5-ring: ',D14.8,
     1 ' , and from 6-ring: ',D14.8,')'
     1 /3X,' using ',I4,' trigonal pyramidal tessellations',/1X,
     1 ' Deviation from spherical central covering: ',D12.6,1X,
     1 ' in percent: ',D12.6)
 1001 Format(/1X,'Total calculated area of cage molecule: ',D14.8,
     1 ' (Contributions from 5-ring: ',D14.8,
     1 ' , and from 6-ring: ',D14.8,')',/1X,
     1 ' Ratio Area/Volume total: ',D12.6,/1X,
     1 ' Deviation from spherical central covering: ',D12.6,1X,
     1 ' in percent: ',D12.6,/1X)
 1002 Format(/1X,' Volume of the original icosahedron: ',D14.8,
     1 ' and volume and area of the capped icosahedron: V= ',D14.8,1X,
     1 ', A= ',D14.8,/1X,' Distances taken: R5= ',D12.6,', R6= ',D12.6)
 1003 Format(1X,' Warning: Distances in 5-ring not the same, ',
     1 ' difference is ',D12.6,
     1 ', taking the average distance of ',D12.6)
 1004 Format(1X,' Deviation from capped Ih icosahedron: ',D12.6)
 1005 Format(/1X,' Volume and area of the dodecahedron: V= ',D14.8,1X,
     1 ', A= ',D14.8,/1X,' Distance taken: R5= ',D12.6)
      Return
      END 

      FUNCTION FunDistMat(I,J,natomL,DistMat)
C     Unpack distance matrix value from linear vector
      IMPLICIT REAL*8 (A-H,O-Z)
      Dimension DistMat(natomL)
      I1=I
      J1=J
      IF(I.lt.J) then
      I1=J
      J1=I
      endif
      IMat=((I1-1)*(I1-2))/2+J1
      FunDistMat=DistMat(IMat)
      Return
      END 

      FUNCTION VolTP(X1,Y1,Z1,X2,Y2,Z2,X3,Y3,Z3)
C     Volume of trigonal pyramid enclosed between three vectors from origin
      IMPLICIT REAL*8 (A-H,O-Z)
      AMat=X1*Y2*Z3+Y1*Z2*X3+Z1*X2*Y3-Z1*Y2*X3-Y1*X2*Z3-X1*Z2*Y3
      VolTP=dabs(AMat)
      Return
      END
 
      FUNCTION AreaTP(X1,Y1,Z1,X2,Y2,Z2,X3,Y3,Z3)
C     Area of triangle at end of three vectors from origin
      IMPLICIT REAL*8 (A-H,O-Z)
      C1=Y1*Z2+Y2*Z3+Y3*Z1-Z1*Y2-Z2*Y3-Z3*Y1
      C2=Z1*X2+Z2*X3+Z3*X1-X1*Z2-X2*Z3-X3*Z1
      C3=X1*Y2+X2*Y3+X3*Y1-Y1*X2-Y2*X3-Y3*X1
      ATP=C1*C1+C2*C2+C3*C3
      AreaTP=dsqrt(ATP)
      Return
      END
 
      SUBROUTINE RingC(NAtom,Nfaces,Nedges,NAtom2,Matom,nat11,Iout,
     1 iprint,N5MEM,N6MEM,N5Ring,N6Ring,Nring,Iring5,Iring6,Iring56,
     1 NringA,NringB,NringC,NringD,NringE,NringF,DIST,CRing5,CRing6)
      IMPLICIT REAL*8 (A-H,O-Z)
C     Determine the center of each 5-and 6-ring system
      DIMENSION Dist(3,natom),Distac(6)
      DIMENSION CRing5(3,Nfaces),CRing6(3,Nfaces)
      DIMENSION N5MEM(Nfaces,5),N6MEM(Nfaces,6),Nring(Nfaces)
      DIMENSION IedgeA(Nedges),IedgeB(Nedges)
      DIMENSION IedgeC(Nedges),IedgeD(Nedges)
      DIMENSION IedgeE(Nedges),IedgeF(Nedges)
      DIMENSION NringA(Nedges),NringB(Nedges)
      DIMENSION NringC(Nedges),NringD(Nedges)
      DIMENSION NringE(Nedges),NringF(Nedges)
      Integer n3r(3,nat11),n3ra(3,natom),n3rb(3,natom)
      Integer IRhag5(0:5),IRhag6(0:6)
      Character*6,Label
C     Center for 5-rings
      Write(Iout,1000)
      Do I=1,N5Ring
      Nring(I)=I
      Sum5x=0.
      Sum5y=0.
      Sum5z=0.
      Do J=1,5
      IAt=N5MEM(I,J)
      Sum5x=Sum5x+Dist(1,IAt)
      Sum5y=Sum5y+Dist(2,IAt)
      Sum5z=Sum5z+Dist(3,IAt)
      enddo
      CRing5(1,I)=Sum5x*.2d0
      CRing5(2,I)=Sum5y*.2d0
      CRing5(3,I)=Sum5z*.2d0
C     Calculate distance of atoms from the center
      Do J=1,5
      IAt=N5MEM(I,J)
      X1=CRing5(1,I)-Dist(1,IAt)
      Y1=CRing5(2,I)-Dist(2,IAt)
      Z1=CRing5(3,I)-Dist(3,IAt)
      Distac(J)=dsqrt(X1*X1+Y1*Y1+Z1*Z1)
      enddo
      Write(Iout,1002)Nring(I),(N5MEM(I,JT),JT=1,5),
     1 (CRing5(JT1,I),JT1=1,3),(Distac(JT),JT=1,5)
      enddo
C     Center for 6-rings
      If(N6Ring.eq.0) Go to 2000
      Write(Iout,1001)
      Do I=1,N6Ring
      NRing(N5Ring+I)=N5Ring+I
      Sum6x=0.
      Sum6y=0.
      Sum6z=0.
      Do J=1,6
      IAt=N6MEM(I,J)
      Sum6x=Sum6x+Dist(1,IAt)
      Sum6y=Sum6y+Dist(2,IAt)
      Sum6z=Sum6z+Dist(3,IAt)
      enddo
      CRing6(1,I)=Sum6x/6.d0
      CRing6(2,I)=Sum6y/6.d0
      CRing6(3,I)=Sum6z/6.d0
C     Calculate distance of atoms from the center
      Do J=1,6
      IAt=N6MEM(I,J)
      X1=CRing6(1,I)-Dist(1,IAt)
      Y1=CRing6(2,I)-Dist(2,IAt)
      Z1=CRing6(3,I)-Dist(3,IAt)
      Distac(J)=dsqrt(X1*X1+Y1*Y1+Z1*Z1)
      enddo
      Write(Iout,1003)Nring(N5Ring+I),(N6MEM(I,JT),JT=1,6),
     1 (CRing6(JT1,I),JT1=1,3),(Distac(JT),JT=1,6)
      enddo

C     Analyzing the ring fusions
C     All 2-ring fusions
 2000 Write(Iout,1004)
      IR1=5
      IR2=5
      N2ring=0
      IRing5=0
      IRing6=0
      IRing56=0
C     (5-5) 2-ring fusions
      CALL Ring55(natom,Nfaces,Nedges,IRing5,N5Ring,NringA,NringB,Nring,
     1 N5MEM,IedgeA,IedgeB)
      Write(Iout,1005) IR1,IR2,IRing5
      if(IRing5.ne.0) Write(Iout,1006) (NringA(I),NringB(I),I=1,IRing5)
      N2ring=IRing5
      If(N6Ring.eq.0) Go to 3000

C     (5-6) 2-ring fusions
      IR2=6
      CALL Ring56(natom,Nfaces,Nedges,IRing56,N5Ring,N6Ring,
     1 NringC,NringD,Nring,N5MEM,N6MEM)
      Write(Iout,1005) IR1,IR2,IRing56
      if(IRing56.ne.0) Write(Iout,1006)(NringC(I),NringD(I),I=1,IRing56)
      N2ring=N2ring+IRing56

C     (6-6) 2-ring fusions
      IR1=6
      CALL Ring66(natom,Nfaces,Nedges,IRing6,N5Ring,N6Ring,NringE,
     1 NringF,Nring,N6MEM)
      Write(Iout,1005) IR1,IR2,IRing6
      if(IRing6.ne.0) Write(Iout,1006) (NringE(I),NringF(I),I=1,IRing6)
      N2ring=N2ring+IRing6

C     Final 2-ring
 3000 Write(Iout,1007) N2ring

C     Get Rhagavachari-Fowler-Manolopoulos neighboring pentagon and hexagon indices
C     First pentagon indices
      Do I=0,5
       IRhag5(I)=0
      enddo
      If(IRing5.eq.0) then
       IRhag5(0)=12
       go to 111
      endif
      do I=1,12
       IRcount=0
       do J=1,IRing5
        If(NRingA(J).eq.I.or.NRingB(J).eq.I) then
         IRcount=IRcount+1
        endif
       enddo
       IRhag5(IRcount)=IRhag5(IRcount)+1
      enddo
C     Pentagon index
  111 Ifus5=0
      Do I=1,5
      IFus5=IFus5+I*IRhag5(I)
      enddo
      IFus5G=IFus5/2
      Write(Iout,1013) (IRhag5(I),I=0,5),IFus5G
      If(IFus5G.eq.IRing5) then
      Write(Iout,1015) IFus5G
      else
      Write(Iout,1016) IFus5G
      endif
C     Now hexagon indices
      if(N6Ring.eq.0) go to 113
      Do I=0,6
      IRhag6(I)=0
      enddo
      ihk=0
      If(IRing6.eq.0) then
      IRhag6(0)=N6Ring
      go to 112
      endif
      do I=13,12+N6Ring
      IRcount=0
      do J=1,IRing6
      If(NRingE(J).eq.I.or.NRingF(J).eq.I) then
      IRcount=IRcount+1
      endif
      enddo
      IRhag6(IRcount)=IRhag6(IRcount)+1
      enddo
C     Strain Parameter
      khk=0
      k2hk=0
      Do I=3,6
      ihk=ihk+IRhag6(I)
      IIR=I*IRhag6(I)
      khk=khk+IIR
      k2hk=k2hk+I*IIR
      enddo
      aihk=dfloat(ihk)
      akhk2=(dfloat(khk)/aihk)**2
      ak2hk=dfloat(k2hk)/aihk
      sigmah=dsqrt(dabs(ak2hk-akhk2))
  112 Write(Iout,1020) (IRhag6(I),I=0,6),sigmah
      Ifus6=0
      Do I=3,6
      IFus6=IFus6+IRhag6(I)
      enddo
      IFus6G=IFus6*2+20
      If(IFus6G.eq.Matom) then
      Write(Iout,1018) IFus6G
      else
      Write(Iout,1019) IFus6G
      endif

C     All 3-ring fusions
  113 Write(Iout,1014) 
C     (c5-5-5) 3-ring fusions
      Label='closed'
      IR1=5
      IR2=5
      IR3=5
      N3Ring=0
      KRing3=0
      LRing3=0
      if(IRing5.gt.0) CALL Ring555(natom,nfaces,Nedges,nat11,Iout,
     1 IRing5,NringA,NringB,KRing3,LRing3,n3r,n3ra,n3rb)
      Write(Iout,1008) Label,IR1,IR2,IR3,LRing3
      if(Lring3.ne.0.and.iprint.eq.1) 
     1 write(Iout,1011) ((n3rb(J,I),J=1,3),i=1,Lring3)
      N3Ring=N3Ring+LRing3

C     (o5-5-5) 3-ring fusions
      Label='open  '
      Write(Iout,1008) Label,IR1,IR2,IR3,KRing3
      if(Kring3.ne.0.and.iprint.eq.1) 
     1 write(Iout,1011) ((n3ra(J,I),J=1,3),i=1,Kring3)
      N3Ring=N3Ring+KRing3
      If(N6Ring.eq.0) Go to 4000

C     (c5-5-6) 3-ring fusions with (5-5)
      KRing3=0
      LRing3=0
      if(IRing5.gt.0.and.IRing56.gt.0) then
      CALL Ring556(natom,nfaces,Nedges,nat11,Iout,IRing5,IRing56,
     1 NringA,NringB,NringC,NringD,KRing3,LRing3,n3r,n3ra,n3rb)
      endif
      IR3=6
      Label='closed'
      Write(Iout,1008) Label,IR1,IR2,IR3,KRing3
      if(Kring3.ne.0.and.iprint.eq.1) 
     1 write(Iout,1011) ((n3ra(J,I),J=1,3),i=1,Kring3)
      N3Ring=N3Ring+KRing3

C     (o5-5-6) 3-ring fusions
      Label='open  '
      Write(Iout,1008) Label,IR1,IR2,IR3,LRing3
      if(Lring3.ne.0.and.iprint.eq.1) 
     1 write(Iout,1011) ((n3rb(J,I),J=1,3),i=1,Lring3)
      N3Ring=N3Ring+LRing3

C     (l5-6-5) 3-ring fusions
      KRing3=0
      LRing3=0
      if(IRing56.gt.0) then
      CALL Ring565(natom,nfaces,Nedges,nat11,Iout,IRing5,IRing56,
     1 NringA,NringB,NringC,NringD,KRing3,LRing3,n3r,n3ra,n3rb,
     1 N5Ring, N6Ring,N5MEM,N6MEM)
      endif
      Label='bent  '
      IR2=6
      IR3=5
      Write(Iout,1008) Label,IR1,IR2,IR3,KRing3
      if(Kring3.ne.0.and.iprint.eq.1) 
     1 write(Iout,1011) ((n3ra(J,I),J=1,3),i=1,Kring3)
      N3Ring=N3Ring+KRing3

C     (b5-6-5) 3-ring fusions
      Label='linear'
      Write(Iout,1009) Label,IR1,IR2,IR3,LRing3
      if(Lring3.ne.0.and.iprint.eq.1) 
     1 write(Iout,1011) ((n3rb(J,I),J=1,3),i=1,Lring3)
      N3Ring=N3Ring+LRing3

C     (c6-5-6) 3-ring fusions
      KRing3=0
      LRing3=0
      if(IRing56.gt.0) then
      CALL Ring656(natom,nfaces,Nedges,nat11,Iout,IRing5,IRing6,IRing56,
     1 NringC,NringD,NringE,NringF,KRing3,LRing3,n3r,n3ra,n3rb)
      endif
      Label='closed'
      IR1=6
      IR2=5
      IR3=6
      Write(Iout,1008) Label,IR1,IR2,IR3,KRing3
      if(Kring3.ne.0.and.iprint.eq.1) 
     1 write(Iout,1011) ((n3ra(J,I),J=1,3),i=1,Kring3)
      N3Ring=N3Ring+KRing3

C     (o6-5-6) 3-ring fusions
      Label='open  '
      Write(Iout,1008) Label,IR1,IR2,IR3,LRing3
      if(Lring3.ne.0.and.iprint.eq.1) 
     1 write(Iout,1011) ((n3rb(J,I),J=1,3),i=1,Lring3)
      N3Ring=N3Ring+LRing3

C     (l5-6-6) 3-ring fusions
      KRing3=0
      LRing3=0
      Label='bent  '
      IR1=5
      IR2=6
      if(IRing56.gt.0.and.IRing6.gt.0) then
      CALL Ring566(natom,nfaces,Nedges,nat11,Iout,IRing6,IRing56,
     1 NringC,NringD,NringE,NringF,N5MEM,N6MEM,KRing3,LRing3,
     1 n3r,n3ra,n3rb)
      endif
      Write(Iout,1008) Label,IR1,IR2,IR3,KRing3
      if(Kring3.ne.0.and.iprint.eq.1) 
     1 write(Iout,1011) ((n3ra(J,I),J=1,3),i=1,Kring3)
      N3Ring=N3Ring+KRing3

C     (b5-6-6) 3-ring fusions
      Label='linear'
      Write(Iout,1008) Label,IR1,IR2,IR3,LRing3
      if(Lring3.ne.0.and.iprint.eq.1) 
     1 write(Iout,1011) ((n3rb(J,I),J=1,3),i=1,Lring3)
      N3Ring=N3Ring+LRing3

C     (c6-6-6) 3-ring fusions
      KRing3=0
      LRing3l=0
      LRing3b=0
      IR1=6
      Label='closed'
      if(IRing6.gt.0) then
      CALL Ring666(natom,nfaces,Nedges,nat11,Iout,IRing6,
     1 NringE,NringF,N6MEM,KRing3,LRing3b,LRing3l,n3r,n3ra)
      endif
      Write(Iout,1008) Label,IR1,IR2,IR3,KRing3
      if(Kring3.ne.0.and.iprint.eq.1) 
     1 write(Iout,1011) ((n3ra(J,I),J=1,3),i=1,Kring3)
      N3Ring=N3Ring+KRing3

C     (b6-6-6) 3-ring fusions
      Label='bent  '
      Write(Iout,1008) Label,IR1,IR2,IR3,LRing3b
      if(Lring3b.ne.0.and.iprint.eq.1) 
     1 write(Iout,1011) ((n3r(J,I),J=1,3),i=1,Lring3b)
      N3Ring=N3Ring+LRing3b

C     (l6-6-6) 3-ring fusions
      Label='linear'
      ndimh=nat11/2
      ncount=Lring3l-ndimh
      if(Lring3l.lt.ndimh) ncount=0
      Write(Iout,1008) Label,IR1,IR2,IR3,ncount
      if(ncount.ne.0.and.iprint.eq.1) write(Iout,1011) 
     1  ((n3r(J,I),J=1,3),i=ndimh+1,Lring3l)
      N3Ring=N3Ring+ncount

C     Final 3-ring count
 4000 N3ringexp=11*(Matom/2)-30
      Write(Iout,1010) N3ring,N3ringexp
      Ndif=N3ringexp-N3ring
      if(Ndif.ne.0) then
      Write(Iout,1012)
      endif
C     Check all connected 4-and 5-ring pentagons to create
C     pentagon indices a la Fowler and Manolopoulus

C     Similar for hexagon indices a la Fowler and Manolopoulus

 1000 Format(/1X,'Center for 5-rings',/1X,
     1 ' Ring Number RN, Atom Numbers Ni, Ring centers X,Y,Z and '
     1 'distances di from ring center to atoms',/2X,
     1 'RN     N1  N2  N3  N4  N5',9X,'X',12X,'Y',12X,'Z',
     1 12X,'d1',11X,'d2',11X,'d3',11X,'d4',11X,'d5')
 1001 Format(/1X,'Center for 6-rings',/1X,
     1 ' Ring Number RN, Atom Numbers Ni, Ring centers X,Y,Z and '
     1 'distances di from ring center to atoms',/2X,
     1 'RN     N1  N2  N3  N4  N5  N6',9X,'X',12X,'Y',12X,'Z',
     1 12X,'d1',11X,'d2',11X,'d3',11X,'d4',11X,'d5',11X,'d6')
 1002 Format(1X,I3,3X,5I4,3X,3(D12.6,1X),2X,5(D12.6,1X))
 1003 Format(1X,I3,3X,6I4,3X,3(D12.6,1X),2X,6(D12.6,1X))
 1004 Format(/1X,'Analyzing basic two- and three-ring fusions',
     1 //1X,'2-ring fusions between rings (RNI,RNJ):') 
 1005 Format(2X,'(',I1,'-',I1,') fusions: ',I5,' in total')
 1006 Format(15(1X,'(',I3,',',I3,')'))
 1007 Format(1X,'Total number of distinct two-ring fusions:',I4,
     1 ' (should be identical to the number of edges Ne)',/)
 1008 Format(2X,A6,1X,'(',I1,'-',I1,'-',I1,') fusions: ',I4)
 1009 Format(2X,A6,1X,'(',I1,'-',I1,'-',I1,') fusions: ',I4,
     1 ' (natural constraint of the second kind)')
 1010 Format(1X,'Total number of distinct three-ring fusions:',I5,
     1 ' (expected: ',I5,')')
 1011 Format(10(1X,'(',I3,',',I3,','I3,')'))
 1012 Format(' WARNING: expected 3-ring count does not match ',
     1 'number found')
 1013 Format(1X,'Rhagavachari-Fowler-Manolopoulos neighboring '
     1 'pentagon indices: (',5(I2,','),I2,')',
     1 ' and number of pentagon-pentagon fusions: ',I2)
 1014 Format(//1X,'3-ring fusions between rings (RNI,RNJ,RNK):') 
 1015 Format(1X,'Number of (5,5) fusions matches the ',I2,
     1 ' value obtained from Rhagavachar-/Fowler-Manolopoulos '
     1 'neighboring pentagon indices')
 1016 Format(1X,'Error: Number of (5,5) fusions does not match the ',I2,
     1 ' value obtained from Rhagavachari-Fowler-Manolopoulos '
     1 'neighboring pentagon indices')
 1017 Format(1X,'Rhagavachari/Fowler neighboring hexagon indices: (',
     1 6(I3,','),I3,')')
 1018 Format(1X,'Number vertices matches the ',I5,
     1 ' value obtained from Rhagavachari-Fowler-Manolopoulos '
     1 'neighboring hexagon indices ---> Fullerene is IPR')
 1019 Format(1X,'Number vertices does not match the ',I5,
     1 ' value obtained from Rhagavachari-Fowler-Manolopoulos '
     1 'neighboring hexagon indices ---> Fullerene is not IPR')
 1020 Format(1X,'Rhagavachari/Fowler neighboring hexagon indices: (',
     1 6(I3,','),I3,')  and strain parameter sigma = ',F12.6)
      Return
      END
 
      SUBROUTINE Ring666(natom,nfaces,Nedges,ndim,Iout,I6C,
     1 NrE,NrF,N6MEM,KRing3,LRing3b,LRing3l,n666,c666)
C     Search for (o5-5-5) and (c5-5-5) 3-ring fusions
      IMPLICIT INTEGER (A-Z)
      DIMENSION N6MEM(Nfaces,6),NrE(Nedges),NrF(Nedges)
      DIMENSION IS(6),JS(6)
      Integer n666(3,ndim),c666(3,natom)
C     Write out all 3-ring 566 connections first then sort them out
      i666=0
      Do I=1,I6C
      IR1=NrE(I)
      IR2=NrF(I)
      Do J=I+1,I6C
      IR3=NRE(J)
      IR4=NRF(J)
C     Check for each ring fusion which ring is connected to IR1.and.IR2
C     and store, there will be duplicates
      If(IR3.eq.IR1) then
       i666=i666+1
       if(i666.gt.ndim) stop
        if(IR2.gt.IR4) then
         n666(1,i666)=IR4 
         n666(2,i666)=IR1 
         n666(3,i666)=IR2
        else
         n666(1,i666)=IR2 
         n666(2,i666)=IR1 
         n666(3,i666)=IR4
       endif
      endif
      If(IR4.eq.IR1) then
       i666=i666+1
       if(i666.gt.ndim) stop
        if(IR2.gt.IR3) then
         n666(1,i666)=IR3 
         n666(2,i666)=IR1 
         n666(3,i666)=IR2
        else
         n666(1,i666)=IR2 
         n666(2,i666)=IR1 
         n666(3,i666)=IR3
       endif
      endif
      If(IR3.eq.IR2) then
       i666=i666+1
       if(i666.gt.ndim) stop
        if(IR1.gt.IR4) then
         n666(1,i666)=IR4 
         n666(2,i666)=IR2 
         n666(3,i666)=IR1
        else
         n666(1,i666)=IR1 
         n666(2,i666)=IR2 
         n666(3,i666)=IR4
       endif
      endif
      If(IR4.eq.IR2) then
       i666=i666+1
       if(i666.gt.ndim) stop
        if(IR1.gt.IR3) then
         n666(1,i666)=IR3 
         n666(2,i666)=IR2 
         n666(3,i666)=IR1
        else
         n666(1,i666)=IR1 
         n666(2,i666)=IR2 
         n666(3,i666)=IR3
       endif
      endif
      enddo
      enddo
      if(i666.eq.0) return

C     Determine closed structures from the list
C      and remove them from the main list
      j666=0
      Kring3=0
      Do I=1,i666
       IS(1)=n666(1,I)
       IS(2)=n666(2,I)
       IS(3)=n666(3,I)
       Do J=1,I6C
        JR1=NRE(J)
        JR2=NRF(J)
        if(IS(1).eq.JR1.and.IS(3).eq.JR2) then
           Kring3=Kring3+1
           CALL SortI(3,IS,JS)
         if(Kring3.gt.1) then
C     Sort out duplicates
          Do k=1,Kring3-1
           if(c666(1,k).eq.JS(1).and.c666(2,k).eq.JS(2).
     1      and.c666(3,k).eq.JS(3)) then
            Kring3=Kring3-1
            go to 2
           endif
          enddo
         endif
         if(Kring3.gt.natom) stop
          c666(1,Kring3)=JS(1)
          c666(2,Kring3)=JS(2)
          c666(3,Kring3)=JS(3)
          go to 2
        endif
       enddo
       j666=j666+1
       n666(1,j666)=n666(1,i)
       n666(2,j666)=n666(2,i)
       n666(3,j666)=n666(3,i)
   2  enddo
      i666=j666
      if(i666.eq.0) return

C     Now sort out linear and bent 666 structures and dividing the space
C      of aray n666 in half for bent and linear structures
      LRing3b=0
      ndimh=ndim/2
      LRing3l=ndimh
      Do I=1,i666
       IS1=n666(1,i)
       ISM=n666(2,i)
       IS3=n666(3,i)
       ISM6=ISM-12
        do j=1,6
          J1=J+1
          if(J1.eq.7) J1=1
          IP1=N6MEM(ISM6,J)  
          IP2=N6MEM(ISM6,J1)  
          itag1=0
          itag2=0
          do k=1,6
           KP1=N6MEM(IS1-12,k)
           if(KP1.eq.IP1) itag1=itag1+1
           if(KP1.eq.IP2) itag2=itag2+1
          enddo
          do k=1,6
           KP1=N6MEM(IS3-12,k)
           if(KP1.eq.IP2) itag1=itag1+1
           if(KP1.eq.IP1) itag2=itag2+1
          enddo
          if(itag1.eq.2.or.itag2.eq.2) then
           Lring3b=Lring3b+1
           if(Lring3b.gt.ndimh) stop
           n666(1,Lring3b)=IS1
           n666(2,Lring3b)=ISM
           n666(3,Lring3b)=IS3
           go to 3
          endif
        enddo
           Lring3l=Lring3l+1
           if(Lring3l.gt.ndim) stop
           n666(1,Lring3l)=IS1
           n666(2,Lring3l)=ISM
           n666(3,Lring3l)=IS3
   3  enddo 
      
C     Sort out duplicates for bent structures
      ncount=0
      Do I=1,Lring3b
       IS1=n666(1,I)
       IS2=n666(2,I)
       IS3=n666(3,I)
      Do J=I+1,Lring3b
       JS1=n666(1,J)
       JS2=n666(2,J)
       JS3=n666(3,J)
       if(IS1.eq.JS1.and.IS2.eq.JS2.and.IS3.eq.JS3) n666(1,J)=0
      enddo
      enddo
      Do I=1,Lring3b
       If(n666(1,I).ne.0) then
       ncount=ncount+1
       n666(1,ncount)=n666(1,I)
       n666(2,ncount)=n666(2,I)
       n666(3,ncount)=n666(3,I)
       endif
       enddo
      Lring3b=ncount

C     Sort out duplicates for linear structures
      ncount=ndimh
      Do I=ndimh+1,Lring3l
       IS1=n666(1,I)
       IS2=n666(2,I)
       IS3=n666(3,I)
      Do J=I+1,Lring3l
       JS1=n666(1,J)
       JS2=n666(2,J)
       JS3=n666(3,J)
       if(IS1.eq.JS1.and.IS2.eq.JS2.and.IS3.eq.JS3) n666(1,J)=0
      enddo
      enddo
      Do I=ndimh+1,Lring3l
       If(n666(1,I).ne.0) then
       ncount=ncount+1
       n666(1,ncount)=n666(1,I)
       n666(2,ncount)=n666(2,I)
       n666(3,ncount)=n666(3,I)
       endif
       enddo
      Lring3l=ncount

C     Sort both arrays n666    
C     First the bent structures
      Do I=1,Lring3b
       IS1=n666(1,I)
       IS3=n666(3,I)
      Do J=I+1,Lring3b
       JS1=n666(1,J)
       JS3=n666(3,J)
      IF(IS1-JS1) 10,11,12
  11  IF(JS3.gt.IS3) go to 10
  12  IS1=n666(1,J)
      IS2=n666(2,J)
      IS3=n666(3,J)
      n666(1,J)=n666(1,I)
      n666(2,J)=n666(2,I)
      n666(3,J)=n666(3,I)
      n666(1,I)=IS1
      n666(2,I)=IS2
      n666(3,I)=IS3
  10  enddo
      enddo

C     Next the linear structures
      Do I=ndimh+1,Lring3l
       IS1=n666(1,I)
       IS3=n666(3,I)
      Do J=I+1,Lring3l
       JS1=n666(1,J)
       JS3=n666(3,J)
      IF(IS1-JS1) 20,21,22
  21  IF(JS3.gt.IS3) go to 20
  22  IS1=n666(1,J)
      IS2=n666(2,J)
      IS3=n666(3,J)
      n666(1,J)=n666(1,I)
      n666(2,J)=n666(2,I)
      n666(3,J)=n666(3,I)
      n666(1,I)=IS1
      n666(2,I)=IS2
      n666(3,I)=IS3
  20  enddo
      enddo

      Return
      END
 
      SUBROUTINE Ring566(natom,nfaces,Nedges,ndim,Iout,I6C,I56C,
     1 NrC,NrD,NrE,NrF,N5MEM,N6MEM,KRing3,LRing3,n566,b566,l566)
C     Search for (o5-5-5) and (c5-5-5) 3-ring fusions
      IMPLICIT INTEGER (A-Z)
      DIMENSION N5MEM(Nfaces,5),N6MEM(Nfaces,6)
      DIMENSION NrE(Nedges),NrF(Nedges)
      DIMENSION NrC(Nedges),NrD(Nedges)
      Integer n566(3,ndim),l566(3,natom),b566(3,natom)
C     Write out all 3-ring 566 connections first then sort them out
      i566=0
      Do I=1,I56C
       IR1=NrC(I)
       IR2=NrD(I)
      Do J=1,I6C
       IR3=NRE(J)
       IR4=NRF(J)
C     Check for each ring fusion which ring is connected to IR1.and.IR2
C     and store, there will be duplicates
      If(IR2.eq.IR3) then
       i566=i566+1
       n566(1,i566)=IR1 
       n566(2,i566)=IR2 
       n566(3,i566)=IR4
      endif 
      If(IR2.eq.IR4) then
       i566=i566+1
       n566(1,i566)=IR1 
       n566(2,i566)=IR2 
       n566(3,i566)=IR3
      endif
      enddo
      enddo
      if(i566.eq.0) return
      
C     Remove closed structures from the list
      j566=0
      Do I=1,i566
      IR1=n566(1,I)
      IR3=n566(3,I)
      Do J=1,I56C
       JR1=NRC(J)
       JR2=NRD(J)
       if(IR1.eq.JR1.and.IR3.eq.JR2) then
       go to 2
       endif
      enddo
      j566=j566+1
      n566(1,j566)=n566(1,i)
      n566(2,j566)=n566(2,i)
      n566(3,j566)=n566(3,i)
   2  enddo
      i566=j566
      if(i566.eq.0) return

C     Now sort out linear and bent 566 structures
      Do I=1,i566
      IS5=n566(1,i)
      ISM=n566(2,i)
      IS6=n566(3,i)
      ISM6=ISM-12
        do j=1,6
          J1=J+1
          if(J1.eq.7) J1=1
          IP1=N6MEM(ISM6,J)  
          IP2=N6MEM(ISM6,J1)  
          itag1=0
          itag2=0
          do k=1,5
           KP1=N5MEM(IS5,k)
           if(KP1.eq.IP1) itag1=itag1+1
           if(KP1.eq.IP2) itag2=itag2+1
          enddo
          do k=1,6
           KP1=N6MEM(IS6-12,k)
           if(KP1.eq.IP2) itag1=itag1+1
           if(KP1.eq.IP1) itag2=itag2+1
          enddo
          if(itag1.eq.2.or.itag2.eq.2) then
           Kring3=Kring3+1
           b566(1,Kring3)=IS5
           b566(2,Kring3)=ISM
           b566(3,Kring3)=IS6
           go to 3
          endif
        enddo
           Lring3=Lring3+1
           l566(1,Lring3)=IS5
           l566(2,Lring3)=ISM
           l566(3,Lring3)=IS6
   3  enddo      

      Return
      END
 
      SUBROUTINE Ring656(natom,nfaces,Nedges,ndim,Iout,I5C,I6C,
     1 I56C,NrC,NrD,NrE,NrF,KRing3,LRing3,n656,c656,o656)
C     Search for (o5-5-5) and (c5-5-5) 3-ring fusions
      IMPLICIT INTEGER (A-Z)
      DIMENSION NrE(Nedges),NrF(Nedges)
      DIMENSION NrC(Nedges),NrD(Nedges)
      Integer n656(3,ndim),c656(3,natom),o656(3,natom)
C     Write out all 3-ring 656 connections first then sort them out
      i656=0
      Do I=1,I56C
       IR1=NrC(I)
       IR2=NrD(I)
      Do J=I+1,I56C
       IR3=NRC(J)
       IR4=NRD(J)
C     Check for each ring fusion which ring is connected to IR1.and.IR2
C     and store, there will be duplicates
       If(IR3.eq.IR1) then
       i656=i656+1
       if(IR2.gt.IR4) then
        mr=IR2
        IR2=IR4
        IR4=mr
       endif
       n656(1,i656)=IR2 
       n656(2,i656)=IR1 
       n656(3,i656)=IR4
       endif 
      enddo
      enddo
      if(i656.eq.0) return
      
C     Now sort out closed and open 656 structures
      Do 1 I=1,i656
      IS1=n656(1,i)
      ISM=n656(2,i)
      IS2=n656(3,i)
        do j=1,I6C
        IS3=NRE(J)
        IS4=NRF(J)
         if(IS1.eq.IS3.and.IS2.eq.IS4) then
          Kring3=Kring3+1
          c656(1,Kring3)=IS1
          c656(2,Kring3)=ISM
          c656(3,Kring3)=IS2
          go to 1
         endif
         enddo      
          Lring3=Lring3+1
          o656(1,Lring3)=IS1
          o656(2,Lring3)=ISM
          o656(3,Lring3)=IS2
   1  Continue

      Return
      END
 
      SUBROUTINE Ring565(natom,nfaces,Nedges,ndim,Iout,I5C,I56C,NrA,NrB,
     1 NrC,NrD,KRing3,LRing3,n565,b565,l565,N5Ring,N6Ring,N5MEM,N6MEM)
C     Search for (o5-5-5) and (c5-5-5) 3-ring fusions
      IMPLICIT INTEGER (A-Z)
      DIMENSION N5MEM(Nfaces,5),N6MEM(Nfaces,6)
      DIMENSION NrA(Nedges),NrB(Nedges)
      DIMENSION NrC(Nedges),NrD(Nedges)
      Integer n565(3,ndim),b565(3,natom),l565(3,natom)
C     Write out all 3-ring 565 connections first then sort them out
      i565=0
      Do I=1,I56C
       IR1=NrC(I)
       IR2=NrD(I)
      Do J=I+1,I56C
       IR3=NRC(J)
       IR4=NRD(J)
C     Check for each ring fusion which ring is connected to IR1.and.IR2
C     and store, there will be duplicates
       If(IR2.eq.IR4) then
        i565=i565+1
       if(IR1.gt.IR3) then
        mr=IR1
        IR1=IR3
        IR3=mr
       endif
        n565(1,i565)=IR1 
        n565(2,i565)=IR2 
        n565(3,i565)=IR3
       endif 
      enddo
      enddo
      if(i565.eq.0) return

C     Remove the (5,5) connections
      do i=1,i565
       I1=n565(1,i)
       I2=n565(3,i)
      do j=1,I5C
       J1=NRA(j)
       J2=NRB(j)
       if(J1.eq.I1.and.J2.eq.I2) then
        n565(1,i)=0
       endif
      enddo
      enddo

C     Now look for bent fusion and add them into b556
C     If found add a 0 for n555(1,I)
      Do 1 I=1,i565
      IS1=n565(1,i)
      If(IS1.ne.0) then
       IS2=n565(2,i)
       IS3=n565(3,i)
C     Determine if 3rings are aligned linear (jring=0) or bent (jring=1)
       Do J=1,6
        i5b=0
        J1=J-1
        if(J1.eq.0) J1=6
          IS12=IS2-12
          I6a=N6MEM(IS12,J1)
          I6b=N6MEM(IS12,J)
          i5b1=0
          i5b2=0
            do k=1,5
             I5x=N5MEM(IS1,k)
             I5y=N5MEM(IS3,k)
             if(I5x.eq.I6a) i5b1=i5b1+1
             if(I5y.eq.I6b) i5b1=i5b1+1
             if(I5x.eq.I6b) i5b2=i5b2+1
             if(I5y.eq.I6a) i5b2=i5b2+1
            enddo
        if(i5b1.eq.2.or.i5b2.eq.2) go to 2
        enddo
        go to 1
   2      Kring3=Kring3+1
C         Sort in ascending order
          b565(1,Kring3)=IS1
          b565(2,Kring3)=IS2
          b565(3,Kring3)=IS3
          n565(1,i)=0
        endif
   1  Continue

C     Now store the linear fusions
      Do I=1,i565
       if(n565(1,I).ne.0) then
        Lring3=Lring3+1
        l565(1,Lring3)=n565(1,i)
        l565(2,Lring3)=n565(2,i)
        l565(3,Lring3)=n565(3,i)
       endif
      enddo

      Return
      END
 
      SUBROUTINE Ring556(natom,nfaces,Nedges,ndim,Iout,I5C,I56C,
     1 NrA,NrB,NrC,NrD,KRing3,LRing3,n556,c556,o556)
C     Search for (o5-5-5) and (c5-5-5) 3-ring fusions
      IMPLICIT INTEGER (A-Z)
      DIMENSION NrA(Nedges),NrB(Nedges)
      DIMENSION NrC(Nedges),NrD(Nedges)
      DIMENSION IS(6),JS(6)
      Integer n556(3,ndim),c556(3,natom),o556(3,natom)
C     Write out all 3-ring 556 connections first then sort them out
      i556=0
      Do I=1,I5C
       IR1=NrA(I)
       IR2=NrB(I)
      Do J=1,I56C
       IR3=NRC(J)
       IR4=NRD(J)
C     Check for each ring fusion which ring is connected to IR1.and.IR2
C     and store, there will be duplicates
       If(IR3.eq.IR1) then
        i556=i556+1
        n556(1,i556)=IR2 
        n556(2,i556)=IR1 
        n556(3,i556)=IR4
       endif 
       If(IR3.eq.IR2) then
        i556=i556+1
        n556(1,i556)=IR1 
        n556(2,i556)=IR2 
        n556(3,i556)=IR4
       endif 
      enddo
      enddo
      if(i556.eq.0) return

C     Determine closed 556 structures from the list
C      and remove them from the main list
      Do I=1,i556
       IS(1)=n556(1,I)
       IS(2)=n556(2,I)
       IS(3)=n556(3,I)
       Do J=1,I56C
        JR1=NRC(J)
        JR2=NRD(J)
        if(IS(1).eq.JR1.and.IS(3).eq.JR2) then
           Kring3=Kring3+1
           If(IS(1).gt.IS(2)) then
           IM=IS(1)
           IS(1)=IS(2)
           IS(2)=IM
           endif
         if(Kring3.gt.1) then
C     Sort out duplicates
          Do k=1,Kring3-1
           if(c556(1,k).eq.IS(1).and.c556(2,k).eq.IS(2).
     1      and.c556(3,k).eq.IS(3)) then
            Kring3=Kring3-1
            go to 2
           endif
          enddo
         endif
          c556(1,Kring3)=IS(1)
          c556(2,Kring3)=IS(2)
          c556(3,Kring3)=IS(3)
          go to 2
        endif
       enddo
       Lring3=Lring3+1
       o556(1,Lring3)=IS(1)
       o556(2,Lring3)=IS(2)
       o556(3,Lring3)=IS(3)
   2  enddo

      Return
      END
 
      SUBROUTINE Ring555(natom,nfaces,Nedges,ndim,Iout,I5C,
     1 NrA,NrB,KRing3,LRing3,n555,n555f,m555)
C     Search for (o5-5-5) and (c5-5-5) 3-ring fusions
      IMPLICIT INTEGER (A-Z)
      DIMENSION NrA(Nedges),NrB(Nedges)
      DIMENSION IS(6),JS(6)
      DIMENSION n555(3,ndim),m555(3,natom),n555f(3,natom)
C     Write out all 3-ring 555 connections first then sort them out
      i555=0
      Do I=1,I5C
      IR1=NrA(I)
      IR2=NrB(I)
      Do J=I+1,I5C
      IR3=NrA(J)
      IR4=NrB(J)
C     Check for each ring fusion which ring is connected to IR1.and.IR2
C     and store, there will be duplicates, permute first and last ting
C     if necessary
      If(IR3.eq.IR1) then
       i555=i555+1
       if(IR4.lt.IR2) then
        n555(1,i555)=IR4 
        n555(2,i555)=IR1 
        n555(3,i555)=IR2
       else
        n555(1,i555)=IR2 
        n555(2,i555)=IR1 
        n555(3,i555)=IR4
       endif 
      endif 
      If(IR4.eq.IR1) then
       i555=i555+1
       if(IR3.lt.IR2) then
        n555(1,i555)=IR3 
        n555(2,i555)=IR1 
        n555(3,i555)=IR2
       else
        n555(1,i555)=IR2 
        n555(2,i555)=IR1 
        n555(3,i555)=IR3
       endif 
      endif 
      If(IR3.eq.IR2) then
       i555=i555+1
       if(IR1.lt.IR4) then
        n555(1,i555)=IR1 
        n555(2,i555)=IR2 
        n555(3,i555)=IR4
       else
        n555(1,i555)=IR4 
        n555(2,i555)=IR2 
        n555(3,i555)=IR1
       endif 
      endif 
      If(IR4.eq.IR2) then
       i555=i555+1
       if(IR1.lt.IR3) then
        n555(1,i555)=IR1 
        n555(2,i555)=IR2 
        n555(3,i555)=IR3
       else
        n555(1,i555)=IR3 
        n555(2,i555)=IR2 
        n555(3,i555)=IR1
       endif 
      endif 
      enddo
      enddo
      if(i555.eq.0) return

C     Separate closed from open structures from the list
      Do I=1,i555
       IS(1)=n555(1,I)
       IS(2)=n555(2,I)
       IS(3)=n555(3,I)
       Do J=1,I5C
        JR1=NRA(J)
        JR2=NRB(J)
        if(IS(1).eq.JR1.and.IS(3).eq.JR2) then
           Lring3=Lring3+1
           CALL SortI(3,IS,JS)
         if(Lring3.gt.1) then
C     Sort out duplicates
          Do k=1,Lring3-1
           if(m555(1,k).eq.JS(1).and.m555(2,k).eq.JS(2).
     1      and.m555(3,k).eq.JS(3)) then
            Lring3=Lring3-1
            go to 2
           endif
          enddo
         endif
          m555(1,Lring3)=JS(1)
          m555(2,Lring3)=JS(2)
          m555(3,Lring3)=JS(3)
          go to 2
        endif
       enddo
       Kring3=Kring3+1
       n555f(1,Kring3)=IS(1)
       n555f(2,Kring3)=IS(2)
       n555f(3,Kring3)=IS(3)
   2  enddo

C     Sort array n555f
      Do I=1,Kring3
       IS1=n555f(1,I)
       IS3=n555f(3,I)
      Do J=I+1,Kring3
       JS1=n555f(1,J)
       JS3=n555f(3,J)
      IF(IS1-JS1) 10,11,12
  11  IF(JS3.gt.IS3) go to 10
  12  IS1=n555f(1,J)
      IS2=n555f(2,J)
      IS3=n555f(3,J)
      n555f(1,J)=n555f(1,I)
      n555f(2,J)=n555f(2,I)
      n555f(3,J)=n555f(3,I)
      n555f(1,I)=IS1
      n555f(2,I)=IS2
      n555f(3,I)=IS3
  10  enddo
      enddo

      Return
      END
 
      SUBROUTINE Ring56(natom,Nfaces,Nedges,IR56,N5R,N6R,NrA,NrB,Nring,
     1 N5MEM,N6MEM)
      IMPLICIT INTEGER (A-Z)
      DIMENSION N5MEM(Nfaces,5),N6MEM(Nfaces,6),Nring(Nfaces)
      DIMENSION NrA(Nedges),NrB(Nedges)
      IR56=0
C     (5-6) 2-ring fusions
      Do I=1,N5R
      Do J=1,N6R
       Do K1=1,5
       IN1=N5MEM(I,K1)
        IF(K1.EQ.5) then
        IN2=N5MEM(I,1)
        else
        IN2=N5MEM(I,K1+1)
        endif
       Do K2=1,6
        IM1=N6MEM(J,K2)
        IF(K2.EQ.6) then
        IM2=N6MEM(J,1)
        else
        IM2=N6MEM(J,K2+1)
        endif
        IF(K2.EQ.1) then
        IM3=N6MEM(J,6)
        else
        IM3=N6MEM(J,K2-1)
        endif
         IF(IN2.LT.IN1) then
          IMem=IN2
          IN2=IN1
          IN1=IMem
         endif
         IM3R=IM1
         IF(IM2.LT.IM1) then
          IMem=IM2
          IM2=IM1
          IM1=IMem
         endif
           IF(IN1.EQ.IM1.AND.IN2.EQ.IM2) then
           IR56=IR56+1
           NrA(IR56)=NRing(+I)
           NrB(IR56)=NRing(N5R+J)
           Go to 1000
           endif
         IM1=IM3R
         IF(IM3.LT.IM1) then
          IMem=IM3
          IM3=IM1
          IM1=IMem
         endif
           IF(IN1.EQ.IM1.AND.IN2.EQ.IM3) then
           IR56=IR56+1
           NrA(IR56)=NRing(+I)
           NrB(IR56)=NRing(N5R+J)
           Go to 1000
           endif
       enddo
       enddo
 1000 Continue
      enddo
      enddo
      Return
      END
 
      SUBROUTINE Ring55(natom,Nfaces,Nedges,IR5,N5R,NrA,NrB,Nring,
     1 N5MEM,IedA,IedB)
      IMPLICIT INTEGER (A-Z)
      DIMENSION N5MEM(Nfaces,5),Nring(Nfaces)
      DIMENSION NrA(Nedges),NrB(Nedges)
      DIMENSION IedA(Nedges),IedB(Nedges)
      IR5=0
C     (5-5) 2-ring fusions
      Do I=1,N5R
      Do J=I+1,N5R
       Do K1=1,5
        IN1=N5MEM(I,K1)
        IF(K1.EQ.5) then
         IN2=N5MEM(I,1)
        else
         IN2=N5MEM(I,K1+1)
        endif
       Do K2=1,5
        IM1=N5MEM(J,K2)
        IF(K2.EQ.5) then
         IM2=N5MEM(J,1)
        else
         IM2=N5MEM(J,K2+1)
        endif
        IF(K2.EQ.1) then
         IM3=N5MEM(J,5)
        else
         IM3=N5MEM(J,K2-1)
        endif
         IF(IN2.LT.IN1) then
          IMem=IN2
          IN2=IN1
          IN1=IMem
         endif
         IM3R=IM1
         IF(IM2.LT.IM1) then
          IMem=IM2
          IM2=IM1
          IM1=IMem
         endif
           IF(IN1.EQ.IM1.AND.IN2.EQ.IM2) then
           IR5=IR5+1
           NrA(IR5)=NRing(I)
           NrB(IR5)=NRing(J)
           IedA(IR5)=IN1
           IedB(IR5)=IN2
           Go to 1000
           endif
         IM1=IM3R
         IF(IM3.LT.IM1) then
          IMem=IM3
          IM3=IM1
          IM1=IMem
         endif
           IF(IN1.EQ.IM1.AND.IN2.EQ.IM3) then
           IR5=IR5+1
           NrA(IR5)=NRing(I)
           NrB(IR5)=NRing(J)
           IedA(IR5)=IN1
           IedB(IR5)=IN2
           Go to 1000
           endif
       enddo
       enddo
 1000 Continue
      enddo
      enddo
      Return
      END
 
      SUBROUTINE Ring66(natom,nfaces,Nedges,IR6,N5R,N6R,NrA,NrB,
     1 Nring,N6MEM)
      IMPLICIT INTEGER (A-Z)
      DIMENSION N6MEM(Nfaces,6),Nring(Nfaces)
      DIMENSION NrA(Nedges),NrB(Nedges)
      IR6=0
C     (6-6) 2-ring fusions
      Do I=1,N6R
      Do J=I+1,N6R
       Do K1=1,6
       IN1=N6MEM(I,K1)
        IF(K1.EQ.6) then
        IN2=N6MEM(I,1)
        else
        IN2=N6MEM(I,K1+1)
        endif
       Do K2=1,6
        IM1=N6MEM(J,K2)
        IF(K2.EQ.6) then
        IM2=N6MEM(J,1)
        else
        IM2=N6MEM(J,K2+1)
        endif
        IF(K2.EQ.1) then
        IM3=N6MEM(J,6)
        else
        IM3=N6MEM(J,K2-1)
        endif
         IF(IN2.LT.IN1) then
          IMem=IN2
          IN2=IN1
          IN1=IMem
         endif
         IM3R=IM1
         IF(IM2.LT.IM1) then
          IMem=IM2
          IM2=IM1
          IM1=IMem
         endif
           IF(IN1.EQ.IM1.AND.IN2.EQ.IM2) then
           IR6=IR6+1
           NrA(IR6)=NRing(N5R+I)
           NrB(IR6)=NRing(N5R+J)
           Go to 1000
           endif
         IM1=IM3R
         IF(IM3.LT.IM1) then
          IMem=IM3
          IM3=IM1
          IM1=IMem
         endif
           IF(IN1.EQ.IM1.AND.IN2.EQ.IM3) then
           IR6=IR6+1
           NrA(IR6)=NRing(N5R+I)
           NrB(IR6)=NRing(N5R+J)
           Go to 1000
           endif
       enddo
       enddo
 1000 Continue
      enddo
      enddo
      Return
      END
 
      SUBROUTINE DifDist(Ndif,N,Tol,Distac,Rmem)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION Distac(6),Rmem(100)
      If(Ndif.eq.0) then
       Rmem(1)=Distac(1)
       Ndif=1
      endif
       do I=1,N
       do J=1,Ndif
       difR=dabs(Distac(I)-Rmem(J))
         if(difR.lt.Tol) Go to 1
       enddo
         Ndif=Ndif+1
         Rmem(Ndif)=Distac(I)
    1  Continue
       enddo
      Return
      END
 
      SUBROUTINE Distmatrix(NAtom,natomL,MAtom,IOUT,Iprint,Iopt,
     1 Dist,DistMat,Rmin,Rmax,Vol,ASphere)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION Dist(3,natom),DistMat(natomL)
C     Calculate distance matrix between atoms from cartesian coordinates
      DATA API/3.14159265358979d0/
      IMat=0
      if(Iopt.eq.0.and.Iprint.eq.1) Write(IOUT,1000) 
      Do I=2,MAtom
      Do J=1,I-1
      Sum=0.d0
      Do K=1,3
      Sum=Sum+(Dist(K,I)-Dist(K,J))**2
      enddo
      IMat=IMat+1
      DistMat(IMat)=dsqrt(Sum)
      enddo
      enddo
      Do I=2,MAtom
      IZ=((I-1)*(I-2))/2
      if(Iopt.eq.0.and.Iprint.eq.1) 
     1   Write(IOUT,1001) (I,J,DistMat(IZ+J),J=1,I-1)
      enddo
C     Determine minimum and maximum distances
      Rmin=1.d20
      Rmax=1.d0
      RmaxS=1.d0
      Do I=1,MAtom
      Sum=0.d0
      Do K=1,3
      Sum=Sum+Dist(K,I)**2
      enddo
      Sumd=dsqrt(Sum)
      If(Sumd.gt.RmaxS) RmaxS=Sumd
      Do J=I+1,MAtom
      DM=FunDistMat(I,J,natomL,DistMat)
      If(DM.lt.Rmin) then
      Rmin=DM
      Imin=I
      Jmin=J
      endif
      If(DM.gt.Rmax) then
      Rmax=DM
      Imax=I
      Jmax=J
      endif
      enddo
      enddo
      Vol=4.d0/3.d0*API*RmaxS**3
      ASphere=4.d0*API*RmaxS**2
      Write(IOUT,1002) Rmin,Imin,Jmin,Rmax,Imax,Jmax,RmaxS,Vol,
     1 ASphere,ASphere/Vol
C     Volume of ideal capped icosahedron
      If(Matom.eq.60) then
      Redge=Rmin*3.d0
      dsr5=dsqrt(5.d0)
C     Calculate square cos36 and sin36
      coss36=.125d0*(3.d0+dsr5)
      sins36=1.d0-coss36
      fac1=dsqrt(4.d0-1.d0/sins36)
      Rico=Redge/fac1
      VolIco=(5.d0/12.d0)*(3.d0+dsr5)*Redge**3
      VolIcocap=0.25d0*(125.d0+43.d0*dsr5)*(Redge/3.d0)**3
      Write(IOUT,1003) Rico,Redge,VolIco,VolIcocap 
      endif 
C     Calculate the volume for C50 using R5
      If(Matom.eq.20) then
      dsr5=dsqrt(5.d0)
      dsr3=dsqrt(3.d0)
      fac1=.25d0*(15.d0+7.d0*dsr5)
      Rdode=.25d0*dsr3*(1.d0+dsr5)*Rmin
      VolIcocap=fac1*Rmin**3
      Write(IOUT,1004) Rdode,Rmin,VolIcocap 
      endif
 1000 Format(/1X,'Distance Matrix:')
 1001 Format(5(1X,'('I3,',',I3,')',1X,D15.8))
 1002 Format(/1X,'Minimum distance ',D15.8,
     1 ' between atoms ',I3,' and ',I3,
     1      /1X,'Maximum distance ',D15.8,
     1 ' between atoms ',I3,' and ',I3,
     1 /1X,' Radius of covering central sphere ',D15.8,
     1 /1X,' Volume of covering central sphere (upper limit)',
     1 D15.8,' in units cube of distances'
     1 /1X,' Area of covering central sphere (upper limit)  ',D15.8,
     1 ' in units square of distances',
     1 /1X,' Area to volume ratio of covering central sphere (3/R) ',
     1 D15.8,' in units of inverse distance')
 1003 Format(1X,' Radius of (uncapped) icosahedron (obtained from '
     1 'minimum distance): ',D15.8,' and edge length: ',D15.8,/,
     1 '  Volume of ideal icosahedron for C60:',D15.8,
     1 ' and of ideal capped icosahedron:',
     1 D15.8,' (in units cube of distances)')
 1004 Format(1X,' Radius of dodecahedron: ',D15.8,
     1 ' and edge length: ',D15.8,/,
     1 '  Volume of ideal dodecahedron for C20:',D15.8)
      RETURN
      END

      SUBROUTINE Ring(NAtom,Nfaces,natomL,Natom2,MCon2,MAtom,
     1 IOUT,Ncount5,Ncount6,IC3,Icon2,N5MEM,N6MEM,Rmin5,
     1 Rmin6,Rmax5,Rmax6,DistMat)
C     Get all 6 and 5 ring systems by checking all possible branches (vertices)
C     for each atom
C     I am sure there are better algorithms, but this one is not too bad and fast
C     enough and fast.
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION IC3(NAtom,3)
      DIMENSION Icon2(natom2)
      DIMENSION N5MEM(Nfaces,5),N5MEMS(Nfaces,5)
      DIMENSION N6MEM(Nfaces,6),N6MEMS(Nfaces,6)
      DIMENSION IPa(6,96)
      DIMENSION DistMat(natomL)
      DIMENSION Rd(6)
      DIMENSION Rmem(100)
      Data Tol/5.d-4/
      Ndif=0
      NForbid=0
      Ncount5=1
      Ncount6=1
      Do I=1,6
      Rd(I)=0.d0
      enddo
      Do IS=1,MAtom
      Do 1 I=1,6
      Do 1 J=1,96
    1 IPa(I,J)=0
      Do 2 I=1,3
    2 IPa(1,I)=IC3(IS,I)     
      Do I2=1,3
      IX1=IPa(1,I2)
      if(IX1.ne.0) CALL Step(NAtom,2,I2,IS,IX1,IPA,IC3)
      Do I3=1,6
      IV=I3/2
      IV1=(I3+1)/2
      IDIF=IV1-IV
      IF(IDIF.EQ.1) IV=IV+1
      IForbid=IPa(1,IV)
      IX2=IPa(2,I3)
      if(IX2.ne.0) CALL Step(NAtom,3,I3,IForbid,IX2,IPA,IC3)
      Do I4=1,12
      IV=I4/2
      IV1=(I4+1)/2
      IDIF=IV1-IV
      IF(IDIF.EQ.1) IV=IV+1
      IForbid=IPa(2,IV)
      IX3=IPa(3,I4)
      if(IX3.ne.0) CALL Step(NAtom,4,I4,IForbid,IX3,IPA,IC3)
      Do I5=1,24
      IV=I5/2
      IV1=(I5+1)/2
      IDIF=IV1-IV
      IF(IDIF.EQ.1) IV=IV+1
      IForbid=IPa(3,IV)
      IX4=IPa(4,I5)
      if(IX4.ne.0) CALL Step(NAtom,5,I5,IForbid,IX4,IPA,IC3)
      Do I6=1,48
      IV=I6/2
      IV1=(I6+1)/2
      IDIF=IV1-IV
      IF(IDIF.EQ.1) IV=IV+1
      IForbid=IPa(4,IV)
      IX5=IPa(5,I6)
      if(IX5.ne.0) CALL Step(NAtom,6,I6,IForbid,IX5,IPA,IC3)
      enddo
      enddo
      enddo
      enddo
      enddo
C     Print*,' Tree ',IS
C     Do 3 I=1,6
C     Write(IOUT,1010) (IPa(I,J),J=1,48)
C   3 Write(IOUT,1011) (IPa(I,J),J=49,96)
C     Identify all 5-membered rings
      Do I=1,48
      IN5=IPa(5,I)
      IF(IN5.eq.IS) then
      CALL Ring5(Ncount5,I,IN5,natom,Nfaces,IPA,N5MEM,N5MEMS)
      endif
      enddo
C     Identify all 6-membered rings
      Do I=1,96
      IN6=IPa(6,I)
      IF(IN6.eq.IS) then
      CALL Ring6(Ncount6,I,IN6,natom,Nfaces,IPA,N6MEM,N6MEMS)
      endif
      enddo
      enddo
      Ncount5=Ncount5-1
      Write(IOUT,1000) Ncount5
      Do I=1,Ncount5
      Rsum=0.
      Rmin5=1000.d0
      Rmax5=0.d0
      Do J=1,5
      IAT1=N5MEM(I,J)
      J1=J+1
      IF(J1.eq.6) J1=1
      IAT2=N5MEM(I,J1)
      DM=FunDistMat(IAT1,IAT2,natomL,DistMat)
      Rd(J)=DM
      if(Rd(J).LT.Rmin5) Rmin5=Rd(J)
      if(Rd(J).GT.Rmax5) Rmax5=Rd(J)
      RSum=Rsum+Rd(J)
      enddo
      RAv5=RSum*.2d0
      Rsum=0.
      Do J=1,5
      Rsum=Rsum+(RAv5-Rd(J))**2
      enddo
      Rrmsd=dsqrt(Rsum*.2d0)
      Write(IOUT,1001) (N5MEM(I,J),J=1,5),RAv5,Rrmsd,(Rd(J),J=1,5)
      CALL DifDist(Ndif,5,Tol,Rd,Rmem)
      enddo
      Write(IOUT,1007) Rmin5,Rmax5
C
      Ncount6=Ncount6-1
      Write(IOUT,1002) Ncount6
      If(Ncount6.ne.0) Write(IOUT,1006)
      Rmin6=1000.d0
      Rmax6=0.d0
      Do I=1,Ncount6
      Rsum=0.
      Do J=1,6
      IAT1=N6MEM(I,J)
      J1=J+1
      IF(J1.eq.7) J1=1
      IAT2=N6MEM(I,J1)
      DM=FunDistMat(IAT1,IAT2,natomL,DistMat)
      Rd(J)=DM
      if(Rd(J).LT.Rmin6) Rmin6=Rd(J)
      if(Rd(J).GT.Rmax6) Rmax6=Rd(J)
      RSum=Rsum+Rd(J)
      enddo
      RAv6=RSum/6.d0
      Rsum=0.
      Do J=1,6
      Rsum=Rsum+(RAv6-Rd(J))**2
      enddo
      Rrmsd=dsqrt(Rsum*.2d0)
      Write(IOUT,1003) (N6MEM(I,J),J=1,6),RAv6,Rrmsd,(Rd(J),J=1,6)
      CALL DifDist(Ndif,6,Tol,Rd,Rmem)
      enddo
      If(Ncount6.ne.0) Write(IOUT,1008) Rmin6,Rmax6
      If(Rmin5.lt.Rmin6) then
      NMin=5
      RminT=Rmin5
      else
      NMin=6
      RminT=Rmin6
      endif
      If(Rmax5.ge.(Rmax6-1.d-12)) then
      NMax=5
      RmaxT=Rmax5
      else
      NMax=6
      RmaxT=Rmax6
      endif
C     Check Euler charecteristic
      Ncount56=Ncount5+Ncount6
      MEuler=MAtom-Mcon2+Ncount56
      Mv=(5*Ncount5+6*Ncount6)/3
      Me=(5*Ncount5+6*Ncount6)/2
      Write(IOUT,1004) MAtom,Mcon2,Ncount56,MEuler,Ncount5,Ncount6,Mv,Me
      If(MEuler.ne.2) Write(IOUT,1005)
      If(Ncount5.ne.12) then
      Write(IOUT,1014)
      stop
      endif
      Write(IOUT,1009) NMin,RminT,NMax,RmaxT
      ameas=dfloat(Ndif)/dfloat(Mcon2)
      Write(Iout,1012) Ndif,ameas,Tol
      Write(Iout,1013) (Rmem(I),I=1,Ndif)
 1000 Format(/1X,I3,' five-membered-rings identified',/,
     1 ' Atom numbers in ring, Ni, mean distance, dm, and root mean',
     1 ' square deviation for distances, RMSD,'
     1 ' and distances in the ring:',
     1 /3X,'N1   N2   N3   N4   N5',9X,'dm',11X,'RMSD',
     1 15X,'R1',12X,'R2',12X,'R3',12X,'R4',12X,'R5')
 1001 Format(1X,5(I4,1X),3X,2(d12.6,2X),5X,5(d12.6,2X))
 1002 Format(/1X,I3,' six-membered-rings identified')
 1003 Format(1X,6(I4,1X)3X,2(d12.6,2X),5X,6(d12.6,2X))
 1004 Format(//1X,'Checking the Euler polyhedron formula:',/1X,
     1 'Number of vertices Nv: ',I4,/1X,
     1 'Number of edges Ne:    ',I4,/1X,
     1 'Number of faces Nf:    ',I4,/1X,
     1 'Euler number Nv-Ne+Nf: ',I4,
     1 ' (should be 2 for spherical polyhedra '
     1 'or planar connected graphs)',/1X,
     1 'Number of pentagons:   ',I4,/1X,
     1 'Number of hexagons:    ',I4,/1X,
     1 'Mv=',I4,1X,' Me=',I4)
 1005 Format(1X,' **** Capped Polydron does not fulfill Eulers theorem')
 1006 Format(/1X,' Atom numbers in ring,',
     1 ' Ni, mean distance, dm, and root mean',
     1 ' square deviation for distances, RMSD,'
     1 ' and distances in the ring:',
     1 /3X,'N1   N2   N3   N4   N5   N6',9X,'dm',11X,'RMSD',
     1 15X,'R1',12X,'R2',12X,'R3',12X,'R4',12X,'R5'12X,'R6')
 1007 Format(1X,' 5-ring minimum bond distance: ',d12.6,
     1 3X,' maximum bond distance: ',d12.6) 
 1008 Format(1X,' 6-ring minimum bond distance: ',d12.6,
     1 3X,' maximum bond distance: ',d12.6) 
 1009 Format(1X,' Minimum bond distance in ',I1,'-ring: ',d12.6,
     1 3X,' maximum bond distance in ',I1,'-ring: ',d12.6) 
 1010 Format(1X,96(I3))
 1011 Format(3X,96(I3))
 1012 Format(/1X,'Number of different bond distances Nr=',I4,
     1 ' and Nr/Ne= ',d12.6,
     1 ' (within tolerance ',d6.1,'),  Nonequivalent bond distances:') 
 1013 Format(10(1X,D12.6,1X))
 1014 Format(1X,'**** Severe error: 12 pentagons expected. STOP ****')
      RETURN
      END

      SUBROUTINE Ring5(Ncount5,IN,I5,natom,nfaces,IPA,N5MEM,N5MEMS)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION IPa(6,96),N5MEM(Nfaces,5),N5MEMS(Nfaces,5)
      DIMENSION ISM(6),JSM(6)
C     Identify all 5-membered rings
C     Print*,'5-membered ring detected',IN
      ISM(5)=I5
      IT4=IN/2 
      IT4x=(IN+1)/2
      IDIF=IT4x-IT4
      IF(IDIF.EQ.1) IT4=IT4+1
      ISM(4)=IPA(4,IT4)
      IT3=IT4/2 
      IT3x=(IT4+1)/2
      IDIF=IT3x-IT3
      IF(IDIF.EQ.1) IT3=IT3+1
      ISM(3)=IPA(3,IT3)
      IT2=IT3/2 
      IT2x=(IT3+1)/2
      IDIF=IT2x-IT2
      IF(IDIF.EQ.1) IT2=IT2+1
      ISM(2)=IPA(2,IT2)
      IT1=IT2/2 
      IT1x=(IT2+1)/2
      IDIF=IT1x-IT1
      IF(IDIF.EQ.1) IT1=IT1+1
      ISM(1)=IPA(1,IT1)
      IF(Ncount5.eq.1) then
      Do I=1,5
      N5MEM(1,I)=ISM(I)
      enddo
      NCount5=NCount5+1
      CALL SortI(5,ISM,JSM)
      Do I=1,5
      N5MEMS(1,I)=JSM(I)
      enddo
C      Print*,ISM,' Sorted ',JSM
      return
      endif
      CALL SortI(5,ISM,JSM)
      IREP=0
      Do I=1,NCount5-1
      IF(N5MEMS(I,1).EQ.JSM(1).AND.N5MEMS(I,2).EQ.JSM(2).AND.
     1  N5MEMS(I,3).EQ.JSM(3).AND.N5MEMS(I,4).EQ.JSM(4).AND.
     1  N5MEMS(I,5).EQ.JSM(5)) IREP=1
      enddo
      IF(IREP.eq.0) then
      Do I=1,5
      N5MEM(NCount5,I)=ISM(I)
      N5MEMS(NCount5,I)=JSM(I)
      enddo
      NCount5=NCount5+1
      endif
C     Print*,ISM,' Sorted ',JSM
      RETURN
      END

      SUBROUTINE Ring6(Ncount6,IN,I6,natom,nfaces,IPA,N6MEM,N6MEMS)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION IPa(6,96),N6MEM(Nfaces,6),N6MEMS(Nfaces,6)
      DIMENSION ISM(6),JSM(6)
C     Identify all 6-membered rings
C     Print*,'6-membered ring detected',IN
      ISM(6)=I6
      IT5=IN/2 
      IT5x=(IN+1)/2
      IDIF=IT5x-IT5
      IF(IDIF.EQ.1) IT5=IT5+1
      ISM(5)=IPA(5,IT5)
      IT4=IT5/2 
      IT4x=(IT5+1)/2
      IDIF=IT4x-IT4
      IF(IDIF.EQ.1) IT4=IT4+1
      ISM(4)=IPA(4,IT4)
      IT3=IT4/2 
      IT3x=(IT4+1)/2
      IDIF=IT3x-IT3
      IF(IDIF.EQ.1) IT3=IT3+1
      ISM(3)=IPA(3,IT3)
      IT2=IT3/2 
      IT2x=(IT3+1)/2
      IDIF=IT2x-IT2
      IF(IDIF.EQ.1) IT2=IT2+1
      ISM(2)=IPA(2,IT2)
      IT1=IT2/2 
      IT1x=(IT2+1)/2
      IDIF=IT1x-IT1
      IF(IDIF.EQ.1) IT1=IT1+1
      ISM(1)=IPA(1,IT1)
      IF(Ncount6.eq.1) then
      Do I=1,6
      N6MEM(1,I)=ISM(I)
      enddo
      NCount6=NCount6+1
      CALL SortI(6,ISM,JSM)
      Do I=1,6
      N6MEMS(1,I)=JSM(I)
      enddo
C     Print*,ISM,' Sorted ',JSM
      return
      endif
      CALL SortI(6,ISM,JSM)
      IREP=0
      Do I=1,NCount6-1
      IF(N6MEMS(I,1).EQ.JSM(1).AND.N6MEMS(I,2).EQ.JSM(2).AND.
     1  N6MEMS(I,3).EQ.JSM(3).AND.N6MEMS(I,4).EQ.JSM(4).AND.
     1  N6MEMS(I,5).EQ.JSM(5).AND.N6MEMS(I,6).EQ.JSM(6)) IREP=1
      enddo
      Do I=1,NCount6-1
      IF(JSM(1).Eq.JSM(2).OR.JSM(2).Eq.JSM(3).OR.JSM(3).Eq.JSM(4)
     1 .OR.JSM(4).Eq.JSM(5).OR.JSM(5).Eq.JSM(6)) IREP=1
      enddo
      IF(IREP.eq.0) then
      Do I=1,6
      N6MEM(NCount6,I)=ISM(I)
      N6MEMS(NCount6,I)=JSM(I)
      enddo
      NCount6=NCount6+1
      endif
C     Print*,ISM,' Sorted ',JSM
      RETURN
      END

      SUBROUTINE SortI(N,IS,JS)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION IS(6),JS(6)
C     Sort the N integer numbers, input IS, Output JS
      DO I=1,N
      JS(I)=IS(I)
      enddo
      N1=N-1
      DO 15 I=1,N1
      NAMIN=JS(I)
      M=I+1
      DO 25 K=M,N
      IF (NAMIN.LE.JS(K)) GO TO 25
      NZ=NAMIN
      NAMIN=JS(K)
      JS(K)=NZ
 25   CONTINUE
 15   JS(I)=NAMIN
      RETURN
      END

      SUBROUTINE Step(Natom,ITree,ILoop,IForbid,INum,IPa,IC3)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION IC3(Natom,3)
      DIMENSION IPa(6,96)
      DIMENSION IM(2)
C     Filling in Tree structure at level Istep
      I=1
      I1=IC3(INum,1)
      IF(I1.NE.IForbid) then
      IM(1)=I1
      I=2
      endif
      I2=IC3(INum,2)
      IF(I2.NE.IForbid) then
      IM(I)=I2
      endif
      I3=IC3(INum,3)
      IF(I3.NE.IForbid) then
      IM(2)=I3
      endif
      I=2*ILoop-1
      IPA(ITree,I)=IM(1)
      IPA(ITree,I+1)=IM(2)
      RETURN
      END

      SUBROUTINE Connect(NAtom,natomL,Natom2,MCon2,MAtom,
     1 Ipent,IOUT,Icon2,IC3,IDA,Tol,DistMat,Rmin)
C     Get the connectivities between 2 and 3 atoms
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION DistMat(natomL)
      DIMENSION Icon2(natom2),IDA(NAtom,NAtom)
      DIMENSION NCI(12),NCJ(12)
      DIMENSION IC3(Natom,3)
      Rtol=Rmin*(1.d0+Tol)
      Mcon2=0
      Do I=1,NAtom
      Do J=1,3
      IC3(I,J)=0
      enddo
      enddo
      if(Ipent.eq.0) then
      Do I=1,MAtom
      Do J=I+1,MAtom
      DM=FunDistMat(I,J,natomL,DistMat)
      If (DM.lt.Rtol) then
      Mcon2=Mcon2+1
      Ncount=I*MAtom+J
      Icon2(Mcon2)=Ncount
      endif
      enddo
      enddo
      else
      Do I=1,MAtom
      Do J=I+1,MAtom
      If (IDA(I,J).eq.1) then
      Mcon2=Mcon2+1
      Ncount=I*MAtom+J
      Icon2(Mcon2)=Ncount
      endif
      enddo
      enddo
      endif
      Write(IOUT,1000) Mcon2
      If(Mcon2.lt.MAtom) then
      Write(IOUT,1004)
      Stop
      endif
      Do I=1,Mcon2,12
      Do J=1,12
      NCI(J)=0
      NCJ(J)=0
      enddo
      M12=12
      Do J=1,12
      IArray=I+J-1
      CALL Num2(MAtom,Icon2(IArray),NCI(J),NCJ(J))
      If(NCI(J).Eq.0) then
      M12=J-1
      Go to 11
      endif
      enddo
   11 Write(IOUT,1001) (NCI(J),NCJ(J),J=1,M12)
      enddo
      Write(IOUT,1002)
C     Get all vertices
      Do I=1,MAtom
      IZ=0
      Do J=1,MCon2
      CALL Num2(MAtom,Icon2(J),IX,IY)
      IF(IX.EQ.I) then
      IZ=IZ+1
      IC3(I,IZ)=IY
      endif
      IF(IY.EQ.I) then
      IZ=IZ+1
      IC3(I,IZ)=IX
      endif
      IF(IZ.EQ.3) Go to 10
      enddo
   10 Continue
      Write(IOUT,1003) I,(IC3(I,J),J=1,3)
      enddo
C     Check if structure is alright at this point
      nexpedge=MAtom*3/2
      if(Mcon2.ne.nexpedge) then
      Write(IOUT,1005) Mcon2,nexpedge
      stop
      endif
 1000 Format(/1X,' Number of connected surface atoms (edges, bonds):',
     1 I4,/1X,' Connectivities (edge set):')
 1001 Format(1X,12('{',I3,',',I3,'} '))
 1002 Format(1X,' Calculate all vertices N and corresponding ',
     1 'adjacencies Ni of 3-connected graph:',
     1 /1X,'   N       N1  N2  N3')
 1003 Format(1X,I4,'    (',3I4,')')
 1004 Format(1X,'**** Error, not enough connected atoms', 
     1 ' check coordinates')
 1005 Format(1X,'**** Severe error, number of edges (bonds) not as ',
     1 'expected from number of atoms: ',I4,' (expected: ',I4,')')
      RETURN
      END
      
      SUBROUTINE Num2(MAtom,IArray,I,J)
      IMPLICIT REAL*8 (A-H,O-Z)
      I=IArray/MAtom
      J=IArray-I*MAtom
      If(J.eq.0) then
      J=MAtom
      I=I-1
      endif
      If(I.eq.-1) then
      I=0
      J=0
      endif
      RETURN
      END

      FUNCTION fpsi(ndim,M,u,dist)
C     Calculate the Lagrangian dual for the minimum sphere problem
      IMPLICIT REAL*8 (A-H,O-Z)
      Dimension u(ndim),dist(3,ndim),x(3)
      sum1=0.d0
      x(1)=0.d0
      x(2)=0.d0
      x(3)=0.d0
      Do i=1,M
      sum1=sum1+u(i)*(dist(1,i)**2+dist(2,i)**2+dist(3,i)**2)
      Do j=1,3
      x(j)=x(j)+u(i)*dist(j,i)
      enddo
      enddo
      sum2=x(1)*x(1)+x(2)*x(2)+x(3)*x(3)
      fpsi=sum1-sum2
      Return
      END

      SUBROUTINE Datain(IN,IOUT,NAtom,Icart,Iopt,iprint,IHam,IPR,
     1 ISchlegel,IS1,IS2,IS3,IER,istop,IOPD,iupac,Ipent,ParamS,TolX)
      IMPLICIT REAL*8 (A-H,O-Z)
      Character DATEN*80
      Namelist /Coord/ Icart,Natom,Iprint
C Input send to output   
      WRITE(IOUT,100)
      DO 10 I=1,200
      READ(IN,'(A80)',END=11) DATEN
   10 WRITE(IOUT,60) DATEN
   11 WRITE(IOUT,101)
      REWIND IN

      IOPD=0    !  Switch for producing the nth dual
      iupac=1   !  Switch for producing the Iupac nomenclature
                !  iupac=0 just count Hamiltonian Cycles
      Ipent=0   !  Initial flag for Spriral pentagon input
      IER=0     !  Error flag
      Tol=0.33d0 ! Tolerance
      iprint=0
      NAtom=60
      ICart=1

C Now process input    
      Read(IN,*) MAtom,Icart,Iopt,iprintf,IHam,IPR,ISchlegel,
     1 IS1,IS2,IS3,ParamS,TolR

C Set Parameters
C  Check on number of atoms (vertices)
      if(IABS(MAtom).gt.natom) WRITE(IOUT,102) MAtom
      if(MAtom.lt.20.or.MAtom.eq.22) then
      Write(IOUT,103) Matom
      IER=1
      return
      endif
      IF (MAtom/2*2.Ne.Matom) then
      Write(IOUT,104) Matom
      IER=1
      return
      endif

C  Output list
      if(iprint.gt.0) then
       WRITE(IOUT,105)
       iprint=1
      endif
      if(iprint.lt.0) then
       iprint=0
       iupac=0
      endif

C  Tolerance for finding 5- and 6-ring connections
      if(TolR.le.0.d0) then
      TolX=Tol
      else
      TolX=TolR*0.01d0
      endif

      istop=0
      if(IPR.le.0) then
        IPR=-1
      endif
      if(IPR.eq.1) then
        if(MAtom.lt.60) IPR=0
      endif
      if(IPR.eq.2) then
        IPR=0
      endif
      if(IPR.eq.3) then
        IPR=1
        istop=1
      endif
      if(IPR.ge.4) then
        IPR=0
        istop=1
      endif

   60 FORMAT(1X,A80)
  100 FORMAT(1X,80(1H-),/1X,'I N P U T ',/1X,5H0....,
     161H....1.........2.........3.........4.........5.........6......,
     214H...7.........8,/1X,39H123456789012345678901234567890123456789,
     341H01234567890123456789012345678901234567890,/)
  101 FORMAT(1X,80(1H-))
  102 FORMAT(1X,' Number of Atoms exceed allowed limit of ',I4,
     1 ' Increase Parameter natom')
  103 FORMAT(1x,'Fullerene with requested number of carbon atoms ',
     1 I4,' not possible')
  104 FORMAT(1x,'Fullerene with odd number of carbon atoms ',
     1 I4,' not possible')
  105 FORMAT(1x,'Larger output requested')
      RETURN
      END

      SUBROUTINE DualAnalyze(NMAX,MMAX,N,M,Iout,D,IRhag5,IRhag6,
     1 IFus5G,IDA,nelec,ndeg,sigmah,A,gap)
      IMPLICIT REAL*8 (A-H,O-Z)
      Integer D(MMAX,MMAX),Ddiag(MMAX),NR5(12),IDA(NMAX,NMAX)
      Integer IRhag5(0:5),IRhag6(0:6),IDG(NMAX)
      Dimension A(NMAX,NMAX),evec(NMAX),df(NMAX)
C     Analyze dual matrix and get pentagon and hexagon indices
C     and determine if molecule is open shell
      Data Tol/1.d-5/
      NV5=0
      NV6=0
      IER=0
      Do I=1,M
       Ddiag(I)=0
       Do J=1,M
        Ddiag(I)=Ddiag(I)+D(J,I)
       enddo
       Itest=Ddiag(I)
       If(Itest.eq.5) then
        NV5=NV5+1
        NR5(NV5)=I
       endif
       If(Itest.eq.6) NV6=NV6+1
      enddo
C     NV=NV5+NV6
C     If(NV.ne.M) Write(Iout,1000)
C     Get Rhagavachari-Fowler-Manolopoulos neighboring pentagon and hexagon indices
C     First pentagon indices
      Do I=0,5
       IRhag5(I)=0
      enddo
      do I=1,12
       IRcount=0
       IRing5=NR5(I)
       do J=1,12
        JRing5=NR5(J)
        If(D(JRing5,IRing5).eq.1) then
         IRcount=IRcount+1
        endif
       enddo
       IRhag5(IRcount)=IRhag5(IRcount)+1
      enddo
      Ifus5=0
      Do I=1,5
       IFus5=IFus5+I*IRhag5(I)
      enddo
      IFus5G=IFus5/2

C     Now hexagon indices
      Do I=0,6
       IRhag6(I)=0
      enddo
      do 10 I=1,M
       IRcount=0
       IR5=Ddiag(I)
       if(IR5.eq.5) go to 10
       do J=1,M
        JR5=Ddiag(J)
        If(JR5.ne.5.and.D(I,J).eq.1) then
         IRcount=IRcount+1
        endif
       enddo
       IRhag6(IRcount)=IRhag6(IRcount)+1
   10 Continue
C     Strain Parameter
      khk=0
      k2hk=0
      Do I=3,6
      ihk=ihk+IRhag6(I)
      IIR=I*IRhag6(I)
      khk=khk+IIR
      k2hk=k2hk+I*IIR
      enddo
      if(ihk.eq.0) go to 112
      aihk=dfloat(ihk)
      akhk2=(dfloat(khk)/aihk)**2
      ak2hk=dfloat(k2hk)/aihk
      sigmah=dsqrt(dabs(ak2hk-akhk2))

C     Now produce adjacency matrix
 112  CALL DUAL(NMAX,D,MMAX,IDA,N,IER)
      Do I=1,N
       df(I)=0.d0
      Do J=I,N
        A(I,J)=0.d0
        if(IDA(I,J).eq.1) A(I,J)=1.d0
        A(J,I)=A(I,J)
      enddo
      enddo
C Diagonalize without producing eigenvectors
      call tred2l(A,N,NMAX,evec,df)
      call tqlil(evec,df,N,NMAX)
C Sort eigenvalues
      Do I=1,N
       e0=evec(I)
       jmax=I
        Do J=I+1,N
         e1=evec(J)
          if(e1.gt.e0) then 
           jmax=j
           e0=e1
          endif
        enddo
        if(i.ne.jmax) then
         ex=evec(jmax)
         evec(jmax)=evec(I)
         evec(I)=ex
        endif
      enddo

C Now sort degeneracies
      df(1)=evec(1)
      ieigv=1
      ideg=1
      IDG(1)=ideg
      Do I=2,N
       diff=dabs(evec(I-1)-evec(I))
       if(diff.lt.Tol) then
        ideg=ideg+1
        IDG(ieigv)=ideg
       else
        ieigv=ieigv+1
        ideg=1
        IDG(ieigv)=ideg
        df(ieigv)=evec(I)
       endif
      enddo
       
C Produce number of electrons in HOMO, degeneracy and gap
      Noc=N/2
      Norb=0
      Do I=1,ieigv
      Iorb=I
      Norb=Norb+IDG(I)
      if(Norb.eq.Noc) then 
      gap=df(Iorb)-df(Iorb+1)
      ndeg=IDG(Iorb)
      nelec=ndeg*2
      go to 111
      endif
      if(Norb.gt.Noc) then 
      gap=df(Iorb)-df(Iorb+1)
      ndeg=IDG(Iorb)
      nelec=(ndeg-Norb+Noc)*2
      go to 111
      endif
      enddo
  111 Continue
      
C1000 Format(1X,'Error: NV5+NN6 does not match total number of '
C    1 'vertices')
C     Write(Iout,1001) NV5,NV6
C     Do I=1,M
C     Write(Iout,1002) (D(I,J),J=1,M)
C     enddo
C     Write(Iout,1002) M,(Ddiag(J),J=1,M)
 1001 Format(1X,'Number of vertices of order five in dual matrix: ',I4,
     1 /1X,'Number of vertices of order six in dual matrix: ',I4)
 1002 Format(1X,60I3)
      Return
      End

      SUBROUTINE Spiral(NMAX,MMAX,LMAX,N,IPR,Iout,
     1 Isonum,IsoIPR,iham,IDA,A)
      IMPLICIT INTEGER (A-Z)
      DIMENSION D(MMAX,MMAX),S(MMAX),IDA(NMAX,NMAX)
      Real*8 A(NMAX,NMAX),gap
      Integer Isonum(119),IsoIPR(123)
      DIMENSION NMR(6),IRhag5(0:5),IRhag6(0:6)
      DIMENSION Spiralx(12,NMAX)
      CHARACTER*3 GROUP
      CHARACTER*6 Occup
      Real*8 sigmah,sigmahlow,sigmahhigh
C     This subroutine comes directly from the book of Fowler and 
C     Manopoulus "An Atlas of Fullerenes" (Dover Publ., New York, 2006).           
C     This sub-program catalogues fullerenes with a given number of      
C     vertices using the spiral algorithm and a uniqueness test 
C     based on equivalent spirals. The required input is IPR, 
C     where IPR = 0 for general and 1 for isolated-pentagon isomers. 
C     The resulting output is a catalogue of the isomers found containing 
C     their idealized point groups, canonical spirals, and NMR patterns.        
C     N is the nuclearity of the fullerene.

      if(N.gt.NMAX) Return            ! Increase NMAX 
      if(2*(N/2).ne.N) Return         ! N must be even 
      M1=N/2-9
      M2=N/2-29
      nhamcycle=0
      IPRdect=0
      maxiter=10000000
      hamlow=2000000000
      IPRhamlow=2000000000
      hamhigh=0
      IPRhamhigh=0
      islow=0
      islowIPR=0
      ishigh=0
      ishighIPR=0
      IPRhamlow=2000000000
      IPRhamhigh=-1
      IFus5Glow=1000
      sigmahlow=1.d10
      IFus5Ghigh=0
      sigmahhigh=-1.d0
      WRITE (Iout,600)
      if(iham.eq.0) then
      if(IPR.EQ.0) then 
         IF(N.lt.100) WRITE(Iout,601) N
         IF(N.ge.100) WRITE(Iout,602) N
      else
         IPR=1 
         IF(N.lt.100) WRITE(Iout,603) N
         IF(N.ge.100) WRITE(Iout,604) N
      endif
      else
      if(IPR.EQ.0) then 
         IF(N.lt.100) WRITE(Iout,701) N
         IF(N.ge.100) WRITE(Iout,702) N
      else
         IPR=1 
         IF(N.lt.100) WRITE(Iout,703) N
         IF(N.ge.100) WRITE(Iout,704) N
      endif
      endif
      do I=1,MMAX
      do J=1,MMAX
      D(I,J)=0
      enddo
      enddo
      L=0
      IER=0
      IT=0
      JPR=IPR+1
      M=N/2+2
      DO 1  J1= 1    ,M-11*JPR !   Open loop over spiral
      DO 2  J2=J1+JPR,M-10*JPR !   combinations
      DO 3  J3=J2+JPR,M-9*JPR
      DO 4  J4=J3+JPR,M-8*JPR
      DO 5  J5=J4+JPR,M-7*JPR
      DO 6  J6=J5+JPR,M-6*JPR
      DO 7  J7=J6+JPR,M-5*JPR
      DO 8  J8=J7+JPR,M-4*JPR
      DO 9  J9=J8+JPR,M-3*JPR
      DO 10 J10=J9+JPR,M-2*JPR
      DO 11 J11=J10+JPR,M-JPR
      DO 12 J12=J11+JPR,M
        DO J=1,M               ! Form spiral code in S
         S(J)=6
        enddo
      S(J1)=5
      S(J2)=5
      S(J3)=5
      S(J4)=5
      S(J5)=5
      S(J6)=5
      S(J7)=5
      S(J8)=5
      S(J9)=5
      S(J10)=5
      S(J11)=5
      S(J12)=5
      CALL Windup(MMAX,M,IPR,IER,S,D)      !      Wind up spiral into dual 
      IF(IER.EQ.12) GO TO 12               !      and check for closure 
      IF(IER.EQ.11) GO TO 11
      IF(IER.EQ.10) GO TO 10
      IF(IER.EQ.9)  GO TO 9
      IF(IER.EQ.8)  GO TO 8
      IF(IER.EQ.7)  GO TO 7
      IF(IER.EQ.6)  GO TO 6
      IF(IER.EQ.5)  GO TO 5
      IF(IER.EQ.4)  GO TO 4
      IF(IER.EQ.3)  GO TO 3
      IF(IER.EQ.2)  GO TO 2
      IF(IER.EQ.1)  GO TO 1
      CALL Unwind(NMAX,MMAX,LMAX,M,IER,IT,ispiral,
     1 Spiralx,S,D,NMR,Group)                            ! Unwind dual into spirals 
      IF(IER.EQ.13) GO TO 13                             ! and check for uniqueness      
      K=0
      L=L+1                                              ! Spiral S is canonical      
      DO J=1,6
         IF(NMR(J).EQ.0) GO TO 16
         K=J
      enddo
C     Analyze dual matrix
   16  CALL DualAnalyze(NMAX,MMAX,N,M,Iout,D,IRhag5,IRhag6,
     1 IFus5G,IDA,nelec,ndeg,sigmah,A,gap)
       if(2*ndeg.eq.nelec) then 
        Occup='closed'
       else
        Occup='open  '
        gap=0.d0
       endif
       if(IFus5G.le.IFus5Glow) then
        IFus5Glow=IFus5G
        IFusL=L
       endif
       if(IFus5G.ge.IFus5Ghigh) then
        IFus5Ghigh=IFus5G
        IFusH=L
       endif
       if(sigmah.le.sigmahlow) then
        sigmahlow=sigmah
        ISigmaL=L
       endif
       if(sigmah.ge.sigmahhigh) then
        sigmahhigh=sigmah
        ISigmaH=L
       endif
       if(iham.eq.0) then
       WRITE(Iout,607) L,GROUP,J1,J2,J3,J4,J5,J6,J7,J8,J9,J10,J11,J12,
     1 (IRhag5(J),J=0,5),IFus5G,(IRhag6(J),J=0,6),sigmah,
     2 nelec,ndeg,gap,Occup,(NMR(J),J=1,K)
       else
        Call HamiltonCyc(NMax,N,maxiter,IDA,nhamcycle)
        WRITE(Iout,608) L,GROUP,J1,J2,J3,J4,J5,J6,J7,J8,J9,J10,J11,J12,
     1   (IRhag5(J),J=0,5),IFus5G,(IRhag6(J),J=0,6),sigmah,
     2   nelec,ndeg,gap,Occup,nhamcycle,(NMR(J),J=1,K)
        if(nhamcycle.le.hamlow) then
         hamlow=nhamcycle
         islow=L
        endif
        if(nhamcycle.ge.hamhigh) then
         hamhigh=nhamcycle
         ishigh=L
        endif
        if(IPR.eq.0.and.IFus5G.eq.0) then
         IPRdect=1
         if(nhamcycle.lt.IPRhamlow) then
          IPRhamlow=nhamcycle
          islowIPR=L
         endif
         if(nhamcycle.gt.IPRhamhigh) then
          IPRhamhigh=nhamcycle
          ishighIPR=L
         endif
        endif
       endif
       if(IPR.eq.0) then
        if(M1.le.119.and.L.eq.Isonum(M1)) go to 99
       else
        if(M2.le.123.and.M2.gt.0.and.L.eq.IsoIPR(M2)) go to 99
      endif
 13     CONTINUE 
 12     CONTINUE        ! Close loop over spiral 
 11     CONTINUE        ! combinations      
 10     CONTINUE
 9      CONTINUE
 8      CONTINUE
 7      CONTINUE
 6      CONTINUE
 5      CONTINUE
 4      CONTINUE
 3      CONTINUE
 2      CONTINUE
 1      CONTINUE 
 99   if(iham.ne.0) then
       WRITE (Iout,609) hamlow,islow,hamhigh,ishigh
       if(IPR.eq.0.and.IPRdect.eq.1) then
        WRITE (Iout,610) IPRhamlow,islowIPR,IPRhamhigh,ishighIPR
       endif
      endif
      WRITE (Iout,611) IFus5Glow,IFusL,IFus5Ghigh,IFusH,
     1  sigmahlow,ISigmaL,sigmahhigh,ISigmaH
      WRITE (Iout,606)
 600  FORMAT(/1X,'Subroutine Spiral from Fowler and Manopoulus',
     1 ' (An Atlas of Fullerenes, Dover Publ., New York, 2006)',
     2 /1X,'(Symmetries are given for undistorted fullerenes)')
 601  FORMAT(1X,'General fullerene isomers of C',I2,':',
     1 ' (Np=0 implies IPR isomer, sigmah is the strain paramter, ',
     1 ' Ne the number of HOMO electrons, deg the HOMO degeneracy, ',
     1 /35x,' and gap the HOMO-LUMO gap in units of beta)',
     2 /8X,'N  PG   Ring spiral pentagon positions',
     3 19X,'Pentagon indices',5x,'Np  Hexagon indices',11x,'Sigmah',
     4 '   Ne  deg  gap    c/o     NMR pattern',
     5 /1X,170('-')) 
 602  FORMAT(1X,'General fullerene isomers of C',I3,':',
     1 ' (Np=0 implies IPR isomer, sigmah is the strain paramter, ',
     1 ' Ne the number of HOMO electrons, deg the HOMO degeneracy, ',
     1 /35x,' and gap the HOMO-LUMO gap in units of beta)',
     2 /8X,'N  PG   Ring spiral pentagon positions',
     3 19X,'Pentagon indices',5x,'Np  Hexagon indices',11x,'Sigmah',
     4 '   Ne  deg  gap    c/o     NMR pattern',
     5 /1X,170('-')) 
 603  FORMAT(1X,'Isolated-pentagon isomers of C',I2,':',
     1 ' (Np=0 implies IPR isomer, sigmah is the strain paramter, ',
     1 ' Ne the number of HOMO electrons, deg the HOMO degeneracy, ',
     1 /35x,' and gap the HOMO-LUMO gap in units of beta)',
     1 /8X,'N  PG   Ring spiral pentagon positions',
     3 19X,'Pentagon indices',5x,'Np  Hexagon indices',11x,'Sigmah',
     4 '   Ne  deg  gap    c/o     NMR pattern',
     5 /1X,170('-')) 
 604  FORMAT(1X,'Isolated-pentagon isomers of C',I3,':',
     1 ' (Np=0 implies IPR isomer, sigmah is the strain paramter, ',
     1 ' Ne the number of HOMO electrons, deg the HOMO degeneracy, ',
     1 /35x,' and gap the HOMO-LUMO gap in units of beta)',
     1 /8X,'N  PG   Ring spiral pentagon positions',
     3 19X,'Pentagon indices',5x,'Np  Hexagon indices',11x,'Sigmah',
     4 '   Ne  deg  gap    c/o     NMR pattern',
     5 /1X,170('-')) 
 605  FORMAT(1X,I8,2X,A3,9X,12I4,2X,3(I3,' x',I3,:,','))
 606  FORMAT(1X,170('-'),/1X,'End of subroutine Spiral')
 607  FORMAT(1X,I8,2X,A3,1X,12I4,2X,'(',5(I2,','),I2,')  ',I2,
     1 2X,'(',6(I2,','),I3,')  ',F8.5,2X,I2,1X,I2,1X,F8.5,
     1 1X,A6,2X,3(I3,' x',I3,:,','))
 608  FORMAT(1X,I8,2X,A3,1X,12I4,2X,'(',5(I2,','),I2,')  ',I2,
     1 2X,'(',6(I2,','),I3,')  ',F8.5,2X,I2,1X,I2,1X,F8.5,
     1 1X,A6,2X,I9,2X,3(I3,' x',I3,:,','))
 609  FORMAT(1X,'Lowest number of Hamiltonian cycles     ',I10,
     1 ' for isomer ',I10,
     1      /1X,'Highest number of Hamiltonian cycles    ',I10,
     1 ' for isomer ',I10)
 610  FORMAT(1X,'Lowest number of IPR Hamiltonian cycles ',I10,
     1 ' for isomer ',I10,
     1      /1X,'Highest number of IPR Hamiltonian cycles',I10,
     1 ' for isomer ',I10)
 611  FORMAT(1X,'Lowest  Np= ',I3,' for isomer ',I10,
     1      /1X,'Highest Np= ',I3,' for isomer ',I10,
     1      /1X,'Lowest  Sigmah= ',F8.5,' for isomer ',I10,
     1      /1X,'Highest Sigmah= ',F8.5,' for isomer ',I10)
 701  FORMAT(1X,'General fullerene isomers of C',I2,':',
     1 ' (Np=0 implies IPR isomer, sigmah is the strain paramter, ',
     1 ' Ne the number of HOMO electrons, deg the HOMO degeneracy, ',
     1 /35x,' gap the HOMO-LUMO gap in units of beta, and NHamCyc the ',
     1 ' number of Hamiltonian cycles)',
     2 /8X,'N  PG   Ring spiral pentagon positions',
     3 19X,'Pentagon indices',5x,'Np  Hexagon indices',11x,'Sigmah',
     4 '   Ne  deg  gap    c/o     NHamCyc   NMR pattern',
     5 /1X,170('-')) 
 702  FORMAT(1X,'General fullerene isomers of C',I3,':',
     1 ' (Np=0 implies IPR isomer, sigmah is the strain paramter, ',
     1 ' Ne the number of HOMO electrons, deg the HOMO degeneracy, ',
     1 /35x,' gap the HOMO-LUMO gap in units of beta, and NHamCyc the ',
     1 ' number of Hamiltonian cycles)',
     2 /8X,'N  PG   Ring spiral pentagon positions',
     3 19X,'Pentagon indices',5x,'Np  Hexagon indices',11x,'Sigmah',
     4 '   Ne  deg  gap    c/o     NHamCyc   NMR pattern',
     5 /1X,170('-')) 
 703  FORMAT(1X,'Isolated-pentagon isomers of C',I2,':',
     1 ' (Np=0 implies IPR isomer, sigmah is the strain paramter, ',
     1 ' Ne the number of HOMO electrons, deg the HOMO degeneracy, ',
     1 /35x,' gap the HOMO-LUMO gap in units of beta, and NHamCyc the ',
     1 ' number of Hamiltonian cycles)',
     1 /8X,'N  PG   Ring spiral pentagon positions',
     3 19X,'Pentagon indices',5x,'Np  Hexagon indices',11x,'Sigmah',
     4 '   Ne  deg  gap    c/o     NHamCyc   NMR pattern',
     5 /1X,170('-')) 
 704  FORMAT(1X,'Isolated-pentagon isomers of C',I3,':',
     1 ' (Np=0 implies IPR isomer, sigmah is the strain paramter, ',
     1 ' Ne the number of HOMO electrons, deg the HOMO degeneracy, ',
     1 /35x,' gap the HOMO-LUMO gap in units of beta, and NHamCyc the ',
     1 ' number of Hamiltonian cycles)',
     1 /8X,'N  PG   Ring spiral pentagon positions',
     3 19X,'Pentagon indices',5x,'Np  Hexagon indices',11x,'Sigmah',
     4 '   Ne  deg  gap    c/o     NHamCyc   NMR pattern',
     5 /1X,170('-')) 
      Return
      END

      SUBROUTINE Windup(MMAX,M,IPR,IER,S,D)
      IMPLICIT INTEGER (A-Z)
      DIMENSION S(MMAX),D(MMAX,MMAX)
      DIMENSION R(MMAX),C(MMAX,6)
C       This subroutine attempts to wind up an input spiral S into
C       a fullerene dual (face) adjacency matrix D. It returns with      
C       IER = P if the spiral shorts or is discovered to be open-ended      
C       after P pentagons have been added. Otherwise IER = 0 on return.
      J=1
      C(1,1)=2
      C(2,1)=1
      R(1)=2
      R(2)=2
      E=1
      P=12-S(1)-S(2)
      DO 5 K=3,M-1
         P=P+6-S(K)
         R(K)=1
         I=K-1
 1       IF(IPR.EQ.1.AND.S(I).EQ.5.AND.S(K).EQ.5) GO TO 10      
         IF(R(K).GE.S(K)) GO TO 10      
         C(I,R(I))=K    ! Connect face K to the last open face I
         C(K,R(K))=I    ! in the preceding spiral      
         R(I)=R(I)+1
         R(K)=R(K)+1
         IF(R(I).GT.S(I)) THEN
            L=I-1              ! If this closes face I update I and go
            DO I=L,J+1,-1    ! back to connect face K to the new I      
             IF(R(I).LE.S(I)) GO TO 1
            enddo
            GO TO 10
         ENDIF
 3       IF(IPR.EQ.1.AND.S(J).EQ.5.AND.S(K).EQ.5) GO TO 10
         IF(R(K).GE.S(K)) GO TO 10
         C(J,R(J))=K    ! Connect face K to the first open face J
         C(K,R(K))=J    ! in the preceding spiral 
         R(J)=R(J)+1
         R(K)=R(K)+1
         IF (R(J).GT.S(J)) THEN
            L=J+1              ! If this closes face J update J and go
            DO J=L,I-1,+1      ! back to connect face K to the new J 
             IF(R(J).LE.S(J)) GO TO 3
            enddo
            GO TO 10
         ENDIF
         H=K-P
         E=E+R(K)-1     ! Use Euler's theorem to streamline the 
         V=3+2*P+3*H-E  ! search. F is a lower bound on the # of 
         F=(V+1)/2+1    ! additional faces required for closure 
         IF(F.GT.M-K) GO TO 10
 5    CONTINUE
      P=12
      R(M)=1
      DO 6 K=J,M-1
         IF (R(K).LT.S(K)) GO TO 10
         IF (R(K).GT.S(K)) GO TO 6
         IF (R(M).GT.S(M)) GO TO 10
         IF (IPR.EQ.1.AND.S(K).EQ.5.AND.S(M).EQ.5) GO TO 10
         C(K,R(K))=M    ! Connect face M to all remaining
         C(M,R(M))=K    ! open faces (including face M-1)
         R(K)=R(K)+1
         R(M)=R(M)+1
 6    CONTINUE
      IF(R(M).LE.S(M)) GO TO 10
      P=0               ! Successful spiral
      DO J=1,M        ! Form dual adjacency matrix in D
         DO I=1,M
            D(I,J)=0
         enddo
         DO K=1,S(J)
            I=C(J,K)
            D(I,J)=1
         enddo
      enddo
 10   IER=P
      RETURN
      END

      SUBROUTINE Unwind(NMAX,MMAX,LMAX,M,IER,IT,ispiral,
     1 Spiral,S,D,NMR,GROUP)
      IMPLICIT INTEGER (A-Z)
      DIMENSION D(MMAX,MMAX),S(MMAX),NMR(6)
      DIMENSION P(MMAX),R(MMAX)
      DIMENSION V(3,NMAX),E(2,LMAX)
      DIMENSION VP(NMAX,MMAX),EP(LMAX,MMAX),FP(MMAX,MMAX)
      DIMENSION MV(12),ME(12),MF(12),MS(12),Spiral(12,NMAX)
      CHARACTER*3 GROUP
C       This subroutine unwinds a fullerene dual adjacency matrix D 
C       into each of its constituent spirals and checks that none has      
C       a lexicographically smaller code than the input spiral S. The 
C       idealized point group and NMR signature of the fullerene are      
C       also calculated if this test is passed, in which case the      
C       spiral is canonical and IER = 0 on return. Otherwise IER = 13.
C       IF IT=0 this option is supressed as noncanonical spirals are
C       analyzed as well.      
      SO=0
      ispiral=0
      DO 10 I1=1,M      ! Begin multiple loop over all      
         P(1)=I1        ! 6*N possible spiral starts 
         FLAG1=0        ! with initial faces I1,I2,I3      
         IF (S(P(1)).NE.S(1)) THEN
            IF (S(P(1)).GT.S(1)) GO TO 10
            FLAG1=1
         ENDIF
         DO 9 I2=1,M
            IF(D(I1,I2).EQ.0) GO TO 9     
            P(2)=I2
            FLAG2=FLAG1
            IF(FLAG2.EQ.0.AND.S(P(2)).NE.S(2)) THEN
                 IF(S(P(2)).GT.S(2)) GO TO 9
                 FLAG2=2
            ENDIF
            DO 8 I3=1,M
           IF(D(I1,I3).EQ.0.OR.D(I2,I3).EQ.0) GO TO 8
           IF(SO.EQ.0) THEN
              SO=1        !     Store a face permutation for
              DO K=1,M    !     each symmetry operation in FP, 
               FP(K,SO)=K !     with the identity operation 
              enddo       !     (here) in column 1      
              GO TO 8
           ENDIF
           P(3)=I3
           FLAG3=FLAG2
           IF(FLAG3.EQ.0.AND.S(P(3)).NE.S(3)) THEN
              IF(S(P(3)).GT.S(3)) GO TO 8
              FLAG3=3
           ENDIF
           DO J=1,M
              R(J)=0
           enddo
           R(P(1))=2
           R(P(2))=2
           R(P(3))=2
           I=1
         DO 6 J=4,M
 3            IF(R(P(I)).EQ.S(P(I))) THEN
                 I=I+1
                 IF(I.EQ.J-1) GO TO 8
                 GO TO 3
              ENDIF
                 IFX=P(I)    !  These are the first (IF)      
                 IL=P(J-1)   !  and last (IL) open faces      
                 DO 5 IJ=1,M !  in the preceding spiral 
                IF (D(IJ,IFX).EQ.0.OR.D(IJ,IL).EQ.0) GO TO 5
                IF (R(IJ).GT.0) GO TO 5
                P(J)=IJ
                IF (FLAG3.EQ.0.AND.S(P(J)).NE.S(J)) THEN
                   IF (S(P(J)).GT.S(J)) GO TO 8
                   FLAG3=J    ! This spiral has a smaller      
                ENDIF         ! code than S, but it may not      
                DO 4 K=1,J-1  ! close properly. Flag it      
                   IF (D(P(J),P(K)).EQ.1) THEN
                  R(P(J))=R(P(J))+1
                  R(P(K))=R(P(K))+1
                   ENDIF
 4            CONTINUE
                GO TO 6
 5             CONTINUE
                 GO TO 8
 6          CONTINUE
              IF (FLAG3.EQ.0) THEN
                 SO=SO+1      ! Arrive here once for each 
                 DO 7 K=1,M   ! spiral with the same code as 
                FP(K,SO)=P(K) ! S, which is once for each 
 7             CONTINUE       ! symmetry operation SO      
              ELSE
                 If(IT.eq.0) then
                 IER=13       ! The flagged spiral has closed, 
                 RETURN       ! so call it a day  
                 endif    
              ENDIF
C            Store all non-identical spirals
             If(IT.ne.0) then
             ISP=0
             ispiral=ispiral+1
             Do II=1,M
             IF(S(P(II)).eq.5) then
             ISP=ISP+1
             Spiral(ISP,ispiral)=II
             endif
             enddo
             Do II=1,ispiral-1
             nv=0
             Do JJ=1,12
             nv=nv+iabs(Spiral(JJ,II)-Spiral(JJ,ispiral))
             if(Spiral(JJ,ispiral).eq.0) go to 86
             if(JJ.ne.1) then
             ndif=Spiral(JJ-1,ispiral)-Spiral(JJ,ispiral)
             if(ndif.eq.0) go to 86
             endif
             enddo
             if(nv.eq.0) go to 86
             enddo
             go to 87
 86          ispiral=ispiral-1
 87          continue
             endif
 8           CONTINUE
 9            CONTINUE
 10            CONTINUE
         IER=0      !         Spiral S is canonical, and 
         ORDER=SO   !         SO is the point group order.
         N=0        !         Now calculate GROUP and NMR: 
         L=0
         DO 13 K=2,M
            DO 12 J=1,K-1
           IF (D(J,K).EQ.0) GO TO 12
           DO 11 I=1,J-1
              IF (D(I,J).EQ.0.OR.D(I,K).EQ.0) GO TO 11
              N=N+1
              V(1,N)=I    ! Associate the three mutually 
              V(2,N)=J    ! adjacent faces I,J,K 
              V(3,N)=K    ! with vertex N 
 11      CONTINUE
           L=L+1
           E(1,L)=J    ! And the two mutually adjacent 
           E(2,L)=K    ! faces J,K with edge L 
 12     CONTINUE
 13    CONTINUE
       DO 18 SO=1,ORDER
         DO 15 J=1,N
           J1=FP(V(1,J),SO)
           J2=FP(V(2,J),SO)
           J3=FP(V(3,J),SO)
           I1=MIN(J1,J2,J3)
           I3=MAX(J1,J2,J3)
           I2=J1+J2+J3-I1-I3
           DO 14 I=1,N
              IF (V(1,I).EQ.I1.AND.V(2,I).EQ.I2.AND.V(3,I).EQ.I3) THEN 
                 VP(J,SO)=I ! Store a vertex permutation for 
                 GO TO 15   ! each symmetry operation in VP
              ENDIF
 14         CONTINUE
 15    CONTINUE
       DO 17 J=1,L
           J1=FP(E(1,J),SO)
           J2=FP(E(2,J),SO)
           I1=MIN(J1,J2)
           I2=J1+J2-I1
           DO 16 I=1,L
              IF(E(1,I).EQ.I1.AND.E(2,I).EQ.I2) THEN
                 EP(J,SO)=I ! And similarly an edge permutation 
                 GO TO 17   ! in EP
              ENDIF
 16         CONTINUE
 17     CONTINUE
 18    CONTINUE
         DO 19 K=1,12
            MV(K)=0
            ME(K)=0
            MF(K)=0
 19      CONTINUE
         DO 21 J=1,N
            IF (VP(J,1).EQ.0) GO TO 21
            VP(J,1)=0
            K=1
            DO 20 SO=2,ORDER
              I=VP(J,SO)
              IF(VP(I,1).EQ.0) GO TO 20
              VP(I,1)=0
              K=K+1
 20         CONTINUE
            K=ORDER/K        ! Count vertex orbits with 
            MV(K)=MV(K)+1    ! site group order K in MV(K)      
 21      CONTINUE
         DO 22 J=1,N
            VP(J,1)=J
 22         CONTINUE
         DO 24 J=1,L
            IF (EP(J,1).EQ.0) GO TO 24
            EP(J,1)=0
            K=1
         DO 23 SO=2,ORDER
           I=EP(J,SO)
           IF(EP(I,1).EQ.0) GO TO 23
           EP(I,1)=0
           K=K+1
 23      CONTINUE
            K=ORDER/K        ! And edge orbits with 
            ME(K)=ME(K)+1    ! site group order K in ME(K)      
 24         CONTINUE
         DO 25 J=1,L
            EP(J,1)=J
 25         CONTINUE
         DO 27 J=1,M
            IF (FP(J,1).EQ.0) GO TO 27
            FP(J,1)=0
            K=1
         DO 26 SO=2,ORDER
           I=FP(J,SO)
           IF(FP(I,1).EQ.0) GO TO 26
           FP(I,1)=0
           K=K+1
 26      CONTINUE
            K=ORDER/K      ! And face orbits with
            MF(K)=MF(K)+1  ! site group order K in MF(K)
 27         CONTINUE
         DO 28 J=1,M
            FP(1,J)=J
 28         CONTINUE
         DO 29 K=1,12                !  And ALL special point orbits
            MS(K)=MV(K)+ME(K)+MF(K)  !  with site group order K in MS(K)
 29         CONTINUE
         DO 30 J=1,6
            NMR(J)=0
 30         CONTINUE
         J=0
         DO 31 K=6,1,-1              ! Use the vertex orbit counts
            IF (MV(K).EQ.0) GO TO 31 ! to calculate the NMR pattern
            J=J+1
            NMR(J)=MV(K)
            J=J+1
            NMR(J)=ORDER/K
 31         CONTINUE
         GROUP='???'                 !  And, finally, the full
         IF (ORDER.EQ.1) THEN        !  special point orbit counts
            GROUP = ' C1'            !  (in conjunction with the
         ELSE IF (ORDER .EQ. 2) THEN !  point group order) to assign
            IF (MS(2).EQ.0) THEN     !  the point group
           GROUP = ' Ci'
            ELSE IF (MS(2).EQ.2) THEN
           GROUP = ' C2'
            ELSE IF (MS(2).GT.2) THEN
           GROUP = ' Cs'
           ENDIF
         ELSE IF (ORDER.EQ.3) THEN
            GROUP = ' C3'
         ELSE IF (ORDER.EQ.4) THEN
            IF (MS(4).EQ.0) THEN
           IF (MS(2) .EQ. 1) THEN
              GROUP = ' S4'
           ELSE IF (MS(2).EQ.3) THEN
              GROUP = ' D2'
           ELSE IF (MS(2).GT.3) THEN
              GROUP = 'C2h'
           ENDIF
            ELSE IF (MS(4).EQ.2) THEN
           GROUP = 'C2v'
            ENDIF
         ELSE IF (ORDER.EQ.6) THEN
            IF (MS(6).EQ.0) THEN
           IF (MS(2).EQ.0) THEN
              GROUP = ' S6'
           ELSE IF (MS(2).EQ.2) THEN
              GROUP = ' D3'
           ELSE IF (MS(2).GT.2) THEN
              GROUP = 'C3h'
           ENDIF
            ELSE IF (MS(6).EQ.2) THEN
           GROUP = 'C3v'
            ENDIF
         ELSE IF (ORDER.EQ.8) THEN
            IF (MS(4).EQ.1) THEN
           GROUP = 'D2d'
            ELSE IF (MS(4).EQ.3) THEN
           GROUP = 'D2h'
            ENDIF
         ELSE IF (ORDER.EQ.10) THEN
            GROUP = ' D5'
         ELSE IF (ORDER.EQ.12) THEN
            IF (MS(6).EQ.0) THEN
           GROUP ='  T'
            ELSE IF (MS(6).EQ.1) THEN
           IF (MS(4).EQ.0) THEN
              IF (MS(2).EQ.2) THEN
                 GROUP = ' D6'
              ELSE IF (MS(2).GT.2) THEN
                 GROUP = 'D3d'
              ENDIF
           ELSE IF (MS(4).EQ.2) THEN
              GROUP = 'D3h'
           ENDIF
            ENDIF
         ELSE IF (ORDER.EQ.20) THEN
            IF (MS(4).EQ.0) THEN
           GROUP = 'D5d'
            ELSE IF (MS(4).EQ.2) THEN
           GROUP = 'D5h'
            ENDIF
         ELSE IF (ORDER.EQ.24) THEN
            IF (MS(12).EQ.0) THEN
           IF (MS(6).EQ.0) THEN
              GROUP = ' Th'
           ELSE IF (MS(6) .EQ. 2) THEN
              GROUP = ' Td'
          ENDIF
           ELSE IF (MS(12) .EQ. 1) THEN
          IF (MS(4).EQ.0) THEN
             GROUP = 'D6d'
          ELSE IF (MS(4) .EQ. 2) THEN
             GROUP = 'D6h'
          ENDIF
           ENDIF 
        ELSE IF (ORDER.EQ.60) THEN
           GROUP ='  I'
        ELSE IF (ORDER.EQ.120) THEN
           GROUP = ' Ih'
        ENDIF
        RETURN
        END

      SUBROUTINE DUAL(NMAX,D,M,A,N,IER) 	 
      IMPLICIT INTEGER (A-Z)
	DIMENSION D(M,M),A(NMAX,NMAX)
	DIMENSION V(3,NMAX)
c       Given a fullerene dual adjacency matrix D, this subroutine 
c       constructs the corresponding fullerene adjacency matrix A. 
c       IER = 0 on return if the construction is successful. 	 
	I=0 	 
	DO 3 L = 1,M 
	   DO 2 K=1,L 
	      IF (D(K,L).EQ.0) GO TO 2 		 
	      DO 1 J = 1,K
		 IF (D(J,K).EQ.0.OR.D(J,L).EQ.0) GO TO 1 	 
		 I = I+1 
		 IF (I.GT.N) GO TO 1
		 V(1,I) = J ! Associate the three mutually adjacent 
		 V(2,I) = K ! dual vertices (fullerene faces) J,K,L 
		 V(3,I) = L ! with fullerene vertex I 	 
 1	      CONTINUE 	 
 2	   CONTINUE 	 
 3	CONTINUE 	 
	IER = I-N 
	IF (IER .NE. 0) RETURN ! D contains IER > 0 separating triangles 
	DO 7 J = 1,N           ! and is therefore NOT a fullerene dual 	 
	   DO 6 I = 1,J
	      K = 0 	 
	      DO 5 JJ = 1,3
		 DO 4 II = 1,3
		    IF(V(II,I).EQ.V(JJ,J)) K = K+1	 
 4		 CONTINUE 	 
 5	      CONTINUE 
	      IF (K.EQ.2) THEN 
		 A(I,J)=1   ! Fullerene vertices I and J are adjacent 
		 A(J,I)=1   ! if they have 2 dual vertices in common
	      ELSE 			 
		 A(I,J)=0
		 A(J,I)=0
	      ENDIF
 6	   CONTINUE 			 
 7	CONTINUE 			 
	RETURN 			 
	END
 			 
      SUBROUTINE tred2l(a,n,np,d,e)
      IMPLICIT REAL*8 (A-H,O-Z)
      REAL*8 a(np,np),d(np),e(np)
C     a: real symmetric matrix of dimension n
C     np: dimension of array
      do 18 i=n,2,-1
        l=i-1
        h=0.d0
        scale=0.
        if(l.gt.1)then
          do 11 k=1,l
            scale=scale+dabs(a(i,k))
11        continue
          if(scale.eq.0.d0)then
            e(i)=a(i,l)
          else
            do 12 k=1,l
              a(i,k)=a(i,k)/scale
              h=h+a(i,k)**2
12          continue
            f=a(i,l)
            g=-sign(dsqrt(h),f)
            e(i)=scale*g
            h=h-f*g
            a(i,l)=f-g
            f=0.
            do 15 j=1,l
              g=0.
              do 13 k=1,j
                g=g+a(j,k)*a(i,k)
13            continue
              do 14 k=j+1,l
                g=g+a(k,j)*a(i,k)
14            continue
              e(j)=g/h
              f=f+e(j)*a(i,j)
15          continue
            hh=f/(h+h)
            do 17 j=1,l
              f=a(i,j)
              g=e(j)-hh*f
              e(j)=g
              do 16 k=1,j
                a(j,k)=a(j,k)-f*e(k)-g*a(i,k)
16            continue
17          continue
          endif
        else
          e(i)=a(i,l)
        endif
        d(i)=h
18    continue
      e(1)=0.d0
      do 24 i=1,n
        d(i)=a(i,i)
24    continue
      return
      END

      SUBROUTINE tqlil(d,e,n,np)
      IMPLICIT REAL*8 (A-H,O-Z)
      REAL*8 d(np),e(np)
      do 11 i=2,n
        e(i-1)=e(i)
11    continue
      e(n)=0.
      do 15 l=1,n
        iter=0
1       do 12 m=l,n-1
          dd=dabs(d(m))+dabs(d(m+1))
          if (dabs(e(m))+dd.eq.dd) goto 2
12      continue
        m=n
2       if(m.ne.l)then
          if(iter.eq.300) then
          Print*,' ERROR: Too many iterations in tqlil'
          return
          endif
          iter=iter+1
          g=(d(l+1)-d(l))/(2.*e(l))
          r=dsqrt(g*g+1.d0)
          g=d(m)-d(l)+e(l)/(g+sign(r,g))
          s=1.
          c=1.
          p=0.
          do 14 i=m-1,l,-1
            f=s*e(i)
            b=c*e(i)
            r=dsqrt(g*g+f*f)
            e(i+1)=r
            if(r.eq.0.d0)then
              d(i+1)=d(i+1)-p
              e(m)=0.
              goto 1
            endif
            s=f/r
            c=g/r
            g=d(i+1)-p
            r=(d(i)-g)*s+2.*c*b
            p=s*r
            d(i+1)=g+p
            g=c*r-b
14        continue
          d(l)=d(l)-p
          e(l)=g
          e(m)=0.d0
          goto 1
        endif
15    continue
      return
      END

      SUBROUTINE tred2(a,n,np,d,e)
      IMPLICIT REAL*8 (A-H,O-Z)
      REAL*8 a(np,np),d(np),e(np)
C     a: real symmetric matrix of dimension n
C     np: dimension of array
      do 18 i=n,2,-1
        l=i-1
        h=0.d0
        scale=0.d0
        if(l.gt.1)then
          do 11 k=1,l
            scale=scale+dabs(a(i,k))
11        continue
          if(scale.eq.0.d0)then
            e(i)=a(i,l)
          else
            do 12 k=1,l
              a(i,k)=a(i,k)/scale
              h=h+a(i,k)**2
12          continue
            f=a(i,l)
            g=-sign(dsqrt(h),f)
            e(i)=scale*g
            h=h-f*g
            a(i,l)=f-g
            f=0.
            do 15 j=1,l
              a(j,i)=a(i,j)/h
              g=0.d0
              do 13 k=1,j
                g=g+a(j,k)*a(i,k)
13            continue
              do 14 k=j+1,l
                g=g+a(k,j)*a(i,k)
14            continue
              e(j)=g/h
              f=f+e(j)*a(i,j)
15          continue
            hh=f/(h+h)
            do 17 j=1,l
              f=a(i,j)
              g=e(j)-hh*f
              e(j)=g
              do 16 k=1,j
                a(j,k)=a(j,k)-f*e(k)-g*a(i,k)
16            continue
17          continue
          endif
        else
          e(i)=a(i,l)
        endif
        d(i)=h
18    continue
      d(1)=0.d0
      e(1)=0.d0
      do 24 i=1,n
        l=i-1
        if(d(i).ne.0.)then
          do 22 j=1,l
            g=0.d0
            do 19 k=1,l
              g=g+a(i,k)*a(k,j)
19          continue
            do 21 k=1,l
              a(k,j)=a(k,j)-g*a(k,i)
21          continue
22        continue
        endif
        d(i)=a(i,i)
        a(i,i)=1.
        do 23 j=1,l
          a(i,j)=0.d0
          a(j,i)=0.d0
23      continue
24    continue
      return
      END

      SUBROUTINE tqli(d,e,n,np,z)
      IMPLICIT REAL*8 (A-H,O-Z)
      REAL*8 d(np),e(np),z(np,np)
c	-------------------------------------------
c	QL Algorithm with implicit shifts, to determine the 
c	eigenvalues and eigenvectors of a real, symmetric, tridiagonal matrix
c	D: The N diagonal elements of the matrix.
c	E: Subdiagonal elements of the matrix, with e(1) arbitrary.
c          (On output is destroyed).
c	For eigenvectors: Z must be the identity matrix. 
c	   On output the kth column returns the normalized eigenvector
c	   corresponding to d(k)
      do 11 i=2,n
        e(i-1)=e(i)
11    continue
      e(n)=0.d0
      do 15 l=1,n
        iter=0
1       do 12 m=l,n-1
          dd=dabs(d(m))+dabs(d(m+1))
          if (dabs(e(m))+dd.eq.dd) goto 2
12      continue
        m=n
2       if(m.ne.l)then
          if(iter.eq.300) then
          Print*,' ERROR: Too many iterations in tqli'
          return
          endif
          iter=iter+1
          g=(d(l+1)-d(l))/(2.*e(l))
          r=dsqrt(g*g+1.d0)
          g=d(m)-d(l)+e(l)/(g+sign(r,g))
          s=1.
          c=1.
          p=0.d0
          do 14 i=m-1,l,-1
            f=s*e(i)
            b=c*e(i)
            r=dsqrt(g*g+f*f)
            e(i+1)=r
            if(r.eq.0.)then
              d(i+1)=d(i+1)-p
              e(m)=0.d0
              goto 1
            endif
            s=f/r
            c=g/r
            g=d(i+1)-p
            r=(d(i)-g)*s+2.*c*b
            p=s*r
            d(i+1)=g+p
            g=c*r-b
            do 13 k=1,n
              f=z(k,i+1)
              z(k,i+1)=s*z(k,i)+c*f
              z(k,i)=c*z(k,i)-s*f
13          continue
14        continue
          d(l)=d(l)-p
          e(l)=g
          e(m)=0.d0
          goto 1
        endif
15    continue
      return
      END

      SUBROUTINE frprmn(NMAX,NMAX3,N,MMAX,AH,Iout,N5,N6,N5M,N6M,
     1 p,force,ftol,iter,fret)
      IMPLICIT REAL*8 (A-H,O-Z)
      PARAMETER (ITMAX=500,EPS=1.d-10)
      Real*8 p(NMAX3),g(NMAX3),h(NMAX3),xi(NMAX3)
      Real*8 pcom(NMAX3),xicom(NMAX3),force(8)
      Integer AH(NMAX,NMAX),N5M(MMAX,5),N6M(MMAX,6)
C     Given a starting point p that is a vector of length n, Fletcher-Reeves-Polak-Ribiere minimization
C     is performed on a function func, using its gradient as calculated by a routine dfunc.
C     The convergence tolerance on the function value is input as ftol. Returned quantities are
C     p (the location of the minimum), iter (the number of iterations that were performed),
C     and fret (the minimum value of the function). The routine linmin is called to perform
C     line minimizations. AH is the Hueckel adjacency matrix of atoms.
C     Parameters: NMAX is the maximum anticipated value of n; ITMAX is the maximum allowed
C     number of iterations; EPS is a small number to rectify special case of converging to exactly
C     zero function value.
C     USES dfunc,func,linmin
C     func input vector p of length n user defined to be optimized
C     In force the Wu force field parameters are defined
      iter=0
      Write(Iout,1003) (force(i),i=1,8),ftol
      CALL func(NMAX,NMAX3,MMAX,N,IERR,AH,N5,N6,N5M,N6M,p,fp,force)
      if(IERR.ne.0) then
      Write(Iout,1004)
      return
      endif
C     dfunc input vector p of length N, output gradient of length n user defined
      CALL dfunc(NMAX,NMAX3,MMAX,N,AH,N5,N6,N5M,N6M,p,xi,force)
      grad2=0.d0
      do I=1,N
       grad2=grad2+xi(i)*xi(i)
      enddo
      grad=dsqrt(grad2)
      Write(Iout,1001) iter,fp,grad
      if(grad.lt.ftol) return
      do j=1,N
        g(j)=-xi(j)
        h(j)=g(j)
        xi(j)=h(j)
      enddo
        fret=0.d0
      do its=1,ITMAX
        iter=its
        call linmin(NMAX,NMAX3,MMAX,N,AH,N5,N6,N5M,N6M,its,
     1   p,pcom,xi,xicom,fret,force)
         grad2=0.d0
         do I=1,n
          grad2=grad2+xi(i)*xi(i)
         enddo
         grad=dsqrt(grad2)
        Write(Iout,1001) iter,fret,grad
        if(2.d0*dabs(fret-fp).le.ftol*(dabs(fret)+dabs(fp)+EPS))then
          Write(Iout,1002) fret,fret-fp
          return
        endif
        fp=fret
        CALL dfunc(NMAX,NMAX3,MMAX,N,AH,N5,N6,N5M,N6M,p,xi,force)
        gg=0.d0
        dgg=0.d0
        do j=1,n
          gg=gg+g(j)**2
C         dgg=dgg+xi(j)**2
          dgg=dgg+(xi(j)+g(j))*xi(j)
        enddo
        if(gg.eq.0.d0)return
        gam=dgg/gg
        do j=1,n
          g(j)=-xi(j)
          h(j)=g(j)+gam*h(j)
          xi(j)=h(j)
        enddo   
      enddo
      Write(Iout,1000) fret,fret-fp
 1000 Format(' WARNING: Subroutine frprmn: maximum iterations exceeded',
     1 /1X,'energy ',F15.9,', diff= ',D12.3)
 1001 Format(' Iteration ',I3,', energy ',F15.9,', gradient ',F12.6)
 1002 Format(/1X,'Convergence achieved, energy ',F15.9,', diff= ',D12.3)
 1003 Format(' Force field parameters: ',8F12.6,', Tolerance= ',D9.3,/)
 1004 Format('**** Severe error in angle, check input coordiantes:',
     1 ' One angle either 0 or 180 degrees, ill-alligned structure',
     1 /1X,'Cannot optimize structure, check eigenvector input')
      return
      END

      SUBROUTINE linmin(NMAX,NMAX3,MMAX,n,AH,N5,N6,N5M,N6M,its,
     1 p,pcom,xi,xicom,fret,c)
      IMPLICIT REAL*8 (A-H,O-Z)
      REAL*8 p(NMAX3),pcom(NMAX3),xicom(NMAX3),xi(NMAX3),c(8)
      Integer AH(NMAX,NMAX)
      Integer N5M(MMAX,5),N6M(MMAX,6)
      PARAMETER (TOL=1.d-4)
C     USES brent,f1dim,mnbrak
      do j=1,n
        pcom(j)=p(j)
        xicom(j)=xi(j)
      enddo
      ax=0.d0
      xx=1.d0
      CALL mnbrak(NMAX,NMAX3,MMAX,n,AH,N5,N6,N5M,N6M,
     1 ax,xx,bx,fa,fx,fb,xicom,pcom,c)
      CALL brent(NMAX,NMAX3,MMAX,n,AH,N5,N6,N5M,N6M,Iout,fret,
     1 ax,xx,bx,TOL,xmin,xicom,pcom,c)
      do j=1,n
        xi(j)=xmin*xi(j)
        p(j)=p(j)+xi(j)
      enddo
      return
      END

      SUBROUTINE func(NMAX,NMAX3,MMAX,n,IERR,A,N5,N6,N5M,N6M,p,fc,c)
      IMPLICIT REAL*8 (A-H,O-Z)
C     Calculates the harmonic oscillator potential of power npower
C     and strength force using the Hueckel adjacency
C     matrix A and adds a Coulomb repulsion of strength coulomb
C     for all non-connected atoms
      Real*8 p(NMAX3),c(8)
      Integer A(NMAX,NMAX)
      Integer N5M(MMAX,5),N6M(MMAX,6)
      IERR=0
      rp=c(1)
      rh=c(2)
      ap=c(3)
      ah=c(4)
      frp=c(5)
      frh=c(6)
      fap=c(7)
      fah=c(8)
C     Stretching
      ehookrp=0.d0
      ehookrh=0.d0
      Do I=1,n,3
      Do J=I+3,n,3
        I1=(I+2)/3
        J1=(J+2)/3
        if(A(I1,J1).ne.0) then
         px=p(I)-p(J)
         py=p(I+1)-p(J+1)
         pz=p(I+2)-p(J+2)
         ratom=dsqrt(px*px+py*py+pz*pz)
         ratominv=1.d0/ratom
C        Check if bond is part of 5-ring
         ibond=6
          do IB=1,12
           ir1=0
           ir2=0
           do JB=1,5
            if(I1.eq.N5M(IB,JB)) ir1=1
            if(J1.eq.N5M(IB,JB)) ir2=1
           enddo
            if(ir1.eq.1.and.ir2.eq.1) then
C           5-ring
             ehookrp=ehookrp+(ratom-rp)**2
             go to 1
            endif
           enddo
C           6-ring
           ehookrh=ehookrh+(ratom-rh)**2
        endif
  1   enddo
      enddo

C     Bending
C     Loop over 5-rings
      ehookap=0.d0
      Do I=1,N5
      Do J=1,5
        JLX=J-1
        JRX=J+1
        if(JLX.eq.0) JLX=5
        if(JRX.eq.6) JRX=1
        JM=3*N5M(I,J)-2
        JL=3*N5M(I,JLX)-2
        JR=3*N5M(I,JRX)-2
         pxL=p(JM)  -p(JL)
         pyL=p(JM+1)-p(JL+1)
         pzL=p(JM+2)-p(JL+2)
        r2L=pxL*pxL+pyL*pyL+pzL*pzL
        r1L=dsqrt(r2L)
         pxR=p(JM)  -p(JR)
         pyR=p(JM+1)-p(JR+1)
         pzR=p(JM+2)-p(JR+2)
        r2R=pxR*pxR+pyR*pyR+pzR*pzR
        r1R=dsqrt(r2R)
         pxM=p(JL)  -p(JR)
         pyM=p(JL+1)-p(JR+1)
         pzM=p(JL+2)-p(JR+2)
        r2M=pxM*pxM+pyM*pyM+pzM*pzM
         cosarg=.5d0*(r2L+r2R-r2M)/(r1L*r1R)
         if(cosarg.ge.1.d0.or.cosarg.le.-1.d0) then
         IERR=1
         return
         endif
         anglep=dacos(cosarg)
         ehookap=ehookap+(anglep-ap)**2
      enddo
      enddo

C     Loop over 6-rings
      ehookah=0.d0
      if(N6.eq.0) go to 2
        Do I=1,N6
        Do J=1,6
        JLX=J-1
        JRX=J+1
        if(JLX.eq.0) JLX=6
        if(JRX.eq.7) JRX=1
        JM=3*N6M(I,J)  -2
        JL=3*N6M(I,JLX)-2
        JR=3*N6M(I,JRX)-2
         pxL=p(JM)  -p(JL)
         pyL=p(JM+1)-p(JL+1)
         pzL=p(JM+2)-p(JL+2)
        r2L=pxL*pxL+pyL*pyL+pzL*pzL
        r1L=dsqrt(r2L)
         pxR=p(JM)  -p(JR)
         pyR=p(JM+1)-p(JR+1)
         pzR=p(JM+2)-p(JR+2)
        r2R=pxR*pxR+pyR*pyR+pzR*pzR
        r1R=dsqrt(r2R)
         pxM=p(JL)  -p(JR)
         pyM=p(JL+1)-p(JR+1)
         pzM=p(JL+2)-p(JR+2)
        r2M=pxM*pxM+pyM*pyM+pzM*pzM
        cosarg=.5d0*(r2L+r2R-r2M)/(r1L*r1R)
         if(cosarg.ge.1.d0.or.cosarg.le.-1.d0) then
         IERR=1
         return
         endif
        angleh=dacos(cosarg)
        ehookah=ehookah+(angleh-ah)**2
      enddo
      enddo

C     total energy  
  2   fc=frp*ehookrp+frh*ehookrh+fap*ehookap+fah*ehookah
      Return
      END

      SUBROUTINE dfunc(NMAX,NMAX3,MMAX,n,A,N5,N6,N5M,N6M,p,x,c)
      IMPLICIT REAL*8 (A-H,O-Z)
C     Calculates the gradient of the harmonic oscillator potential of 
C     power npower and strength ehook using the Hueckel adjacency
C     matrix A and adds a Coulomb repulsion of strength coulomb
C     for all non-connected atoms. See function func for details.
      Real*8 p(NMAX3),x(NMAX3),c(8)
      Integer A(NMAX,NMAX)
      Integer N5M(MMAX,5),N6M(MMAX,6)
      rp=c(1)
      rh=c(2)
      ap=c(3)
      ah=c(4)
      frp=c(5)
      frh=c(6)
      fap=c(7)
      fah=c(8)
C     Stretching
      Do I=1,n,3
        ehookx=0.d0
        ehooky=0.d0
        ehookz=0.d0
      Do J=1,n,3
        I1=(I+2)/3
        J1=(J+2)/3
        if(A(I1,J1).ne.0) then
          px=p(I)-p(J)
          py=p(I+1)-p(J+1)
          pz=p(I+2)-p(J+2)
          ratom=dsqrt(px*px+py*py+pz*pz)
          ratominv=1.d0/ratom
C         Check if bond is part of 5-ring
          do IB=1,12
           ir1=0
           ir2=0
           do JB=1,5
            if(I1.eq.N5M(IB,JB)) ir1=1
            if(J1.eq.N5M(IB,JB)) ir2=1
           enddo
           if(ir1.eq.1.and.ir2.eq.1) then
C           5-ring
            fac=frp*ratominv*(ratom-rp)
            ehookx=ehookx+fac*px
            ehooky=ehooky+fac*py
            ehookz=ehookz+fac*pz
            go to 1
           endif
           enddo
C           6-ring
            fac=frh*ratominv*(ratom-rh)
            ehookx=ehookx+fac*px
            ehooky=ehooky+fac*py
            ehookz=ehookz+fac*pz
        endif
  1   enddo
        x(I)  =2.d0*ehookx
        x(I+1)=2.d0*ehooky
        x(I+2)=2.d0*ehookz
      enddo
        
C     Bending
C     Loop over 5-rings
      Do I=1,N5
      Do J=1,5
        JLX=J-1
        JRX=J+1
        if(JLX.eq.0) JLX=5
        if(JRX.eq.6) JRX=1
        JM=3*N5M(I,J)-2
        JL=3*N5M(I,JLX)-2
        JR=3*N5M(I,JRX)-2
         pxL=p(JM)  -p(JL)
         pyL=p(JM+1)-p(JL+1)
         pzL=p(JM+2)-p(JL+2)
        r2L=pxL*pxL+pyL*pyL+pzL*pzL
        r1L=dsqrt(r2L)
        r3L=r1L*r2L
         pxR=p(JM)  -p(JR)
         pyR=p(JM+1)-p(JR+1)
         pzR=p(JM+2)-p(JR+2)
        r2R=pxR*pxR+pyR*pyR+pzR*pzR
        r1R=dsqrt(r2R)
        r3R=r1R*r2R
         pxM=p(JL)  -p(JR)
         pyM=p(JL+1)-p(JR+1)
         pzM=p(JL+2)-p(JR+2)
        r2M=pxM*pxM+pyM*pyM+pzM*pzM
        r1M=dsqrt(r2M)
        r3M=r1M*r2M
         cosarg=.5d0*(r2L+r2R-r2M)/(r1L*r1R)
         if(cosarg.gt.1.d0) cosarg=1.d0
         if(cosarg.lt.-1.d0) cosarg=-1.d0
         anglep=dacos(cosarg)
         anglesin=dabs(dsin(anglep))
         fac=fap*(anglep-ap)/anglesin
C     Derivative of central atom
         fac1=fac/(r3R*r3L)
         r2RL=r2R-r2L
         r2LR=-r2RL
         fac2=r2RL-r2M
         fac3=r2LR-r2M
         fac4=r2R*fac2
         fac5=r2L*fac3
        x(JM)  =x(JM)  +fac1*(pxL*fac4+pxR*fac5)
        x(JM+1)=x(JM+1)+fac1*(pyL*fac4+pyR*fac5)
        x(JM+2)=x(JM+2)+fac1*(pzL*fac4+pzR*fac5)
C     Derivative of left atom
         fac6=-fac/(r3L*r1R)
        x(JL)  =x(JL)  +fac6*(pxL*fac3-2.d0*pxM*r2L)
        x(JL+1)=x(JL+1)+fac6*(pyL*fac3-2.d0*pyM*r2L)
        x(JL+2)=x(JL+2)+fac6*(pzL*fac3-2.d0*pzM*r2L)
C     Derivative of right atom
         fac7=-fac/(r3R*r1L)
        x(JR)  =x(JR)  +fac7*(pxR*fac2+2.d0*pxM*r2R)
        x(JR+1)=x(JR+1)+fac7*(pyR*fac2+2.d0*pyM*r2R)
        x(JR+2)=x(JR+2)+fac7*(pzR*fac2+2.d0*pzM*r2R)
      enddo
      enddo
      
C     Loop over 6-rings
      if(N6.eq.0) return
      Do I=1,N6
      Do J=1,6
        JLX=J-1
        JRX=J+1
        if(JLX.eq.0) JLX=6
        if(JRX.eq.7) JRX=1
        JM=3*N6M(I,J)-2
        JL=3*N6M(I,JLX)-2
        JR=3*N6M(I,JRX)-2
         pxL=p(JM)  -p(JL)
         pyL=p(JM+1)-p(JL+1)
         pzL=p(JM+2)-p(JL+2)
        r2L=pxL*pxL+pyL*pyL+pzL*pzL
        r1L=dsqrt(r2L)
        r3L=r1L*r2L
         pxR=p(JM)  -p(JR)
         pyR=p(JM+1)-p(JR+1)
         pzR=p(JM+2)-p(JR+2)
        r2R=pxR*pxR+pyR*pyR+pzR*pzR
        r1R=dsqrt(r2R)
        r3R=r1R*r2R
         pxM=p(JL)  -p(JR)
         pyM=p(JL+1)-p(JR+1)
         pzM=p(JL+2)-p(JR+2)
        r2M=pxM*pxM+pyM*pyM+pzM*pzM
        r1M=dsqrt(r2M)
        r3M=r1M*r2M
         cosarg=.5d0*(r2L+r2R-r2M)/(r1L*r1R)
         if(cosarg.gt.1.d0) cosarg=1.d0
         if(cosarg.lt.-1.d0) cosarg=-1.d0
         angleh=dacos(cosarg)
         anglesin=dabs(dsin(angleh))
         fac=fah*(angleh-ah)/anglesin
C     Derivative of central atom
         fac1=fac/(r3R*r3L)
         r2RL=r2R-r2L
         r2LR=-r2RL
        fac2=r2RL-r2M
        fac3=r2LR-r2M
        fac4=r2R*fac2
        fac5=r2L*fac3
        x(JM)  =x(JM)  +fac1*(pxL*fac4+pxR*fac5)
        x(JM+1)=x(JM+1)+fac1*(pyL*fac4+pyR*fac5)
        x(JM+2)=x(JM+2)+fac1*(pzL*fac4+pzR*fac5)
C     Derivative of left atom
         fac6=-fac/(r3L*r1R)
        x(JL)  =x(JL)  +fac6*(pxL*fac3-2.d0*pxM*r2L)
        x(JL+1)=x(JL+1)+fac6*(pyL*fac3-2.d0*pyM*r2L)
        x(JL+2)=x(JL+2)+fac6*(pzL*fac3-2.d0*pzM*r2L)
C     Derivative of right atom
         fac7=-fac/(r3R*r1L)
        x(JR)  =x(JR)  +fac7*(pxR*fac2+2.d0*pxM*r2R)
        x(JR+1)=x(JR+1)+fac7*(pyR*fac2+2.d0*pyM*r2R)
        x(JR+2)=x(JR+2)+fac7*(pzR*fac2+2.d0*pzM*r2R)
      enddo
      enddo

      return
      END

      SUBROUTINE f1dim(NMAX,NMAX3,MMAX,n,A,N5,N6,N5M,N6M,
     1 f1dimf,x,xicom,pcom,c)
      IMPLICIT REAL*8 (A-H,O-Z)
      REAL*8 pcom(NMAX3),xt(NMAX3),xicom(NMAX3),c(8)
      Integer A(NMAX,NMAX)
      Integer N5M(MMAX,5),N6M(MMAX,6)
C     USES func
      do j=1,n
        xt(j)=pcom(j)+x*xicom(j)
      enddo
      CALL func(NMAX,NMAX3,MMAX,n,IERR,A,N5,N6,N5M,N6M,xt,f1dimf,c)
      return
      END

      SUBROUTINE mnbrak(NMAX,NMAX3,MMAX,n,AH,N5,N6,N5M,N6M,
     1 ax,bx,cx,fa,fb,fc,xicom,pcom,c)
      IMPLICIT REAL*8 (A-H,O-Z)
      PARAMETER (GOLD=1.618034d0,GLIMIT=1.d2,TINY=1.d-20)
      Integer AH(NMAX,NMAX)
      Integer N5M(MMAX,5),N6M(MMAX,6)
      REAL*8 pcom(NMAX3),xicom(NMAX3),c(8)
      CALL f1dim(NMAX,NMAX3,MMAX,n,AH,N5,N6,N5M,N6M,fa,ax,xicom,pcom,c)
      CALL f1dim(NMAX,NMAX3,MMAX,n,AH,N5,N6,N5M,N6M,fb,bx,xicom,pcom,c)
      if(fb.gt.fa)then
        dum=ax
        ax=bx
        bx=dum
        dum=fb
        fb=fa
        fa=dum
      endif
      cx=bx+GOLD*(bx-ax)
      CALL f1dim(NMAX,NMAX3,MMAX,n,AH,N5,N6,N5M,N6M,fc,cx,xicom,pcom,c)
1     if(fb.ge.fc)then
        r=(bx-ax)*(fb-fc)
        q=(bx-cx)*(fb-fa)
        u=bx-((bx-cx)*q-(bx-ax)*r)/(2.*sign(max(dabs(q-r),TINY),q-r))
        ulim=bx+GLIMIT*(cx-bx)
        if((bx-u)*(u-cx).gt.0.)then
        CALL f1dim(NMAX,NMAX3,MMAX,n,AH,N5,N6,N5M,N6M,fu,u,xicom,pcom,c)
          if(fu.lt.fc)then
            ax=bx
            fa=fb
            bx=u
            fb=fu
            return
          else if(fu.gt.fb)then
            cx=u
            fc=fu
            return
          endif
          u=cx+GOLD*(cx-bx)
        CALL f1dim(NMAX,NMAX3,MMAX,n,AH,N5,N6,N5M,N6M,fu,u,xicom,pcom,c)
        else if((cx-u)*(u-ulim).gt.0.)then
        CALL f1dim(NMAX,NMAX3,MMAX,n,AH,N5,N6,N5M,N6M,fu,u,xicom,pcom,c)
          if(fu.lt.fc)then
            bx=cx
            cx=u
            u=cx+GOLD*(cx-bx)
            fb=fc
            fc=fu
        CALL f1dim(NMAX,NMAX3,MMAX,n,AH,N5,N6,N5M,N6M,fu,u,xicom,pcom,c)
          endif
        else if((u-ulim)*(ulim-cx).ge.0.)then
          u=ulim
        CALL f1dim(NMAX,NMAX3,MMAX,n,AH,N5,N6,N5M,N6M,fu,u,xicom,pcom,c)
        else
          u=cx+GOLD*(cx-bx)
        if(u.gt.1.d10) then
        Print*,'**** Error in Subroutine mnbrak'
        return
        endif
        CALL f1dim(NMAX,NMAX3,MMAX,n,AH,N5,N6,N5M,N6M,fu,u,xicom,pcom,c)
        endif
        ax=bx
        bx=cx
        cx=u
        fa=fb
        fb=fc
        fc=fu
        goto 1
      endif
      return
      END

      SUBROUTINE brent(NMAX,NMAX3,MMAX,n,AH,N5,N6,N5M,N6M,Iout,
     1 fx,ax,bx,cx,tol,xmin,xicom,pcom,c)
C BRENT is a FORTRAN library which contains algorithms for finding zeros 
C or minima of a scalar function of a scalar variable, by Richard Brent. 
      IMPLICIT REAL*8 (A-H,O-Z)
      PARAMETER (ITMAX=500,CGOLD=.3819660,ZEPS=1.d-10)
      REAL*8 pcom(NMAX3),xicom(NMAX3),c(8)
      Integer AH(NMAX,NMAX)
      Integer N5M(MMAX,5),N6M(MMAX,6)
      a=min(ax,cx)
      b=max(ax,cx)
      v=bx
      w=v
      x=v
      e=0.d0
      CALL f1dim(NMAX,NMAX3,MMAX,n,AH,N5,N6,N5M,N6M,fx,x,xicom,pcom,c)
      fv=fx
      fw=fx
      do 11 iter=1,ITMAX
        xm=0.5d0*(a+b)
        tol1=tol*dabs(x)+ZEPS
        tol2=2.d0*tol1
        if(dabs(x-xm).le.(tol2-.5d0*(b-a))) goto 3
        if(dabs(e).gt.tol1) then
          r=(x-w)*(fx-fv)
          q=(x-v)*(fx-fw)
          p=(x-v)*q-(x-w)*r
          q=2.d0*(q-r)
          if(q.gt.0.) p=-p
          q=abs(q)
          etemp=e
          e=d
          if(dabs(p).ge.abs(.5d0*q*etemp).or.p.le.q*(a-x).
     1      or.p.ge.q*(b-x)) goto 1
          d=p/q
          u=x+d
          if(u-a.lt.tol2 .or. b-u.lt.tol2) d=sign(tol1,xm-x)
          goto 2
        endif
1       if(x.ge.xm) then
          e=a-x
        else
          e=b-x
        endif
        d=CGOLD*e
2       if(dabs(d).ge.tol1) then
          u=x+d
        else
          u=x+sign(tol1,d)
        endif
        CALL f1dim(NMAX,NMAX3,MMAX,n,AH,N5,N6,N5M,N6M,fu,u,xicom,pcom,c)
        if(fu.le.fx) then
          if(u.ge.x) then
            a=x
          else
            b=x
          endif
          v=w
          fv=fw
          w=x
          fw=fx
          x=u
          fx=fu
        else
          if(u.lt.x) then
            a=u
          else
            b=u
          endif
          if(fu.le.fw .or. w.eq.x) then
            v=w
            fv=fw
            w=u
            fw=fu
          else if(fu.le.fv .or. v.eq.x .or. v.eq.w) then
            v=u
            fv=fu
          endif
        endif
11    continue
      Write(Iout,1000)
 1000 Format(' WARNING: Subroutine brent: maximum iterations exceeded')
3     xmin=x
      return
      END

      SUBROUTINE HamiltonCyc(NAtom,N,maxiter,A,Nhamilton)
C     Subroutine from Darko Babic to create Hamitonian cycles
C      oprimized for program Isomer
      integer list(natom,3,3),path(0:natom+1),stack(3*natom),pos(natom)
      integer bridge(natom),x(0:natom),y(0:natom),saved(natom)
      integer i,j,k,l,n,m,last,next,ngb1,ngb2,jlast,jnext,jngb1,jngb2
      integer ptr,prev,oldptr,cur,prv,nxt,ngb,diff,maxdif,relk,relbr
      logical occ(natom),pass(natom),end(natom),flag,better
      integer ic3(natom,3),A(natom,natom)
      
      ifirst=0 
      nhamilton=0
      nmax=30

      do i=1,n
        k=0
         do j=1,n
           if(A(I,J).eq.1) then
            k=k+1
            ic3(i,k)=j
            endif
         end do
      end do
      
      do i=1,n
         do j=1,3
            list(i,j,1)=ic3(i,j)
         end do
      end do

      do i=1,n
         do j=1,3
            k=list(i,j,1) 
            l=1
            do m=1,3
               if (list(k,m,1).ne.i) then
                  l=l+1
                  list(i,j,l)=m
               endif
            end do
         end do
      end do

      do i=1,n
         pass(i)=.false.
         occ(i)=.false.
         end(i)=.false.
      end do
      x(0)=n

      stack(1)=0
      stack(2)=0
      stack(3)=1
      stack(4)=1
      stack(5)=2
      oldptr=3
      ptr=6
      occ(1)=.true.
      last=1
      next=list(1,1,1)
      jnext=1
      end(list(1,2,1))=.true.
      end(list(1,3,1))=.true.
      flag=.false.
      l=1
      path(1)=1
      goto 5

    4 jngb1=list(prev,jlast,2)
      jngb2=list(prev,jlast,3)
      ngb1=list(last,jngb1,1)
      ngb2=list(last,jngb2,1)

      if (occ(ngb1)) then
         next=ngb2
         jnext=jngb2
      else
         if (occ(ngb2)) then
            next=ngb1
            jnext=jngb1
         else
            if (pass(ngb1)) then
               if (pass(ngb2).or.end(ngb1)) go to 6
               next=ngb1
               jnext=jngb1
               pass(ngb2)=.true.
               stack(ptr)=ngb2
               ptr=ptr+1
            else
               if (pass(ngb2)) then
                  if (end(ngb2)) go to 6
                  next=ngb2
                  jnext=jngb2
                  pass(ngb1)=.true.
                  stack(ptr)=ngb1
                  ptr=ptr+1
               else
                  next=ngb1
                  jnext=jngb1
                  pass(ngb2)=.true.
                  stack(ptr)=oldptr
                  stack(ptr+1)=l
                  stack(ptr+2)=jngb2
                  oldptr=ptr
                  ptr=ptr+3
               endif
            endif
         endif
      endif

    5 path(l+1)=next
      if (l.eq.n-1) then
      nhamilton=nhamilton+1
      if(nhamilton.gt.maxiter) Return
      endif

      if (end(next)) then
         if (flag.or.pass(next)) go to 6
         flag=.true.
      endif

      l=l+1
      occ(next)=.true.

      prev=last
      last=next
      jlast=jnext
      go to 4


    6 l1=stack(oldptr+1)
      do i=oldptr+3,ptr-1
         pass(stack(i))=.false.
      end do
      do i=l1+1,l
         occ(path(i))=.false.
         if (end(path(i))) flag=.false.
      end do
      ptr=oldptr
      oldptr=stack(ptr)
      pass(path(l1+1))=.true.
      stack(ptr)=path(l1+1)
      ptr=ptr+1
      last=path(l1)
      jnext=stack(ptr+1)
      next=list(last,jnext,1)
      pass(next)=.false.

      l=l1
      if (oldptr.gt.0) go to 5

      return
      end

      SUBROUTINE Hamilton(NAtom,n,Iout,iprint,maxiter,IC3)
C     Subroutine from Darko Babic to create Hamitonian cycles
C     and the IUPAC name of a fullerene
      integer list(natom,3,3),path(0:natom+1),stack(3*natom),pos(natom)
      integer bridge(natom),x(0:natom),y(0:natom),saved(natom)
      integer i,j,k,l,n,m,last,next,ngb1,ngb2,jlast,jnext,jngb1,jngb2
      integer ptr,prev,oldptr,cur,prv,nxt,ngb,diff,maxdif,relk,relbr
      logical occ(natom),pass(natom),end(natom),flag,better
      integer ic3(natom,3)
      
      ifirst=0 
      nhamilton=0
      nmax=30
      if(n.lt.nmax) nmax=n
      write (Iout,1009) maxiter
      do i=1,n
         do j=1,3
            list(i,j,1)=ic3(i,j)
         end do
      end do

      do i=1,n
         do j=1,3
            k=list(i,j,1) 
            l=1
            do m=1,3
               if (list(k,m,1).ne.i) then
                  l=l+1
                  list(i,j,l)=m
               endif
            end do
         end do
      end do

      do i=1,n
         pass(i)=.false.
         occ(i)=.false.
         end(i)=.false.
      end do
      x(0)=n

      stack(1)=0
      stack(2)=0
      stack(3)=1
      stack(4)=1
      stack(5)=2
      oldptr=3
      ptr=6
      occ(1)=.true.
      last=1
      next=list(1,1,1)
      jnext=1
      end(list(1,2,1))=.true.
      end(list(1,3,1))=.true.
      flag=.false.
      l=1
      path(1)=1
      goto 5

    4 jngb1=list(prev,jlast,2)
      jngb2=list(prev,jlast,3)
      ngb1=list(last,jngb1,1)
      ngb2=list(last,jngb2,1)

      if (occ(ngb1)) then
         next=ngb2
         jnext=jngb2
      else
         if (occ(ngb2)) then
            next=ngb1
            jnext=jngb1
         else
            if (pass(ngb1)) then
               if (pass(ngb2).or.end(ngb1)) go to 6
               next=ngb1
               jnext=jngb1
               pass(ngb2)=.true.
               stack(ptr)=ngb2
               ptr=ptr+1
            else
               if (pass(ngb2)) then
                  if (end(ngb2)) go to 6
                  next=ngb2
                  jnext=jngb2
                  pass(ngb1)=.true.
                  stack(ptr)=ngb1
                  ptr=ptr+1
               else
                  next=ngb1
                  jnext=jngb1
                  pass(ngb2)=.true.
                  stack(ptr)=oldptr
                  stack(ptr+1)=l
                  stack(ptr+2)=jngb2
                  oldptr=ptr
                  ptr=ptr+3
               endif
            endif
         endif
      endif

    5 path(l+1)=next
      if (l.eq.n-1) then
      nhamilton=nhamilton+1
      if(nhamilton.gt.maxiter) then
      write (Iout,1010) maxiter
      Return
      endif
      if(ifirst.eq.0) then
      write (Iout,1011)
      endif
      if(iprint.ne.0) then
      if(ifirst.eq.0) write (Iout,1005)
      write (Iout,1004) nhamilton,(path(j),j=1,nmax)
      if(n.gt.30) then
      do I=31,n,30
      jmax=I+29
      if(jmax.gt.n) jmax=n
      write (Iout,1001) (path(j),j=I,jmax)
      enddo
      endif
      endif
      ifirst=1
         do j=1,n           
            pos(path(j))=j
         end do
         path(0)=path(n)
         path(n+1)=path(1)

         maxdif=n
         do j=1,n
            cur=path(j)
            prv=path(j-1)
            nxt=path(j+1)
            do k=1,3
               ngb=list(cur,k,1)
               if (ngb.ne.prv.and.ngb.ne.nxt) then
                  bridge(j)=pos(ngb)
                  diff=abs(bridge(j)-j)
                  if (n-diff.gt.diff) diff=n-diff
                  if (maxdif.gt.diff) maxdif=diff
                  go to 11
               endif
            end do
   11    end do

         maxdif=maxdif-1
         if (maxdif.gt.x(0)) go to 6

         do 13 j=1,n
            better=.false.
            diff=mod(n+bridge(j)-j,n)-1
            if (diff.eq.maxdif) then
               if (maxdif.lt.x(0)) then
                  x(0)=maxdif
                  y(0)=n-maxdif-2
                  better=.true.
               endif
               i=0
               k=j
               do 14 m=1,n-1
                  k=mod(k,n)+1
                  relk=mod(n+k-j,n)+1
                  relbr=mod(n+bridge(k)-j,n)+1
                  if (relbr.lt.relk) go to 14
                  i=i+1
                  if (.not.better) then
                     if (x(i)-relk) 17,15,16
   15                if (y(i)-relbr) 17,14,16
   16                better=.true.
                  endif
                  x(i)=relk
                  y(i)=relbr
   14          continue
            endif

            if (better) then
               do m=1,n
                  saved(m)=path(m)
               end do
            end if
   17       better=.false.
            diff=n-diff-2
            if (diff.eq.maxdif) then
               if (maxdif.lt.x(0)) then
                  x(0)=maxdif
                  y(0)=n-maxdif-2
                  better=.true.
               endif
               i=0
               k=j
               do 18 m=1,n-1
                  k=mod(n+k-2,n)+1
                  relk=mod(n+j-k,n)+1
                  relbr=mod(n+j-bridge(k),n)+1
                  if (relbr.lt.relk) go to 18
                  i=i+1
                  if (.not.better) then
                     if (x(i)-relk) 13,19,20
   19                if (y(i)-relbr) 13,18,20
   20                better=.true.
                  endif
                  x(i)=relk
                  y(i)=relbr
   18          continue
            endif
            if (better) then
               do m=1,n
                  saved(m)=path(m)
               end do
            end if
   13    continue
         go to 6
      endif
      if (end(next)) then
         if (flag.or.pass(next)) go to 6
         flag=.true.
      endif

      l=l+1
      occ(next)=.true.

      prev=last
      last=next
      jlast=jnext
      go to 4


    6 l1=stack(oldptr+1)
      do i=oldptr+3,ptr-1
         pass(stack(i))=.false.
      end do
      do i=l1+1,l
         occ(path(i))=.false.
         if (end(path(i))) flag=.false.
      end do
      ptr=oldptr
      oldptr=stack(ptr)
      pass(path(l1+1))=.true.
      stack(ptr)=path(l1+1)
      ptr=ptr+1
      last=path(l1)
      jnext=stack(ptr+1)
      next=list(last,jnext,1)
      pass(next)=.false.

      l=l1
      if (oldptr.gt.0) go to 5

      if (x(0).eq.0) then
         write (Iout,1002) 
         Return
      endif
 
      write (Iout,1003) nhamilton
      write (Iout,1000) (x(i),i=0,(n-2)/2)
      write (Iout,1000) (y(i),i=0,(n-2)/2)
      write (Iout,1006)
      write (Iout,1008) (saved(j),j=1,n)
 1000 format (1X,i3,i5,98I3)
 1001 format (9X,30(I4,'-'))
 1002 format (/1X,'There is no Hamiltonian cycle in the graph!')
 1003 format (/1X,I10,' Hamiltonian cycles found',
     1 //1X,'Half-ring sizes and IUPAC superscripts:')
 1004 format (1X,I10,': ',30(I4,'-'))
 1005 format (/1X,'Distinct Hamiltonian cycles:',/6X,'NH    vertices',
     1 /1X,20('-'))
 1006 format (/1X,'The best Hamiltonian cycle:')
 1007 format (1X,'Next Hamiltonian cycles:')
 1008 format (30(I4,'-'))
 1009 format (/1X,'Calculate Hamiltonian cycles, half-ring sizes'
     1 ' and IUPAC superscripts: (D. Babic, J. Chem. Inf. Comput. Sci.'
     1 ' 35, 515-526 (1995).)',/1X,'Maximum allowed iteration: ',I10)
 1010 format (I10,' Maximum Hamiltonian cycles reached: Return')
 1011 format (1X,' Hamiltonian cycle detected')
      return
      end

      SUBROUTINE Paths(NAtom,Nedges,MAtom,IOUT,IA,A,evec,df)
      IMPLICIT REAL*8 (A-H,O-Z)
C Calculate the number of all possible distinct paths from the
C adjaceny matric A(i,j) by producing the (n-1)-th power
C of A. In this case n is Matom. This gives all possible walks
C of length (n-1).
      DIMENSION A(NAtom,NAtom),evec(NAtom),df(NAtom)
      DIMENSION IA(Natom,Natom),IM(Natom,Natom),IM2(Natom,Natom)
      DIMENSION IMF(Natom,Natom),IMF1(Natom,Natom)
      DIMENSION IS1(10),IS2(10),APN(10)
      DIMENSION B(NAtom,NAtom)
      Data Ihuge/600/
C     Epstein upper limit
      power=dfloat(MAtom)/3.d0
      ulepstein=2.d0**power
      If(power.lt.31.01d0) then
      ilepstein=dint(ulepstein)
      write (Iout,1005) ilepstein
      else
      If(power.gt.1.d3) then
      write (Iout,1008) 
      RETURN
      endif
      write (Iout,1000) ulepstein
      endif
      if(Matom.gt.Ihuge) then
      write (Iout,1008) 
      RETURN
      endif
      write (Iout,1001) 
C     This is only good for C20, C24 already causes integer overflow
      if(MAtom.eq.20) then
C     Produce symmetric A^2
      do i=1,MAtom
      do j=1,i
      IM(i,j)=0
      do k=1,MAtom
      IM(i,j)=IM(i,j)+IA(i,k)*IA(k,j)
      IM(j,i)=IM(i,j)
      enddo
      enddo
      enddo
C     Now loop do (A^2)^8
      do i=1,MAtom
      do j=1,i
      IMF(i,j)=IM(i,j)
      IMF(j,i)=IM(j,i)
      IMF1(i,j)=0
      IMF1(j,i)=0
      end do
      end do

      nloop=(MAtom-2)/2-1
      do loop=1,nloop
       do i=1,MAtom
       do j=1,MAtom
       do k=1,MAtom
       IMF1(i,j)=IMF1(i,j)+IMF(i,k)*IM(k,j)
       enddo
       enddo
       enddo
       do i=1,MAtom
       do j=1,MAtom
       IMF(i,j)=IMF1(i,j)
       IMF1(i,j)=0
       enddo
       enddo
      enddo

C     Now last multiplication with A
      do i=1,MAtom
      do j=1,MAtom
      do k=1,MAtom
      IMF1(i,j)=IMF1(i,j)+IMF(i,k)*IA(k,j)
      enddo
      enddo
      enddo
C     Now print number of paths for all vertices
      write (Iout,1002)
      do i=1,MAtom
      write (Iout,1003) i,(IMF1(i,j),j=1,10)
      enddo
      write (Iout,1004)
      do i=1,MAtom
      write (Iout,1003) i,(IMF1(i,j),j=11,20)
      enddo

      else
C     For larger matrices using Jordan decomposition is recommended where
C     A=LDL' where D is the diagonal matrix containing the eigenvalues of A
C     L is the matrix of eigenvector, L' its transposed
C     Then A^n = L D^n L' where D^n is the diagonal matric containing all
C     eigenvalues d^n (that is to the nth power)
C     This procedure is much faster and good for large graphs, but real 
C     matrix elements instead of integers are produced.
C     Diagonalize adjacency matrix A
      write (Iout,1007) 
      do i=1,MAtom
      do j=1,i
      A(i,j)=dfloat(IA(i,j))
      A(j,i)=A(i,j)
      enddo
      enddo
      call tred2(A,Matom,NAtom,evec,df)
      call tqli(evec,df,Matom,NAtom,A)
C     Calculate A^(n-1) = L D^(n-1) L but only printing the adjacent vertices
C     NP values
      mpower=Matom-1
      do i=1,MAtom
      evec(i)=evec(i)**mpower
      enddo

      limit=5
      ic=0
      do i=1,MAtom
      do j=1,i-1
      if(IA(i,j).eq.1) then
      ic=ic+1
      IS1(ic)=i
      IS2(ic)=j
      amat=0.d0
      do k=1,Matom
      amat=amat+A(i,k)*evec(k)*A(j,k)
      enddo
      APN(ic)=amat
      endif
      if(ic.eq.limit) then
      ic=0
      Write(IOUT,1006) (IS1(l),IS2(l),APN(l),l=1,limit)
      endif
      enddo
      enddo
      if(ic.ne.0) Write(IOUT,1006) (IS1(l),IS2(l),APN(l),l=1,ic)

      endif
 1000 Format(/1X,'Epstein upper limit for Hamiltonian cycles in '
     1 'cubic graphs: ',D22.14)
 1001 Format(/1X,'Calculate the number of paths (PN) of length (n-1) '
     1 '(n= number of vertices) between vertices i and j'
     1 /1X,'(elements of the (n-1) th power of the adjacency matrix)',
     1 /1X,'Matrix contains numbers PN of distinct paths ',
     1 '(including all Hamiltonian cycles):'
     1 /1X,'(Note this includes the possibility going through vertices'
     1 ' and edges multiple times)')
 1002 Format(/,'   i',5X,'1',9X,'2',9X,'3',9X,'4',9X,'5',9X,'6',9X,'7',
     1 9X,'8',9X,'9',9X,'10')
 1003 Format(1X,I3,10I10)
 1004 Format(/,'   i',5X,'11',8X,'12',8X,'13',8X,'14',8X,'15',8X,'16',
     1 8X,'17',8X,'18',8X,'19',8X,'20')
 1005 Format(/1X,'Epstein upper limit for Hamiltonian cycles in '
     1 'cubic graphs: ',I12)
 1006 Format(1X,5('('I3,',',I3,')',D21.14,','))
 1007 Format(1X,'Only matrix elements of adjacent vertices are printed')
 1008 Format(1X,'Number of paths of length (n-1) exceeds computer'
     1 ' real number limit -> Return')
      RETURN
      END

      SUBROUTINE powell(ndim,n,iter,Iout,IOP,ier,M,ftol,AN,RMDSI,p,Dist)
      IMPLICIT REAL*8 (A-H,O-Z)
      PARAMETER (NMAX=3,ITMAX=20,TINY=1.D-20)
      REAL*8 p(n),pcom(n),xicom(n),xi(n,n),pt(n),ptt(n),xit(n),step(n)
      REAL*8 Dist(3,ndim)
      
c numerical recipies cluster to do Powell minimization
c
c   p(n)      ... initial starting point (input); best point (output)
c   xi(n,n)   ... matrix containing the initial set of directions (input)
c   n         ... dimension; number of variables (input)
c   ftol      ... fractional tolerance in the function value (input)
c   iter      ... number of iterations taken
c   fret      ... value of f at p
      iter=0
      ier=0
      TOL=ftol
      If(IOP.eq.0) then
       Call MDSnorm(ndim,n,M,fret,RMDSI,p,Dist)
      else
       Call MAInorm(ndim,n,M,IP,AN,p,Dist)
       fret=-AN
      endif
      WRITE(IOUT,1002)
      WRITE(IOUT,1005) ftol,n
      do j=1,n
       step(j)=0.1d0
       pt(j)=p(j)
      enddo
      WRITE(IOUT,1006) (p(j),j=1,n),fret
        do i=1,n
        do j=1,i
          xi(j,i)=0.d0
          xi(i,j)=0.d0
          if(i.eq.j) xi(i,i)=step(i)
        enddo
        enddo
1     iter=iter+1
      fp=fret
      ibig=0
      del=0.d0
      do 13 i=1,n
        do 12 j=1,n
          xit(j)=xi(j,i)
12      continue
        fptt=fret
        call linminx(n,ndim,M,IOP,ier,TOL,p,xit,fret,pcom,xicom,Dist)
          if(ier.eq.1) Return
        if(dabs(fptt-fret).gt.del)then
          del=dabs(fptt-fret)
          ibig=i
        endif
13    continue
        WRITE(IOUT,1004) iter,(p(j),j=1,3),fret
      if(2.*dabs(fp-fret).le.ftol*(dabs(fp)+dabs(fret))+TINY) Return
      if(iter.eq.ITMAX) Go to 2
      do 14 j=1,n
        ptt(j)=2.*p(j)-pt(j)
        xit(j)=p(j)-pt(j)
        pt(j)=p(j)
14    continue
      If(IOP.eq.0) then
       Call MDSnorm(ndim,n,M,fptt,RMDSI,ptt,Dist)
      else
       Call MAInorm(ndim,n,M,IP,AN,ptt,Dist)
       fptt=-AN
      endif
      if(fptt.ge.fp)goto 1
      t=2.*(fp-2.*fret+fptt)*(fp-fret-del)**2-del*(fp-fptt)**2
      if(t.ge.0.)goto 1
      call linminx(n,ndim,M,IOP,ier,TOL,p,xit,fret,pcom,xicom,Dist)
      if(ier.eq.1) Return
      do 15 j=1,n
        xi(j,ibig)=xi(j,n)
        xi(j,n)=xit(j)
15    continue
      goto 1
 2    WRITE(IOUT,1007)
 1002 FORMAT(/1x,'Start Powell optimization')
 1004 FORMAT(' Iter: ',I6,' C(S): ',3(D14.8,1X)' Norm: ',D14.8)
 1005 Format(' Fractional tolerance ftol = ',D12.5,
     * ', dimension of problem n = ',i1)
 1006 FORMAT(' Start:       C(S): ',3(D14.8,1X),' Norm: ',D14.8)
 1007 Format(' WARNING: Optimizer Powell exceeding maximum iterations')
      Return
      END

      SUBROUTINE linminx(n,ndim,Mdim,IOP,ier,
     1 TOL,p,xi,fret,pcom,xicom,Dist)
      IMPLICIT REAL*8 (A-H,O-Z)
      REAL*8 p(n),xi(n),pcom(n),xicom(n)
      REAL*8 Dist(3,ndim)
CU    USES brentx,f1dimx,mnbrakx
      do 11 j=1,n
        pcom(j)=p(j)
        xicom(j)=xi(j)
11    continue
      ax=0.d0
      xx=1.d0
      call mnbrakx(n,ndim,Mdim,IOP,ier,
     1 pcom,xicom,ax,xx,bx,fa,fx,fb,Dist)
      if(ier.eq.1) Return
      fret=brentx(n,ndim,Mdim,IOP,pcom,xicom,ax,xx,bx,TOL,xmin,Dist)
      do 12 j=1,n
        xi(j)=xmin*xi(j)
        p(j)=p(j)+xi(j)
12    continue
      return
      END

      SUBROUTINE mnbrakx(ncom,ndim,Mdim,IOP,ier,pcom,xicom,ax,bx,cx,
     1 fa,fb,fc,Dist)
      IMPLICIT REAL*8 (A-H,O-Z)
      PARAMETER (GOLD=1.618034d0,GLIMIT=1.d2,TINY=1.d-20,HUGE=1.d10)
      REAL*8 pcom(ncom),xicom(ncom)
      REAL*8 Dist(3,ndim)
      fa=f1dimx(ncom,ndim,Mdim,IOP,ax,pcom,xicom,Dist)
      fb=f1dimx(ncom,ndim,Mdim,IOP,bx,pcom,xicom,Dist)
      if(fb.gt.fa)then
        dum=ax
        ax=bx
        bx=dum
        dum=fb
        fb=fa
        fa=dum
      endif
      cx=bx+GOLD*(bx-ax)
      fc=f1dimx(ncom,ndim,Mdim,IOP,cx,pcom,xicom,Dist)
1     if(fb.ge.fc)then
        r=(bx-ax)*(fb-fc)
        q=(bx-cx)*(fb-fa)
        if(ax.gt.HUGE.or.bx.gt.HUGE.or.CX.gt.HUGE) then
         ier=1
         Return
         endif
        u=bx-((bx-cx)*q-(bx-ax)*r)/(2.*sign(max(dabs(q-r),TINY),q-r))
        ulim=bx+GLIMIT*(cx-bx)
        if((bx-u)*(u-cx).gt.0.)then
          fu=f1dimx(ncom,ndim,Mdim,IOP,u,pcom,xicom,Dist)
          if(fu.lt.fc)then
            ax=bx
            fa=fb
            bx=u
            fb=fu
            return
          else if(fu.gt.fb)then
            cx=u
            fc=fu
            return
          endif
          u=cx+GOLD*(cx-bx)
          fu=f1dimx(ncom,ndim,Mdim,IOP,u,pcom,xicom,Dist)
        else if((cx-u)*(u-ulim).gt.0.d0)then
          fu=f1dimx(ncom,ndim,Mdim,IOP,u,pcom,xicom,Dist)
          if(fu.lt.fc)then
            bx=cx
            cx=u
            u=cx+GOLD*(cx-bx)
            fb=fc
            fc=fu
            fu=f1dimx(ncom,ndim,Mdim,IOP,u,pcom,xicom,Dist)
          endif
        else if((u-ulim)*(ulim-cx).ge.0.d0)then
          u=ulim
          fu=f1dimx(ncom,ndim,Mdim,IOP,u,pcom,xicom,Dist)
        else
          u=cx+GOLD*(cx-bx)
          fu=f1dimx(ncom,ndim,Mdim,IOP,u,pcom,xicom,Dist)
        endif
        ax=bx
        bx=cx
        cx=u
        fa=fb
        fb=fc
        fc=fu
        goto 1
      endif
      return
      END

      DOUBLE PRECISION FUNCTION brentx(ncom,ndim,Mdim,IOP,
     1 pcom,xicom,ax,bx,cx,tol,xmin,Dist)
      IMPLICIT REAL*8 (A-H,O-Z)
      REAL*8 Dist(3,ndim)
      REAL*8 pcom(ncom),xicom(ncom),xt(ncom)
      INTEGER ITMAX
      PARAMETER (ITMAX=100,CGOLD=.3819660,ZEPS=1.D-10)
      a=min(ax,cx)
      b=max(ax,cx)
      v=bx
      w=v
      x=v
      e=0.
      fx=f1dimx(ncom,ndim,Mdim,IOP,x,pcom,xicom,Dist)
      fv=fx
      fw=fx
      do 11 iter=1,ITMAX
        xm=0.5*(a+b)
        tol1=tol*dabs(x)+ZEPS
        tol2=2.*tol1
        if(dabs(x-xm).le.(tol2-.5*(b-a))) goto 3
        if(dabs(e).gt.tol1) then
          r=(x-w)*(fx-fv)
          q=(x-v)*(fx-fw)
          p=(x-v)*q-(x-w)*r
          q=2.*(q-r)
          if(q.gt.0.) p=-p
          q=dabs(q)
          etemp=e
          e=d
          if(dabs(p).ge.dabs(.5*q*etemp).or.p.le.q*(a-x).or.
     * p.ge.q*(b-x)) goto 1
          d=p/q
          u=x+d
          if(u-a.lt.tol2 .or. b-u.lt.tol2) d=sign(tol1,xm-x)
          goto 2
        endif
1       if(x.ge.xm) then
          e=a-x
        else
          e=b-x
        endif
        d=CGOLD*e
2       if(dabs(d).ge.tol1) then
          u=x+d
        else
          u=x+sign(tol1,d)
        endif
        fu=f1dimx(ncom,ndim,Mdim,IOP,u,pcom,xicom,Dist)
        if(fu.le.fx) then
          if(u.ge.x) then
            a=x
          else
            b=x
          endif
          v=w
          fv=fw
          w=x
          fw=fx
          x=u
          fx=fu
        else
          if(u.lt.x) then
            a=u
          else
            b=u
          endif
          if(fu.le.fw .or. w.eq.x) then
            v=w
            fv=fw
            w=u
            fw=fu
          else if(fu.le.fv .or. v.eq.x .or. v.eq.w) then
            v=u
            fv=fu
          endif
        endif
11    continue
      Print*, 'WARNING: brent exceed maximum iterations'
3     xmin=x
      brentx=fx
      return
      END

      DOUBLE PRECISION FUNCTION f1dimx(ncom,ndim,Mdim,IOP,
     1 x,pcom,xicom,Dist)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION pcom(ncom),xicom(ncom),xt(ncom)
      REAL*8 Dist(3,ndim)
      HUGE=dfloat(Mdim)*1.d2
      do 11 j=1,ncom
        xt(j)=pcom(j)+x*xicom(j)
11    continue
      If(IOP.eq.0) then
      Call MDSnorm(ndim,ncom,Mdim,AN,R,xt,Dist)
      f1dimx=AN
      else
      Call MAInorm(ndim,ncom,Mdim,IP,AN,xt,Dist)
      f1dimx=-AN
      endif
      if(AN.gt.Huge) then
      Print*,'**** Severe Error, check coordinates'
      stop
      endif
      return
      END
