#pragma once
#include "coord3d.cu"
#include "fullerenes/gpu/isomerspace_forcefield.hh"
#include <exception>

/** Container for internal fullerene coordinates, bond lengths, inner angles, outer angles, inner dihedral angles, outer dihedral angles.
/*  Doubles as container for harmonic equillibirium constants corresponding to, bond equillibrium length, inner equillbirium angle  ... etc.
/*  Used diagnostically to test quality of optimized structure or for comparison to other implementations fullerene optimization. **/



void IsomerspaceForcefield::InternalCoordinates::allocate(const size_t N, const size_t batch_size)
{   
    if((!allocated)){
        this->N = N; 
        this->batch_size = batch_size; 
        size_t bytes = sizeof(device_coord3d)*N*batch_size;
        cudaMalloc(&this->bonds, bytes);
        cudaMalloc(&this->angles, bytes);
        cudaMalloc(&this->outer_angles_m, bytes);
        cudaMalloc(&this->outer_angles_p, bytes);
        cudaMalloc(&this->dihedrals, bytes);
        cudaMalloc(&this->outer_dihedrals_a, bytes);
        cudaMalloc(&this->outer_dihedrals_m, bytes);
        cudaMalloc(&this->outer_dihedrals_p, bytes);
        printLastCudaError("Failed to allocate Internal Coordinates on device: ");
        this->allocated = true;
    }
    else{
        printf("\n Warning: Arrays already allocated, allocation is ignored\n");
    }
}
  

void IsomerspaceForcefield::InternalCoordinates::free()
{
    if(allocated){
        cudaFree(this->bonds);
        cudaFree(this->angles);
        cudaFree(this->outer_angles_m);
        cudaFree(this->outer_angles_p);
        cudaFree(this->dihedrals);
        cudaFree(this->outer_dihedrals_a);
        cudaFree(this->outer_dihedrals_m);
        cudaFree(this->outer_dihedrals_p);
        printLastCudaError("Failed to free Coordinates Device :");
        this->allocated = false;
    }
}


void IsomerspaceForcefield::InternalCoordinates::to_file(const IsomerspaceForcefield::InternalCoordinates& coords,size_t fullereneID, std::string ID){
    size_t N = coords.N;
    toBinary("Bonds" + ID + ".bin",coords.bonds,N,fullereneID);
    toBinary("Angles" + ID + ".bin",coords.angles,N,fullereneID);
    toBinary("Outer_Angles_m" + ID + ".bin",coords.outer_angles_m,N,fullereneID);
    toBinary("Outer_Angles_p" + ID + ".bin",coords.outer_angles_p,N,fullereneID);
    toBinary("Dihedrals" + ID + ".bin",coords.dihedrals,N,fullereneID);
    toBinary("Outer_Dihedrals_a" + ID + ".bin",coords.outer_dihedrals_a,N,fullereneID);
    toBinary("Outer_Dihedrals_m" + ID + ".bin",coords.outer_dihedrals_m,N,fullereneID);
    toBinary("Outer_Dihedrals_p" + ID + ".bin",coords.outer_dihedrals_p,N,fullereneID);

}
    



/** Container for cartesian fullerene coordinates and fullerene graph information generated by auxillary methods 
 *  Used to primarily to copy starting geometry and graph from host to device and copy the end-state back to the host.
 * **/
void IsomerspaceForcefield::DeviceGraph::allocate(const size_t N, const size_t batch_size)
{
    if (!allocated)
    {   
        this->N = N;
        this->batch_size = batch_size;
        cudaMalloc(&this->X, sizeof(device_coord3d)*N*batch_size);
        cudaMalloc(&this->neighbours, sizeof(device_node_t)*3*N*batch_size);
        cudaMalloc(&this->next_on_face, sizeof(device_node_t)*3*N*batch_size);
        cudaMalloc(&this->prev_on_face, sizeof(device_node_t)*3*N*batch_size);
        cudaMalloc(&this->face_right, sizeof(uint8_t)*3*N*batch_size);
        printLastCudaError("Failed to allocated device graph :");
        this->allocated = true;
    }
}

void IsomerspaceForcefield::DeviceGraph::allocate_host(const size_t N, const size_t batch_size){
    if (!allocated)
    {   
        this->N = N;
        this->batch_size = batch_size;
        X = new device_real_t[3*N*batch_size];
        neighbours = new device_node_t[3*N*batch_size];
        next_on_face = new device_node_t[3*N*batch_size];
        prev_on_face = new device_node_t[3*N*batch_size];
        face_right = new uint8_t[3*N*batch_size];
        this->allocated = true;
    }
}

void IsomerspaceForcefield::DeviceGraph::free()
{   
    if (allocated)
    {
        cudaFree(this->X);
        cudaFree(this->neighbours);
        cudaFree(this->next_on_face);
        cudaFree(this->prev_on_face);
        cudaFree(this->face_right);
        printLastCudaError("Failed to free device graph :");
        this->allocated = false;
    }
}

void IsomerspaceForcefield::DeviceGraph::free_host()
{   
    if (allocated)
    {
        delete X;
        delete neighbours;
        delete next_on_face;
        delete prev_on_face;
        delete face_right;
        printLastCudaError("Failed to free device graph :");
        this->allocated = false;
    }
}

void IsomerspaceForcefield::DeviceGraph::copy_to_gpu(const IsomerspaceForcefield::DeviceGraph& G){
    cudaMemcpy(X, G.X, sizeof(device_coord3d)*N*G.batch_size , cudaMemcpyHostToDevice);
    cudaMemcpy(neighbours, G.neighbours, sizeof(device_node_t)*3*N*G.batch_size, cudaMemcpyHostToDevice);
    cudaMemcpy(next_on_face, G.next_on_face, sizeof(device_node_t)*3*N*G.batch_size, cudaMemcpyHostToDevice);
    cudaMemcpy(prev_on_face, G.prev_on_face, sizeof(device_node_t)*3*N*G.batch_size, cudaMemcpyHostToDevice);
    cudaMemcpy(face_right, G.face_right, sizeof(uint8_t)*3*N*G.batch_size, cudaMemcpyHostToDevice);
    printLastCudaError("Failed to copy DeviceGraph :");
}




//Pentagons = 0
//Hexagons = 1
//PPP = 0, {HPP, PHP, PPH} = 1, {PHH, HPH, HHP} = 2, {HHH} = 3
__constant__ device_real_t optimal_corner_cos_angles[2] = {-0.30901699437494734, -0.5}; 
__constant__ device_real_t optimal_bond_lengths[3] = {1.479, 1.458, 1.401}; 
__constant__ device_real_t optimal_dih_cos_angles[8] = {0.7946545571495363, 0.872903607049519, 0.872903607049519, 0.9410338472965512, 0.8162879359966257, 0.9139497166300941, 0.9139497166300941, 1.}; 

#if SEMINARIO_FORCE_CONSTANTS==1
__constant__ device_real_t angle_forces[2] = {207.924,216.787}; 
__constant__ device_real_t bond_forces[3] = {260.0, 353.377, 518.992}; 
__constant__ device_real_t dih_forces[4] = {35.0,65.0,3.772,270.0}; 
#else
__constant__ device_real_t angle_forces[2] = {100.0,100.0}; 
__constant__ device_real_t bond_forces[3] = {260.0,390.0,450.0}; 
__constant__ device_real_t dih_forces[4] = {35.0,65.0,85.0,270.0}; 
#endif


struct NodeGraph{
    const device_node3 neighbours;
    const device_node3 next_on_face;
    const device_node3 prev_on_face;
    __device__ NodeGraph(const device_node3& neighbours, const device_node3& next_on_face, const device_node3& prev_on_face) : 
        neighbours(neighbours), next_on_face(next_on_face), prev_on_face(prev_on_face) {}


    __device__ NodeGraph(const IsomerspaceForcefield::DeviceGraph& G):  neighbours(make_uint3(G.neighbours[(threadIdx.x + blockDim.x*blockIdx.x)*3],G.neighbours[(threadIdx.x + blockDim.x*blockIdx.x)*3 + 1],G.neighbours[(threadIdx.x + blockDim.x*blockIdx.x)*3 + 2])),
                                                                        next_on_face(make_uint3(G.next_on_face[(threadIdx.x + blockDim.x*blockIdx.x)*3],G.next_on_face[(threadIdx.x + blockDim.x*blockIdx.x)*3 + 1],G.next_on_face[(threadIdx.x + blockDim.x*blockIdx.x)*3 + 2])),
                                                                        prev_on_face(make_uint3(G.prev_on_face[(threadIdx.x + blockDim.x*blockIdx.x)*3],G.prev_on_face[(threadIdx.x + blockDim.x*blockIdx.x)*3 + 1],G.prev_on_face[(threadIdx.x + blockDim.x*blockIdx.x)*3 + 2])){

    }
};

struct Constants{
    device_coord3d f_bond;
    device_coord3d f_inner_angle;
    device_coord3d f_inner_dihedral;
    device_coord3d f_outer_angle_m;
    device_coord3d f_outer_angle_p;
    device_coord3d f_outer_dihedral;

    device_coord3d r0;
    device_coord3d angle0;
    device_coord3d outer_angle_m0;
    device_coord3d outer_angle_p0;
    device_coord3d inner_dih0;
    device_coord3d outer_dih0_a;
    device_coord3d outer_dih0_m;
    device_coord3d outer_dih0_p;
    
    __device__ __host__ uint8_t face_index(uint8_t f1, uint8_t f2, uint8_t f3){
        return f1*4 + f2*2 + f3;
    }

    __device__ Constants(const IsomerspaceForcefield::DeviceGraph& G){
        size_t offset = blockDim.x*blockIdx.x;
        device_node_t* neighbours = G.neighbours + offset*3;
        device_node_t* next_on_face = G.next_on_face + offset*3; 
        device_node_t* prev_on_face = G.prev_on_face + offset*3; 
        uint8_t* face_right = G.face_right + offset*3;
        //       m    p
        //    f5_|   |_f4
        //   p   c    b  m
        //       \f1/
        //     f2 a f3
        //        |
        //        d
        //      m/\p
        //       f6

        for (uint8_t j = 0; j < 3; j++) {
            uint8_t F1 = face_right[threadIdx.x * 3 + j] - 5;
            uint8_t F3 = face_right[threadIdx.x * 3 + (2 + j)%3] - 5;

            uint8_t f_r_neighbour = face_right[neighbours[threadIdx.x * 3 + j]*3 ] - 5;
            uint8_t f_l_neighbour = face_right[neighbours[threadIdx.x * 3 + j]*3 + 1 ] - 5;
            uint8_t f_m_neighbour = face_right[neighbours[threadIdx.x * 3 + j]*3 + 2] - 5;
            uint8_t F4 = f_r_neighbour + f_l_neighbour + f_m_neighbour - F1 - F3 ;


            uint8_t face_sum = face_right[threadIdx.x * 3] - 5 + face_right[threadIdx.x * 3 + 1] - 5 + face_right[threadIdx.x * 3 + 2] - 5;
            uint8_t dihedral_face_sum = face_right[neighbours[threadIdx.x * 3 + j] * 3]-5 + face_right[neighbours[threadIdx.x * 3 + j] * 3 + 1]-5 +  face_right[neighbours[threadIdx.x * 3 + j] * 3 + 2]-5;

            //Load equillibirium distance, angles and dihedral angles from face information.
            d_set(r0,j,optimal_bond_lengths[ F3 + F1 ]);
            d_set(angle0,j,optimal_corner_cos_angles[ F1 ]);
            d_set(inner_dih0,j,optimal_dih_cos_angles[ face_index(face_right[threadIdx.x * 3 + j] - 5, face_right[threadIdx.x * 3 + (1+j)%3] - 5 , face_right[threadIdx.x * 3 + (2+j)%3] - 5) ]);
            d_set(outer_angle_m0,j,optimal_corner_cos_angles[ F3 ]);
            d_set(outer_angle_p0,j,optimal_corner_cos_angles[ F1 ]);
            
            uint8_t dihedral_index_a = face_index(F3,F4,F1);
            uint8_t dihedral_index_m =  face_index(F4, F1, F3);
            uint8_t dihedral_index_p = face_index(F1,F3, F4);

            d_set(outer_dih0_a,j,optimal_dih_cos_angles[dihedral_index_a]  );
            d_set(outer_dih0_m,j,optimal_dih_cos_angles[dihedral_index_m]  );
            d_set(outer_dih0_p,j,optimal_dih_cos_angles[dihedral_index_p]  );

            //Load force constants from neighbouring face information.
            d_set(f_bond,j,bond_forces[ F3 + F1 ]);
            d_set(f_inner_angle,j,angle_forces[ F1 ]);
            d_set(f_inner_dihedral,j,dih_forces[ face_sum]);
            d_set(f_outer_angle_m,j,angle_forces[ F3 ]);
            d_set(f_outer_angle_p,j,angle_forces[ F1 ]);
            d_set(f_outer_dihedral,j,dih_forces[ dihedral_face_sum]);
        }
    }   
};



